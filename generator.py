import json
import logging
from dataclasses import dataclass

import inflection

from pathlib import Path
from typing import Optional

logger = logging.getLogger('cdp.generate')

_python_type_lookup = {
    'string': 'str',
    'integer': 'int',
    'number': 'float',
    'boolean': 'bool',
    'object': 'dict',
    'array': 'list'
}

BASE_HEADER = f'''
# DO NOT EDIT THIS FILE!
#
# This file is generated from the CDP specification. If you need to make
# changes, edit the generator and regenerate this stub.
'''


BASE_IMPORTS = [
    ('dataclasses', ('dataclass',)),
    ('typing', ('TYPE_CHECKING',)),
    ('cdp.target.target', ('Target',)),
]


def indent(s: str, n: int):
    return ' ' * n + s


def snake_case(name: str) -> str:
    return inflection.underscore(name)


@dataclass
class CDPProtocol:
    version: 'CDPVersion'
    domains: list['CDPDomain']

    @classmethod
    def from_dict(cls, data: dict):
        self = cls(
            version=CDPVersion.from_dict(data.get('version')),
            domains=[]
        )

        for domain in data.get('domains', []):
            self.domains.append(
                CDPDomain.from_dict(
                    domain
                )
            )

        return self


@dataclass
class CDPDomain:
    domain: str
    description: Optional[str]
    experimental: bool
    deprecated: bool
    types: list['CDPType']
    commands: list['CDPCommand']
    events: list['CDPEvent']

    @classmethod
    def from_dict(cls, data: dict):
        self = cls(
            domain=data.get('domain'),
            description=data.get('description'),
            experimental=data.get('experimental'),
            deprecated=data.get('deprecated'),
            types=[],
            commands=[],
            events=[]
        )

        for type_ in data.get('types', []):
            self.types.append(
                CDPType.from_dict(
                    type_,
                    self
                )
            )

        for command in data.get('commands', []):
            self.commands.append(
                CDPCommand.from_dict(
                    command,
                    self
                )
            )

        for event in data.get('events', []):
            self.events.append(
                CDPEvent.from_dict(
                    event,
                    self
                )
            )

        return self

    @property
    def class_name(self):
        return self.domain

    def generate_class(self):
        definition = f'class {self.class_name}\n\n'

        for method in self.commands:
            definition += indent(f'def {method.method_name}(\n', 4)
            definition += indent(f'self', 12)

            if method.parameters:
                definition += ',\n'

            else:
                definition += '\n'

            for i, parameter in enumerate(method.parameters):
                is_last = i == len(method.parameters) - 1

                parameter = f'{parameter.python_name}: {parameter.python_type} = ...'
                definition += indent(f'{parameter}', 12)

                if not is_last:
                    definition += ','

                definition += '\n'

            definition += indent(f'):\n', 4)
            definition += indent(f'...\n\n', 8)

        return definition


@dataclass
class CDPCommand:
    domain: 'CDPDomain'
    name: str
    description: str
    parameters: list['CDPParameter']
    returns: list['CDPReturn']
    experimental: bool
    deprecated: bool

    @property
    def method_name(self):
        return snake_case(self.name)

    @classmethod
    def from_dict(cls, data: dict, domain: 'CDPDomain'):
        self = cls(
            domain=domain,
            name=data.get('name'),
            description=data.get('description'),
            parameters=[],
            returns=[],
            experimental=data.get('experimental'),
            deprecated=data.get('deprecated')
        )

        for p in data.get('parameters', []):
            self.parameters.append(CDPParameter.from_dict(p))

        for r in data.get('returns', []):
            self.returns.append(CDPReturn.from_dict(r))

        return self


@dataclass
class CDPEvent:
    domain: 'CDPDomain'
    name: str
    description: str
    parameters: list
    experimental: bool
    deprecated: bool

    @classmethod
    def from_dict(cls, data: dict, domain: 'CDPDomain'):
        self = cls(
            domain=domain,
            name=data.get('name'),
            description=data.get('description'),
            parameters=[],
            experimental=data.get('experimental'),
            deprecated=data.get('deprecated')
        )

        for p in data.get('parameters', []):
            self.parameters.append(CDPParameter.from_dict(p))

        return self


@dataclass
class CDPType:
    domain: 'CDPDomain'
    id: str
    type: str
    description: str
    enum: list[str]
    properties: list['CDPProperty']

    @classmethod
    def from_dict(cls, data: dict, domain: 'CDPDomain'):
        self = cls(
            domain=domain,
            id=data.get('id'),
            type=data.get('type'),
            description=data.get('description'),
            enum=data.get('enum'),
            properties=[]
        )

        for p in data.get('properties', []):
            self.properties.append(CDPProperty.from_dict(p))

        return self


@dataclass
class CDPVersion:
    major: int
    minor: int

    @classmethod
    def from_dict(cls, data: dict):
        return cls(
            major=data.get('major'),
            minor=data.get('minor')
        )


@dataclass
class CDPItems:
    type: Optional[str]
    ref: Optional[str]

    @classmethod
    def from_dict(cls, data: dict):
        return cls(
            type=data.get('type'),
            ref=data.get('$ref')
        )


@dataclass
class CDPProperty:
    name: str
    description: Optional[str]
    type: Optional[str]
    ref: Optional[str]
    enum: Optional[list[str]]
    items: Optional[CDPItems]
    optional: bool
    experimental: bool
    deprecated: bool

    @property
    def python_type(self):
        return _python_type_lookup.get(self.type, self.type)

    @classmethod
    def from_dict(cls, data: dict):
        self = cls(
            name=data.get('name'),
            description=data.get('description'),
            type=data.get('type'),
            ref=data.get('$ref'),
            enum=data.get('enum', []),
            items=None,
            optional=data.get('optional'),
            experimental=data.get('experimental'),
            deprecated=data.get('deprecated')
        )

        if items := data.get('items'):
            self.items = CDPItems.from_dict(items)

        return self


@dataclass
class CDPParameter(CDPProperty):
    @property
    def python_name(self):
        return snake_case(self.name)


@dataclass
class CDPReturn(CDPProperty):
    pass


def main():
    protocol_browser = Path('static/protocols/1.3/browser_protocol.json')
    protocol_js = Path('static/protocols/1.3/js_protocol.json')

    browser_protocol = CDPProtocol.from_dict(
        json.loads(
            protocol_browser.read_text()
        )
    )

    # protocol_js = CDPProtocol.from_dict(
    #     json.loads(
    #         protocol_js.read_text()
    #     )
    # )
    #
    # output = Path('cdp/domains/domains.pyi')
    # output.unlink(missing_ok=True)
    # output.touch()

    # with open(output, 'w') as file:
    #     file.write(BASE_HEADER + '\n\n')

    for domain in browser_protocol.domains:
        print(domain.generate_class())


if __name__ == '__main__':
    main()
