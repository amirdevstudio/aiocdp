# DO NOT EDIT THIS FILE
#
# This file is generated by the generator. To make changes, edit the generator
# and run it again.

from dataclasses import (
    dataclass
)
from typing import (
    TYPE_CHECKING
)
from typing import (
    Any
)
if TYPE_CHECKING:
    from cdp.domains.runtime.types import (
        CallFrame,
        ScriptId
    )


@dataclass
class ProfileNode:
    id: int
    call_frame: 'CallFrame'
    hit_count: int
    children: list
    deopt_reason: str
    position_ticks: list
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'id': self.id_,
                'call_frame': self.call_frame.to_dict(
                    casing_strategy
                ),
                'hit_count': self.hit_count,
                'children': self.children,
                'deopt_reason': self.deopt_reason,
                'position_ticks': _.to_dict(
                    casing_strategy
                )_position_ticks,
            }
        if casing_strategy == 'snake':
            return {
                'id': self.id_,
                'callFrame': self.call_frame.to_dict(
                    casing_strategy
                ),
                'hitCount': self.hit_count,
                'children': self.children,
                'deoptReason': self.deopt_reason,
                'positionTicks': _.to_dict(
                    casing_strategy
                )_position_ticks,
            }
        if casing_strategy == 'snake':
            return {
                'Id': self.id_,
                'CallFrame': self.call_frame.to_dict(
                    casing_strategy
                ),
                'HitCount': self.hit_count,
                'Children': self.children,
                'DeoptReason': self.deopt_reason,
                'PositionTicks': _.to_dict(
                    casing_strategy
                )_position_ticks,
            }


@dataclass
class Profile:
    nodes: list
    start_time: float
    end_time: float
    samples: list
    time_deltas: list
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'nodes': _.to_dict(
                    casing_strategy
                )_nodes,
                'start_time': self.start_time,
                'end_time': self.end_time,
                'samples': self.samples,
                'time_deltas': self.time_deltas,
            }
        if casing_strategy == 'snake':
            return {
                'nodes': _.to_dict(
                    casing_strategy
                )_nodes,
                'startTime': self.start_time,
                'endTime': self.end_time,
                'samples': self.samples,
                'timeDeltas': self.time_deltas,
            }
        if casing_strategy == 'snake':
            return {
                'Nodes': _.to_dict(
                    casing_strategy
                )_nodes,
                'StartTime': self.start_time,
                'EndTime': self.end_time,
                'Samples': self.samples,
                'TimeDeltas': self.time_deltas,
            }


@dataclass
class PositionTickInfo:
    line: int
    ticks: int
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'line': self.line,
                'ticks': self.ticks,
            }
        if casing_strategy == 'snake':
            return {
                'line': self.line,
                'ticks': self.ticks,
            }
        if casing_strategy == 'snake':
            return {
                'Line': self.line,
                'Ticks': self.ticks,
            }


@dataclass
class CoverageRange:
    start_offset: int
    end_offset: int
    count: int
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'start_offset': self.start_offset,
                'end_offset': self.end_offset,
                'count': self.count,
            }
        if casing_strategy == 'snake':
            return {
                'startOffset': self.start_offset,
                'endOffset': self.end_offset,
                'count': self.count,
            }
        if casing_strategy == 'snake':
            return {
                'StartOffset': self.start_offset,
                'EndOffset': self.end_offset,
                'Count': self.count,
            }


@dataclass
class FunctionCoverage:
    function_name: str
    ranges: list
    is_block_coverage: bool
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'function_name': self.function_name,
                'ranges': _.to_dict(
                    casing_strategy
                )_ranges,
                'is_block_coverage': self.is_block_coverage,
            }
        if casing_strategy == 'snake':
            return {
                'functionName': self.function_name,
                'ranges': _.to_dict(
                    casing_strategy
                )_ranges,
                'isBlockCoverage': self.is_block_coverage,
            }
        if casing_strategy == 'snake':
            return {
                'FunctionName': self.function_name,
                'Ranges': _.to_dict(
                    casing_strategy
                )_ranges,
                'IsBlockCoverage': self.is_block_coverage,
            }


@dataclass
class ScriptCoverage:
    script_id: 'ScriptId'
    url: str
    functions: list
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'script_id': self.script_id.to_dict(
                    casing_strategy
                ),
                'url': self.url,
                'functions': _.to_dict(
                    casing_strategy
                )_functions,
            }
        if casing_strategy == 'snake':
            return {
                'scriptId': self.script_id.to_dict(
                    casing_strategy
                ),
                'url': self.url,
                'functions': _.to_dict(
                    casing_strategy
                )_functions,
            }
        if casing_strategy == 'snake':
            return {
                'ScriptId': self.script_id.to_dict(
                    casing_strategy
                ),
                'Url': self.url,
                'Functions': _.to_dict(
                    casing_strategy
                )_functions,
            }


@dataclass
class TypeObject:
    name: str
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'name': self.name,
            }
        if casing_strategy == 'snake':
            return {
                'name': self.name,
            }
        if casing_strategy == 'snake':
            return {
                'Name': self.name,
            }


@dataclass
class TypeProfileEntry:
    offset: int
    types: list
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'offset': self.offset,
                'types': _.to_dict(
                    casing_strategy
                )_types,
            }
        if casing_strategy == 'snake':
            return {
                'offset': self.offset,
                'types': _.to_dict(
                    casing_strategy
                )_types,
            }
        if casing_strategy == 'snake':
            return {
                'Offset': self.offset,
                'Types': _.to_dict(
                    casing_strategy
                )_types,
            }


@dataclass
class ScriptTypeProfile:
    script_id: 'ScriptId'
    url: str
    entries: list
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'script_id': self.script_id.to_dict(
                    casing_strategy
                ),
                'url': self.url,
                'entries': _.to_dict(
                    casing_strategy
                )_entries,
            }
        if casing_strategy == 'snake':
            return {
                'scriptId': self.script_id.to_dict(
                    casing_strategy
                ),
                'url': self.url,
                'entries': _.to_dict(
                    casing_strategy
                )_entries,
            }
        if casing_strategy == 'snake':
            return {
                'ScriptId': self.script_id.to_dict(
                    casing_strategy
                ),
                'Url': self.url,
                'Entries': _.to_dict(
                    casing_strategy
                )_entries,
            }


@dataclass
class GetBestEffortCoverageReturnT:
    result: list


@dataclass
class StopReturnT:
    profile: 'Profile'


@dataclass
class TakePreciseCoverageReturnT:
    result: list


@dataclass
class TakeTypeProfileReturnT:
    result: list
