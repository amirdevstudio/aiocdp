# DO NOT EDIT THIS FILE
#
# This file is generated by the generator. To make changes, edit the generator
# and run it again.

from typing import (
    Any,
    Literal,
    TYPE_CHECKING
)
from dataclasses import (
    dataclass
)
if TYPE_CHECKING:
    from cdp.domains.page.types import (
        FrameId
    )
    from cdp.domains.runtime.types import (
        ExecutionContextId,
        RemoteObject,
        RemoteObjectId,
        StackTrace
    )

NodeId = int

BackendNodeId = int

Quad = list[float]

PseudoType = Literal[
    'first-line',
    'first-letter',
    'before',
    'after',
    'marker',
    'backdrop',
    'selection',
    'target-text',
    'spelling-error',
    'grammar-error',
    'highlight',
    'first-line-inherited',
    'scrollbar',
    'scrollbar-thumb',
    'scrollbar-button',
    'scrollbar-track',
    'scrollbar-track-piece',
    'scrollbar-corner',
    'resizer',
    'input-list-button',
    'view-transition',
    'view-transition-group',
    'view-transition-image-pair',
    'view-transition-old',
    'view-transition-new'
]

ShadowRootType = Literal[
    'user-agent',
    'open',
    'closed'
]

CompatibilityMode = Literal[
    'QuirksMode',
    'LimitedQuirksMode',
    'NoQuirksMode'
]

PhysicalAxes = Literal[
    'Horizontal',
    'Vertical',
    'Both'
]

LogicalAxes = Literal[
    'Inline',
    'Block',
    'Both'
]


@dataclass
class BackendNode:
    node_type: int
    node_name: str
    backend_node_id: 'BackendNodeId'
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'node_type': self.node_type,
                'node_name': self.node_name,
                'backend_node_id': self.backend_node_id.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'camel':
            return {
                'nodeType': self.node_type,
                'nodeName': self.node_name,
                'backendNodeId': self.backend_node_id.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'pascal':
            return {
                'NodeType': self.node_type,
                'NodeName': self.node_name,
                'BackendNodeId': self.backend_node_id.to_dict(
                    casing_strategy
                ),
            }


@dataclass
class Node:
    node_id: 'NodeId'
    parent_id: 'NodeId'
    backend_node_id: 'BackendNodeId'
    node_type: int
    node_name: str
    local_name: str
    node_value: str
    child_node_count: int
    children: list
    attributes: list
    document_url: str
    base_url: str
    public_id: str
    system_id: str
    internal_subset: str
    xml_version: str
    name: str
    value: str
    pseudo_type: 'PseudoType'
    pseudo_identifier: str
    shadow_root_type: 'ShadowRootType'
    frame_id: 'FrameId'
    content_document: 'Node'
    shadow_roots: list
    template_content: 'Node'
    pseudo_elements: list
    imported_document: 'Node'
    distributed_nodes: list
    is_svg: bool
    compatibility_mode: 'CompatibilityMode'
    assigned_slot: 'BackendNode'
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'node_id': self.node_id.to_dict(
                    casing_strategy
                ),
                'parent_id': self.parent_id.to_dict(
                    casing_strategy
                ),
                'backend_node_id': self.backend_node_id.to_dict(
                    casing_strategy
                ),
                'node_type': self.node_type,
                'node_name': self.node_name,
                'local_name': self.local_name,
                'node_value': self.node_value,
                'child_node_count': self.child_node_count,
                'children': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.children
                ],
                'attributes': self.attributes,
                'document_url': self.document_url,
                'base_url': self.base_url,
                'public_id': self.public_id,
                'system_id': self.system_id,
                'internal_subset': self.internal_subset,
                'xml_version': self.xml_version,
                'name': self.name,
                'value': self.value,
                'pseudo_type': self.pseudo_type,
                'pseudo_identifier': self.pseudo_identifier,
                'shadow_root_type': self.shadow_root_type,
                'frame_id': self.frame_id.to_dict(
                    casing_strategy
                ),
                'content_document': self.content_document.to_dict(
                    casing_strategy
                ),
                'shadow_roots': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.shadow_roots
                ],
                'template_content': self.template_content.to_dict(
                    casing_strategy
                ),
                'pseudo_elements': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.pseudo_elements
                ],
                'imported_document': self.imported_document.to_dict(
                    casing_strategy
                ),
                'distributed_nodes': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.distributed_nodes
                ],
                'is_svg': self.is_svg,
                'compatibility_mode': self.compatibility_mode,
                'assigned_slot': self.assigned_slot.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'camel':
            return {
                'nodeId': self.node_id.to_dict(
                    casing_strategy
                ),
                'parentId': self.parent_id.to_dict(
                    casing_strategy
                ),
                'backendNodeId': self.backend_node_id.to_dict(
                    casing_strategy
                ),
                'nodeType': self.node_type,
                'nodeName': self.node_name,
                'localName': self.local_name,
                'nodeValue': self.node_value,
                'childNodeCount': self.child_node_count,
                'children': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.children
                ],
                'attributes': self.attributes,
                'documentURL': self.document_url,
                'baseURL': self.base_url,
                'publicId': self.public_id,
                'systemId': self.system_id,
                'internalSubset': self.internal_subset,
                'xmlVersion': self.xml_version,
                'name': self.name,
                'value': self.value,
                'pseudoType': self.pseudo_type,
                'pseudoIdentifier': self.pseudo_identifier,
                'shadowRootType': self.shadow_root_type,
                'frameId': self.frame_id.to_dict(
                    casing_strategy
                ),
                'contentDocument': self.content_document.to_dict(
                    casing_strategy
                ),
                'shadowRoots': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.shadow_roots
                ],
                'templateContent': self.template_content.to_dict(
                    casing_strategy
                ),
                'pseudoElements': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.pseudo_elements
                ],
                'importedDocument': self.imported_document.to_dict(
                    casing_strategy
                ),
                'distributedNodes': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.distributed_nodes
                ],
                'isSVG': self.is_svg,
                'compatibilityMode': self.compatibility_mode,
                'assignedSlot': self.assigned_slot.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'pascal':
            return {
                'NodeId': self.node_id.to_dict(
                    casing_strategy
                ),
                'ParentId': self.parent_id.to_dict(
                    casing_strategy
                ),
                'BackendNodeId': self.backend_node_id.to_dict(
                    casing_strategy
                ),
                'NodeType': self.node_type,
                'NodeName': self.node_name,
                'LocalName': self.local_name,
                'NodeValue': self.node_value,
                'ChildNodeCount': self.child_node_count,
                'Children': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.children
                ],
                'Attributes': self.attributes,
                'DocumentURL': self.document_url,
                'BaseURL': self.base_url,
                'PublicId': self.public_id,
                'SystemId': self.system_id,
                'InternalSubset': self.internal_subset,
                'XmlVersion': self.xml_version,
                'Name': self.name,
                'Value': self.value,
                'PseudoType': self.pseudo_type,
                'PseudoIdentifier': self.pseudo_identifier,
                'ShadowRootType': self.shadow_root_type,
                'FrameId': self.frame_id.to_dict(
                    casing_strategy
                ),
                'ContentDocument': self.content_document.to_dict(
                    casing_strategy
                ),
                'ShadowRoots': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.shadow_roots
                ],
                'TemplateContent': self.template_content.to_dict(
                    casing_strategy
                ),
                'PseudoElements': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.pseudo_elements
                ],
                'ImportedDocument': self.imported_document.to_dict(
                    casing_strategy
                ),
                'DistributedNodes': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.distributed_nodes
                ],
                'IsSVG': self.is_svg,
                'CompatibilityMode': self.compatibility_mode,
                'AssignedSlot': self.assigned_slot.to_dict(
                    casing_strategy
                ),
            }


@dataclass
class RGBA:
    r: int
    g: int
    b: int
    a: float
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'r': self.r,
                'g': self.g,
                'b': self.b,
                'a': self.a,
            }
        if casing_strategy == 'camel':
            return {
                'r': self.r,
                'g': self.g,
                'b': self.b,
                'a': self.a,
            }
        if casing_strategy == 'pascal':
            return {
                'R': self.r,
                'G': self.g,
                'B': self.b,
                'A': self.a,
            }


@dataclass
class BoxModel:
    content: 'Quad'
    padding: 'Quad'
    border: 'Quad'
    margin: 'Quad'
    width: int
    height: int
    shape_outside: 'ShapeOutsideInfo'
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'content': self.content.to_dict(
                    casing_strategy
                ),
                'padding': self.padding.to_dict(
                    casing_strategy
                ),
                'border': self.border.to_dict(
                    casing_strategy
                ),
                'margin': self.margin.to_dict(
                    casing_strategy
                ),
                'width': self.width,
                'height': self.height,
                'shape_outside': self.shape_outside.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'camel':
            return {
                'content': self.content.to_dict(
                    casing_strategy
                ),
                'padding': self.padding.to_dict(
                    casing_strategy
                ),
                'border': self.border.to_dict(
                    casing_strategy
                ),
                'margin': self.margin.to_dict(
                    casing_strategy
                ),
                'width': self.width,
                'height': self.height,
                'shapeOutside': self.shape_outside.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'pascal':
            return {
                'Content': self.content.to_dict(
                    casing_strategy
                ),
                'Padding': self.padding.to_dict(
                    casing_strategy
                ),
                'Border': self.border.to_dict(
                    casing_strategy
                ),
                'Margin': self.margin.to_dict(
                    casing_strategy
                ),
                'Width': self.width,
                'Height': self.height,
                'ShapeOutside': self.shape_outside.to_dict(
                    casing_strategy
                ),
            }


@dataclass
class ShapeOutsideInfo:
    bounds: 'Quad'
    shape: list
    margin_shape: list
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'bounds': self.bounds.to_dict(
                    casing_strategy
                ),
                'shape': self.shape,
                'margin_shape': self.margin_shape,
            }
        if casing_strategy == 'camel':
            return {
                'bounds': self.bounds.to_dict(
                    casing_strategy
                ),
                'shape': self.shape,
                'marginShape': self.margin_shape,
            }
        if casing_strategy == 'pascal':
            return {
                'Bounds': self.bounds.to_dict(
                    casing_strategy
                ),
                'Shape': self.shape,
                'MarginShape': self.margin_shape,
            }


@dataclass
class Rect:
    x: float
    y: float
    width: float
    height: float
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'x': self.x,
                'y': self.y,
                'width': self.width,
                'height': self.height,
            }
        if casing_strategy == 'camel':
            return {
                'x': self.x,
                'y': self.y,
                'width': self.width,
                'height': self.height,
            }
        if casing_strategy == 'pascal':
            return {
                'X': self.x,
                'Y': self.y,
                'Width': self.width,
                'Height': self.height,
            }


@dataclass
class CSSComputedStyleProperty:
    name: str
    value: str
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'name': self.name,
                'value': self.value,
            }
        if casing_strategy == 'camel':
            return {
                'name': self.name,
                'value': self.value,
            }
        if casing_strategy == 'pascal':
            return {
                'Name': self.name,
                'Value': self.value,
            }


@dataclass
class CollectClassNamesFromSubtreeReturnT:
    class_names: list


@dataclass
class CopyToReturnT:
    node_id: 'NodeId'


@dataclass
class DescribeNodeReturnT:
    node: 'Node'


@dataclass
class GetAttributesReturnT:
    attributes: list


@dataclass
class GetBoxModelReturnT:
    model: 'BoxModel'


@dataclass
class GetContentQuadsReturnT:
    quads: list


@dataclass
class GetDocumentReturnT:
    root: 'Node'


@dataclass
class GetFlattenedDocumentReturnT:
    nodes: list


@dataclass
class GetNodesForSubtreeByStyleReturnT:
    node_ids: list


@dataclass
class GetNodeForLocationReturnT:
    backend_node_id: 'BackendNodeId'
    frame_id: 'FrameId'
    node_id: 'NodeId'


@dataclass
class GetOuterHTMLReturnT:
    outer_html: str


@dataclass
class GetRelayoutBoundaryReturnT:
    node_id: 'NodeId'


@dataclass
class GetSearchResultsReturnT:
    node_ids: list


@dataclass
class MoveToReturnT:
    node_id: 'NodeId'


@dataclass
class PerformSearchReturnT:
    search_id: str
    result_count: int


@dataclass
class PushNodeByPathToFrontendReturnT:
    node_id: 'NodeId'


@dataclass
class PushNodesByBackendIdsToFrontendReturnT:
    node_ids: list


@dataclass
class QuerySelectorReturnT:
    node_id: 'NodeId'


@dataclass
class QuerySelectorAllReturnT:
    node_ids: list


@dataclass
class GetTopLayerElementsReturnT:
    node_ids: list


@dataclass
class RequestNodeReturnT:
    node_id: 'NodeId'


@dataclass
class ResolveNodeReturnT:
    object: 'RemoteObject'


@dataclass
class GetNodeStackTracesReturnT:
    creation: 'StackTrace'


@dataclass
class GetFileInfoReturnT:
    path: str


@dataclass
class SetNodeNameReturnT:
    node_id: 'NodeId'


@dataclass
class GetFrameOwnerReturnT:
    backend_node_id: 'BackendNodeId'
    node_id: 'NodeId'


@dataclass
class GetContainerForNodeReturnT:
    node_id: 'NodeId'


@dataclass
class GetQueryingDescendantsForContainerReturnT:
    node_ids: list
