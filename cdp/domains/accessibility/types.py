# DO NOT EDIT THIS FILE
#
# This file is generated by the generator. To make changes, edit the generator
# and run it again.

from typing import (
    Any,
    Literal,
    TYPE_CHECKING
)
from dataclasses import (
    dataclass
)
if TYPE_CHECKING:
    from cdp.domains.dom.types import (
        BackendNodeId,
        NodeId
    )
    from cdp.domains.page.types import (
        FrameId
    )
    from cdp.domains.runtime.types import (
        RemoteObjectId
    )

AXNodeId = str

AXValueType = Literal[
    'boolean',
    'tristate',
    'booleanOrUndefined',
    'idref',
    'idrefList',
    'integer',
    'node',
    'nodeList',
    'number',
    'string',
    'computedString',
    'token',
    'tokenList',
    'domRelation',
    'role',
    'internalRole',
    'valueUndefined'
]

AXValueSourceType = Literal[
    'attribute',
    'implicit',
    'style',
    'contents',
    'placeholder',
    'relatedElement'
]

AXValueNativeSourceType = Literal[
    'description',
    'figcaption',
    'label',
    'labelfor',
    'labelwrapped',
    'legend',
    'rubyannotation',
    'tablecaption',
    'title',
    'other'
]

AXPropertyName = Literal[
    'busy',
    'disabled',
    'editable',
    'focusable',
    'focused',
    'hidden',
    'hiddenRoot',
    'invalid',
    'keyshortcuts',
    'settable',
    'roledescription',
    'live',
    'atomic',
    'relevant',
    'root',
    'autocomplete',
    'hasPopup',
    'level',
    'multiselectable',
    'orientation',
    'multiline',
    'readonly',
    'required',
    'valuemin',
    'valuemax',
    'valuetext',
    'checked',
    'expanded',
    'modal',
    'pressed',
    'selected',
    'activedescendant',
    'controls',
    'describedby',
    'details',
    'errormessage',
    'flowto',
    'labelledby',
    'owns'
]


@dataclass
class AXValueSource:
    type: 'AXValueSourceType'
    value: 'AXValue'
    attribute: str
    attribute_value: 'AXValue'
    superseded: bool
    native_source: 'AXValueNativeSourceType'
    native_source_value: 'AXValue'
    invalid: bool
    invalid_reason: str
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'type': self.type_,
                'value': self.value.to_dict(
                    casing_strategy
                ),
                'attribute': self.attribute,
                'attribute_value': self.attribute_value.to_dict(
                    casing_strategy
                ),
                'superseded': self.superseded,
                'native_source': self.native_source,
                'native_source_value': self.native_source_value.to_dict(
                    casing_strategy
                ),
                'invalid': self.invalid,
                'invalid_reason': self.invalid_reason,
            }
        if casing_strategy == 'camel':
            return {
                'type': self.type_,
                'value': self.value.to_dict(
                    casing_strategy
                ),
                'attribute': self.attribute,
                'attributeValue': self.attribute_value.to_dict(
                    casing_strategy
                ),
                'superseded': self.superseded,
                'nativeSource': self.native_source,
                'nativeSourceValue': self.native_source_value.to_dict(
                    casing_strategy
                ),
                'invalid': self.invalid,
                'invalidReason': self.invalid_reason,
            }
        if casing_strategy == 'pascal':
            return {
                'Type': self.type_,
                'Value': self.value.to_dict(
                    casing_strategy
                ),
                'Attribute': self.attribute,
                'AttributeValue': self.attribute_value.to_dict(
                    casing_strategy
                ),
                'Superseded': self.superseded,
                'NativeSource': self.native_source,
                'NativeSourceValue': self.native_source_value.to_dict(
                    casing_strategy
                ),
                'Invalid': self.invalid,
                'InvalidReason': self.invalid_reason,
            }


@dataclass
class AXRelatedNode:
    backend_dom_node_id: 'BackendNodeId'
    idref: str
    text: str
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'backend_dom_node_id': self.backend_dom_node_id.to_dict(
                    casing_strategy
                ),
                'idref': self.idref,
                'text': self.text,
            }
        if casing_strategy == 'camel':
            return {
                'backendDOMNodeId': self.backend_dom_node_id.to_dict(
                    casing_strategy
                ),
                'idref': self.idref,
                'text': self.text,
            }
        if casing_strategy == 'pascal':
            return {
                'BackendDOMNodeId': self.backend_dom_node_id.to_dict(
                    casing_strategy
                ),
                'Idref': self.idref,
                'Text': self.text,
            }


@dataclass
class AXProperty:
    name: 'AXPropertyName'
    value: 'AXValue'
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'name': self.name,
                'value': self.value.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'camel':
            return {
                'name': self.name,
                'value': self.value.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'pascal':
            return {
                'Name': self.name,
                'Value': self.value.to_dict(
                    casing_strategy
                ),
            }


@dataclass
class AXValue:
    type: 'AXValueType'
    value: Any
    related_nodes: list
    sources: list
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'type': self.type_,
                'value': self.value,
                'related_nodes': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.related_nodes
                ],
                'sources': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.sources
                ],
            }
        if casing_strategy == 'camel':
            return {
                'type': self.type_,
                'value': self.value,
                'relatedNodes': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.related_nodes
                ],
                'sources': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.sources
                ],
            }
        if casing_strategy == 'pascal':
            return {
                'Type': self.type_,
                'Value': self.value,
                'RelatedNodes': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.related_nodes
                ],
                'Sources': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.sources
                ],
            }


@dataclass
class AXNode:
    node_id: 'AXNodeId'
    ignored: bool
    ignored_reasons: list
    role: 'AXValue'
    chrome_role: 'AXValue'
    name: 'AXValue'
    description: 'AXValue'
    value: 'AXValue'
    properties: list
    parent_id: 'AXNodeId'
    child_ids: list
    backend_dom_node_id: 'BackendNodeId'
    frame_id: 'FrameId'
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'node_id': self.node_id.to_dict(
                    casing_strategy
                ),
                'ignored': self.ignored,
                'ignored_reasons': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.ignored_reasons
                ],
                'role': self.role.to_dict(
                    casing_strategy
                ),
                'chrome_role': self.chrome_role.to_dict(
                    casing_strategy
                ),
                'name': self.name.to_dict(
                    casing_strategy
                ),
                'description': self.description.to_dict(
                    casing_strategy
                ),
                'value': self.value.to_dict(
                    casing_strategy
                ),
                'properties': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.properties
                ],
                'parent_id': self.parent_id.to_dict(
                    casing_strategy
                ),
                'child_ids': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.child_ids
                ],
                'backend_dom_node_id': self.backend_dom_node_id.to_dict(
                    casing_strategy
                ),
                'frame_id': self.frame_id.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'camel':
            return {
                'nodeId': self.node_id.to_dict(
                    casing_strategy
                ),
                'ignored': self.ignored,
                'ignoredReasons': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.ignored_reasons
                ],
                'role': self.role.to_dict(
                    casing_strategy
                ),
                'chromeRole': self.chrome_role.to_dict(
                    casing_strategy
                ),
                'name': self.name.to_dict(
                    casing_strategy
                ),
                'description': self.description.to_dict(
                    casing_strategy
                ),
                'value': self.value.to_dict(
                    casing_strategy
                ),
                'properties': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.properties
                ],
                'parentId': self.parent_id.to_dict(
                    casing_strategy
                ),
                'childIds': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.child_ids
                ],
                'backendDOMNodeId': self.backend_dom_node_id.to_dict(
                    casing_strategy
                ),
                'frameId': self.frame_id.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'pascal':
            return {
                'NodeId': self.node_id.to_dict(
                    casing_strategy
                ),
                'Ignored': self.ignored,
                'IgnoredReasons': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.ignored_reasons
                ],
                'Role': self.role.to_dict(
                    casing_strategy
                ),
                'ChromeRole': self.chrome_role.to_dict(
                    casing_strategy
                ),
                'Name': self.name.to_dict(
                    casing_strategy
                ),
                'Description': self.description.to_dict(
                    casing_strategy
                ),
                'Value': self.value.to_dict(
                    casing_strategy
                ),
                'Properties': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.properties
                ],
                'ParentId': self.parent_id.to_dict(
                    casing_strategy
                ),
                'ChildIds': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.child_ids
                ],
                'BackendDOMNodeId': self.backend_dom_node_id.to_dict(
                    casing_strategy
                ),
                'FrameId': self.frame_id.to_dict(
                    casing_strategy
                ),
            }


@dataclass
class GetPartialAXTreeReturnT:
    nodes: list


@dataclass
class GetFullAXTreeReturnT:
    nodes: list


@dataclass
class GetRootAXNodeReturnT:
    node: 'AXNode'


@dataclass
class GetAXNodeAndAncestorsReturnT:
    nodes: list


@dataclass
class GetChildAXNodesReturnT:
    nodes: list


@dataclass
class QueryAXTreeReturnT:
    nodes: list
