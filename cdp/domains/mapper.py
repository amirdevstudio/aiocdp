# DO NOT EDIT THIS FILE
#
# This file is generated by the generator. To make changes, edit the generator
# and run it again.

from typing import (
    TypeVar
)
from cdp.domains.utils import (
    CasingStrategyT
)
from cdp.domains.accessibility import (
    types as accessibility
)
from cdp.domains.animation import (
    types as animation
)
from cdp.domains.audits import (
    types as audits
)
from cdp.domains.autofill import (
    types as autofill
)
from cdp.domains.background_service import (
    types as background_service
)
from cdp.domains.browser import (
    types as browser
)
from cdp.domains.css import (
    types as css
)
from cdp.domains.cache_storage import (
    types as cache_storage
)
from cdp.domains.cast import (
    types as cast
)
from cdp.domains.dom import (
    types as dom
)
from cdp.domains.dom_debugger import (
    types as dom_debugger
)
from cdp.domains.event_breakpoints import (
    types as event_breakpoints
)
from cdp.domains.dom_snapshot import (
    types as dom_snapshot
)
from cdp.domains.dom_storage import (
    types as dom_storage
)
from cdp.domains.database import (
    types as database
)
from cdp.domains.device_orientation import (
    types as device_orientation
)
from cdp.domains.emulation import (
    types as emulation
)
from cdp.domains.headless_experimental import (
    types as headless_experimental
)
from cdp.domains.io import (
    types as io
)
from cdp.domains.indexed_db import (
    types as indexed_db
)
from cdp.domains.input import (
    types as input_
)
from cdp.domains.inspector import (
    types as inspector
)
from cdp.domains.layer_tree import (
    types as layer_tree
)
from cdp.domains.log import (
    types as log
)
from cdp.domains.memory import (
    types as memory
)
from cdp.domains.network import (
    types as network
)
from cdp.domains.overlay import (
    types as overlay
)
from cdp.domains.page import (
    types as page
)
from cdp.domains.performance import (
    types as performance
)
from cdp.domains.performance_timeline import (
    types as performance_timeline
)
from cdp.domains.security import (
    types as security
)
from cdp.domains.service_worker import (
    types as service_worker
)
from cdp.domains.storage import (
    types as storage
)
from cdp.domains.system_info import (
    types as system_info
)
from cdp.domains.target import (
    types as target
)
from cdp.domains.tethering import (
    types as tethering
)
from cdp.domains.tracing import (
    types as tracing
)
from cdp.domains.fetch import (
    types as fetch
)
from cdp.domains.web_audio import (
    types as web_audio
)
from cdp.domains.web_authn import (
    types as web_authn
)
from cdp.domains.media import (
    types as media
)
from cdp.domains.device_access import (
    types as device_access
)
from cdp.domains.preload import (
    types as preload
)
from cdp.domains.fed_cm import (
    types as fed_cm
)
from cdp.domains.console import (
    types as console
)
from cdp.domains.debugger import (
    types as debugger
)
from cdp.domains.heap_profiler import (
    types as heap_profiler
)
from cdp.domains.profiler import (
    types as profiler
)
from cdp.domains.runtime import (
    types as runtime
)
from cdp.domains.schema import (
    types as schema
)

_T = TypeVar('_T')

def _map_accessibility__ax_value_source__to_dict(data: 'accessibility.AXValueSource', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'value': to_dict(
                data.value,
                casing_strategy
            ),
            'attribute': data.attribute,
            'attribute_value': to_dict(
                data.attribute_value,
                casing_strategy
            ),
            'superseded': data.superseded,
            'native_source': data.native_source,
            'native_source_value': to_dict(
                data.native_source_value,
                casing_strategy
            ),
            'invalid': data.invalid,
            'invalid_reason': data.invalid_reason,
        }
    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'value': to_dict(
                data.value,
                casing_strategy
            ),
            'attribute': data.attribute,
            'attributeValue': to_dict(
                data.attribute_value,
                casing_strategy
            ),
            'superseded': data.superseded,
            'nativeSource': data.native_source,
            'nativeSourceValue': to_dict(
                data.native_source_value,
                casing_strategy
            ),
            'invalid': data.invalid,
            'invalidReason': data.invalid_reason,
        }
    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'Value': to_dict(
                data.value,
                casing_strategy
            ),
            'Attribute': data.attribute,
            'AttributeValue': to_dict(
                data.attribute_value,
                casing_strategy
            ),
            'Superseded': data.superseded,
            'NativeSource': data.native_source,
            'NativeSourceValue': to_dict(
                data.native_source_value,
                casing_strategy
            ),
            'Invalid': data.invalid,
            'InvalidReason': data.invalid_reason,
        }


def _map_accessibility__ax_related_node__to_dict(data: 'accessibility.AXRelatedNode', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'backend_dom_node_id': data.backend_dom_node_id,
            'idref': data.idref,
            'text': data.text,
        }
    if casing_strategy == 'camel':
        return {
            'backendDOMNodeId': data.backend_dom_node_id,
            'idref': data.idref,
            'text': data.text,
        }
    if casing_strategy == 'pascal':
        return {
            'BackendDOMNodeId': data.backend_dom_node_id,
            'Idref': data.idref,
            'Text': data.text,
        }


def _map_accessibility__ax_property__to_dict(data: 'accessibility.AXProperty', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': to_dict(
                data.value,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': to_dict(
                data.value,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': to_dict(
                data.value,
                casing_strategy
            ),
        }


def _map_accessibility__ax_value__to_dict(data: 'accessibility.AXValue', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'value': data.value,
            'related_nodes': [
                to_dict(item, casing_strategy)
                for item in data.related_nodes
            ],
            'sources': [
                to_dict(item, casing_strategy)
                for item in data.sources
            ],
        }
    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'value': data.value,
            'relatedNodes': [
                to_dict(item, casing_strategy)
                for item in data.related_nodes
            ],
            'sources': [
                to_dict(item, casing_strategy)
                for item in data.sources
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'Value': data.value,
            'RelatedNodes': [
                to_dict(item, casing_strategy)
                for item in data.related_nodes
            ],
            'Sources': [
                to_dict(item, casing_strategy)
                for item in data.sources
            ],
        }


def _map_accessibility__ax_node__to_dict(data: 'accessibility.AXNode', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'node_id': data.node_id,
            'ignored': data.ignored,
            'ignored_reasons': [
                to_dict(item, casing_strategy)
                for item in data.ignored_reasons
            ],
            'role': to_dict(
                data.role,
                casing_strategy
            ),
            'chrome_role': to_dict(
                data.chrome_role,
                casing_strategy
            ),
            'name': to_dict(
                data.name,
                casing_strategy
            ),
            'description': to_dict(
                data.description,
                casing_strategy
            ),
            'value': to_dict(
                data.value,
                casing_strategy
            ),
            'properties': [
                to_dict(item, casing_strategy)
                for item in data.properties
            ],
            'parent_id': data.parent_id,
            'child_ids': [
                item
                for item in data.child_ids
            ],
            'backend_dom_node_id': data.backend_dom_node_id,
            'frame_id': data.frame_id,
        }
    if casing_strategy == 'camel':
        return {
            'nodeId': data.node_id,
            'ignored': data.ignored,
            'ignoredReasons': [
                to_dict(item, casing_strategy)
                for item in data.ignored_reasons
            ],
            'role': to_dict(
                data.role,
                casing_strategy
            ),
            'chromeRole': to_dict(
                data.chrome_role,
                casing_strategy
            ),
            'name': to_dict(
                data.name,
                casing_strategy
            ),
            'description': to_dict(
                data.description,
                casing_strategy
            ),
            'value': to_dict(
                data.value,
                casing_strategy
            ),
            'properties': [
                to_dict(item, casing_strategy)
                for item in data.properties
            ],
            'parentId': data.parent_id,
            'childIds': [
                item
                for item in data.child_ids
            ],
            'backendDOMNodeId': data.backend_dom_node_id,
            'frameId': data.frame_id,
        }
    if casing_strategy == 'pascal':
        return {
            'NodeId': data.node_id,
            'Ignored': data.ignored,
            'IgnoredReasons': [
                to_dict(item, casing_strategy)
                for item in data.ignored_reasons
            ],
            'Role': to_dict(
                data.role,
                casing_strategy
            ),
            'ChromeRole': to_dict(
                data.chrome_role,
                casing_strategy
            ),
            'Name': to_dict(
                data.name,
                casing_strategy
            ),
            'Description': to_dict(
                data.description,
                casing_strategy
            ),
            'Value': to_dict(
                data.value,
                casing_strategy
            ),
            'Properties': [
                to_dict(item, casing_strategy)
                for item in data.properties
            ],
            'ParentId': data.parent_id,
            'ChildIds': [
                item
                for item in data.child_ids
            ],
            'BackendDOMNodeId': data.backend_dom_node_id,
            'FrameId': data.frame_id,
        }


def _map_animation__animation__to_dict(data: 'animation.Animation', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'id': data.id,
            'name': data.name,
            'paused_state': data.paused_state,
            'play_state': data.play_state,
            'playback_rate': data.playback_rate,
            'start_time': data.start_time,
            'current_time': data.current_time,
            'type': data.type,
            'source': to_dict(
                data.source,
                casing_strategy
            ),
            'css_id': data.css_id,
        }
    if casing_strategy == 'camel':
        return {
            'id': data.id,
            'name': data.name,
            'pausedState': data.paused_state,
            'playState': data.play_state,
            'playbackRate': data.playback_rate,
            'startTime': data.start_time,
            'currentTime': data.current_time,
            'type': data.type,
            'source': to_dict(
                data.source,
                casing_strategy
            ),
            'cssId': data.css_id,
        }
    if casing_strategy == 'pascal':
        return {
            'Id': data.id,
            'Name': data.name,
            'PausedState': data.paused_state,
            'PlayState': data.play_state,
            'PlaybackRate': data.playback_rate,
            'StartTime': data.start_time,
            'CurrentTime': data.current_time,
            'Type': data.type,
            'Source': to_dict(
                data.source,
                casing_strategy
            ),
            'CssId': data.css_id,
        }


def _map_animation__animation_effect__to_dict(data: 'animation.AnimationEffect', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'delay': data.delay,
            'end_delay': data.end_delay,
            'iteration_start': data.iteration_start,
            'iterations': data.iterations,
            'duration': data.duration,
            'direction': data.direction,
            'fill': data.fill,
            'backend_node_id': data.backend_node_id,
            'keyframes_rule': to_dict(
                data.keyframes_rule,
                casing_strategy
            ),
            'easing': data.easing,
        }
    if casing_strategy == 'camel':
        return {
            'delay': data.delay,
            'endDelay': data.end_delay,
            'iterationStart': data.iteration_start,
            'iterations': data.iterations,
            'duration': data.duration,
            'direction': data.direction,
            'fill': data.fill,
            'backendNodeId': data.backend_node_id,
            'keyframesRule': to_dict(
                data.keyframes_rule,
                casing_strategy
            ),
            'easing': data.easing,
        }
    if casing_strategy == 'pascal':
        return {
            'Delay': data.delay,
            'EndDelay': data.end_delay,
            'IterationStart': data.iteration_start,
            'Iterations': data.iterations,
            'Duration': data.duration,
            'Direction': data.direction,
            'Fill': data.fill,
            'BackendNodeId': data.backend_node_id,
            'KeyframesRule': to_dict(
                data.keyframes_rule,
                casing_strategy
            ),
            'Easing': data.easing,
        }


def _map_animation__keyframes_rule__to_dict(data: 'animation.KeyframesRule', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'keyframes': [
                to_dict(item, casing_strategy)
                for item in data.keyframes
            ],
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'keyframes': [
                to_dict(item, casing_strategy)
                for item in data.keyframes
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Keyframes': [
                to_dict(item, casing_strategy)
                for item in data.keyframes
            ],
        }


def _map_animation__keyframe_style__to_dict(data: 'animation.KeyframeStyle', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'offset': data.offset,
            'easing': data.easing,
        }
    if casing_strategy == 'camel':
        return {
            'offset': data.offset,
            'easing': data.easing,
        }
    if casing_strategy == 'pascal':
        return {
            'Offset': data.offset,
            'Easing': data.easing,
        }


def _map_audits__affected_cookie__to_dict(data: 'audits.AffectedCookie', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'path': data.path,
            'domain': data.domain,
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'path': data.path,
            'domain': data.domain,
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Path': data.path,
            'Domain': data.domain,
        }


def _map_audits__affected_request__to_dict(data: 'audits.AffectedRequest', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'request_id': data.request_id,
            'url': data.url,
        }
    if casing_strategy == 'camel':
        return {
            'requestId': data.request_id,
            'url': data.url,
        }
    if casing_strategy == 'pascal':
        return {
            'RequestId': data.request_id,
            'Url': data.url,
        }


def _map_audits__affected_frame__to_dict(data: 'audits.AffectedFrame', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'frame_id': data.frame_id,
        }
    if casing_strategy == 'camel':
        return {
            'frameId': data.frame_id,
        }
    if casing_strategy == 'pascal':
        return {
            'FrameId': data.frame_id,
        }


def _map_audits__cookie_issue_details__to_dict(data: 'audits.CookieIssueDetails', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'cookie': to_dict(
                data.cookie,
                casing_strategy
            ),
            'raw_cookie_line': data.raw_cookie_line,
            'cookie_warning_reasons': [
                item
                for item in data.cookie_warning_reasons
            ],
            'cookie_exclusion_reasons': [
                item
                for item in data.cookie_exclusion_reasons
            ],
            'operation': data.operation,
            'site_for_cookies': data.site_for_cookies,
            'cookie_url': data.cookie_url,
            'request': to_dict(
                data.request,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'cookie': to_dict(
                data.cookie,
                casing_strategy
            ),
            'rawCookieLine': data.raw_cookie_line,
            'cookieWarningReasons': [
                item
                for item in data.cookie_warning_reasons
            ],
            'cookieExclusionReasons': [
                item
                for item in data.cookie_exclusion_reasons
            ],
            'operation': data.operation,
            'siteForCookies': data.site_for_cookies,
            'cookieUrl': data.cookie_url,
            'request': to_dict(
                data.request,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'Cookie': to_dict(
                data.cookie,
                casing_strategy
            ),
            'RawCookieLine': data.raw_cookie_line,
            'CookieWarningReasons': [
                item
                for item in data.cookie_warning_reasons
            ],
            'CookieExclusionReasons': [
                item
                for item in data.cookie_exclusion_reasons
            ],
            'Operation': data.operation,
            'SiteForCookies': data.site_for_cookies,
            'CookieUrl': data.cookie_url,
            'Request': to_dict(
                data.request,
                casing_strategy
            ),
        }


def _map_audits__mixed_content_issue_details__to_dict(data: 'audits.MixedContentIssueDetails', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'resource_type': data.resource_type,
            'resolution_status': data.resolution_status,
            'insecure_url': data.insecure_url,
            'main_resource_url': data.main_resource_url,
            'request': to_dict(
                data.request,
                casing_strategy
            ),
            'frame': to_dict(
                data.frame,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'resourceType': data.resource_type,
            'resolutionStatus': data.resolution_status,
            'insecureURL': data.insecure_url,
            'mainResourceURL': data.main_resource_url,
            'request': to_dict(
                data.request,
                casing_strategy
            ),
            'frame': to_dict(
                data.frame,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'ResourceType': data.resource_type,
            'ResolutionStatus': data.resolution_status,
            'InsecureURL': data.insecure_url,
            'MainResourceURL': data.main_resource_url,
            'Request': to_dict(
                data.request,
                casing_strategy
            ),
            'Frame': to_dict(
                data.frame,
                casing_strategy
            ),
        }


def _map_audits__blocked_by_response_issue_details__to_dict(data: 'audits.BlockedByResponseIssueDetails', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'request': to_dict(
                data.request,
                casing_strategy
            ),
            'parent_frame': to_dict(
                data.parent_frame,
                casing_strategy
            ),
            'blocked_frame': to_dict(
                data.blocked_frame,
                casing_strategy
            ),
            'reason': data.reason,
        }
    if casing_strategy == 'camel':
        return {
            'request': to_dict(
                data.request,
                casing_strategy
            ),
            'parentFrame': to_dict(
                data.parent_frame,
                casing_strategy
            ),
            'blockedFrame': to_dict(
                data.blocked_frame,
                casing_strategy
            ),
            'reason': data.reason,
        }
    if casing_strategy == 'pascal':
        return {
            'Request': to_dict(
                data.request,
                casing_strategy
            ),
            'ParentFrame': to_dict(
                data.parent_frame,
                casing_strategy
            ),
            'BlockedFrame': to_dict(
                data.blocked_frame,
                casing_strategy
            ),
            'Reason': data.reason,
        }


def _map_audits__heavy_ad_issue_details__to_dict(data: 'audits.HeavyAdIssueDetails', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'resolution': data.resolution,
            'reason': data.reason,
            'frame': to_dict(
                data.frame,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'resolution': data.resolution,
            'reason': data.reason,
            'frame': to_dict(
                data.frame,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'Resolution': data.resolution,
            'Reason': data.reason,
            'Frame': to_dict(
                data.frame,
                casing_strategy
            ),
        }


def _map_audits__source_code_location__to_dict(data: 'audits.SourceCodeLocation', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'script_id': data.script_id,
            'url': data.url,
            'line_number': data.line_number,
            'column_number': data.column_number,
        }
    if casing_strategy == 'camel':
        return {
            'scriptId': data.script_id,
            'url': data.url,
            'lineNumber': data.line_number,
            'columnNumber': data.column_number,
        }
    if casing_strategy == 'pascal':
        return {
            'ScriptId': data.script_id,
            'Url': data.url,
            'LineNumber': data.line_number,
            'ColumnNumber': data.column_number,
        }


def _map_audits__content_security_policy_issue_details__to_dict(data: 'audits.ContentSecurityPolicyIssueDetails', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'blocked_url': data.blocked_url,
            'violated_directive': data.violated_directive,
            'is_report_only': data.is_report_only,
            'content_security_policy_violation_type': data.content_security_policy_violation_type,
            'frame_ancestor': to_dict(
                data.frame_ancestor,
                casing_strategy
            ),
            'source_code_location': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'violating_node_id': data.violating_node_id,
        }
    if casing_strategy == 'camel':
        return {
            'blockedURL': data.blocked_url,
            'violatedDirective': data.violated_directive,
            'isReportOnly': data.is_report_only,
            'contentSecurityPolicyViolationType': data.content_security_policy_violation_type,
            'frameAncestor': to_dict(
                data.frame_ancestor,
                casing_strategy
            ),
            'sourceCodeLocation': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'violatingNodeId': data.violating_node_id,
        }
    if casing_strategy == 'pascal':
        return {
            'BlockedURL': data.blocked_url,
            'ViolatedDirective': data.violated_directive,
            'IsReportOnly': data.is_report_only,
            'ContentSecurityPolicyViolationType': data.content_security_policy_violation_type,
            'FrameAncestor': to_dict(
                data.frame_ancestor,
                casing_strategy
            ),
            'SourceCodeLocation': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'ViolatingNodeId': data.violating_node_id,
        }


def _map_audits__shared_array_buffer_issue_details__to_dict(data: 'audits.SharedArrayBufferIssueDetails', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'source_code_location': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'is_warning': data.is_warning,
            'type': data.type,
        }
    if casing_strategy == 'camel':
        return {
            'sourceCodeLocation': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'isWarning': data.is_warning,
            'type': data.type,
        }
    if casing_strategy == 'pascal':
        return {
            'SourceCodeLocation': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'IsWarning': data.is_warning,
            'Type': data.type,
        }


def _map_audits__low_text_contrast_issue_details__to_dict(data: 'audits.LowTextContrastIssueDetails', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'violating_node_id': data.violating_node_id,
            'violating_node_selector': data.violating_node_selector,
            'contrast_ratio': data.contrast_ratio,
            'threshold_aa': data.threshold_aa,
            'threshold_aaa': data.threshold_aaa,
            'font_size': data.font_size,
            'font_weight': data.font_weight,
        }
    if casing_strategy == 'camel':
        return {
            'violatingNodeId': data.violating_node_id,
            'violatingNodeSelector': data.violating_node_selector,
            'contrastRatio': data.contrast_ratio,
            'thresholdAA': data.threshold_aa,
            'thresholdAAA': data.threshold_aaa,
            'fontSize': data.font_size,
            'fontWeight': data.font_weight,
        }
    if casing_strategy == 'pascal':
        return {
            'ViolatingNodeId': data.violating_node_id,
            'ViolatingNodeSelector': data.violating_node_selector,
            'ContrastRatio': data.contrast_ratio,
            'ThresholdAA': data.threshold_aa,
            'ThresholdAAA': data.threshold_aaa,
            'FontSize': data.font_size,
            'FontWeight': data.font_weight,
        }


def _map_audits__cors_issue_details__to_dict(data: 'audits.CorsIssueDetails', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'cors_error_status': to_dict(
                data.cors_error_status,
                casing_strategy
            ),
            'is_warning': data.is_warning,
            'request': to_dict(
                data.request,
                casing_strategy
            ),
            'location': to_dict(
                data.location,
                casing_strategy
            ),
            'initiator_origin': data.initiator_origin,
            'resource_ip_address_space': data.resource_ip_address_space,
            'client_security_state': to_dict(
                data.client_security_state,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'corsErrorStatus': to_dict(
                data.cors_error_status,
                casing_strategy
            ),
            'isWarning': data.is_warning,
            'request': to_dict(
                data.request,
                casing_strategy
            ),
            'location': to_dict(
                data.location,
                casing_strategy
            ),
            'initiatorOrigin': data.initiator_origin,
            'resourceIPAddressSpace': data.resource_ip_address_space,
            'clientSecurityState': to_dict(
                data.client_security_state,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'CorsErrorStatus': to_dict(
                data.cors_error_status,
                casing_strategy
            ),
            'IsWarning': data.is_warning,
            'Request': to_dict(
                data.request,
                casing_strategy
            ),
            'Location': to_dict(
                data.location,
                casing_strategy
            ),
            'InitiatorOrigin': data.initiator_origin,
            'ResourceIPAddressSpace': data.resource_ip_address_space,
            'ClientSecurityState': to_dict(
                data.client_security_state,
                casing_strategy
            ),
        }


def _map_audits__attribution_reporting_issue_details__to_dict(data: 'audits.AttributionReportingIssueDetails', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'violation_type': data.violation_type,
            'request': to_dict(
                data.request,
                casing_strategy
            ),
            'violating_node_id': data.violating_node_id,
            'invalid_parameter': data.invalid_parameter,
        }
    if casing_strategy == 'camel':
        return {
            'violationType': data.violation_type,
            'request': to_dict(
                data.request,
                casing_strategy
            ),
            'violatingNodeId': data.violating_node_id,
            'invalidParameter': data.invalid_parameter,
        }
    if casing_strategy == 'pascal':
        return {
            'ViolationType': data.violation_type,
            'Request': to_dict(
                data.request,
                casing_strategy
            ),
            'ViolatingNodeId': data.violating_node_id,
            'InvalidParameter': data.invalid_parameter,
        }


def _map_audits__quirks_mode_issue_details__to_dict(data: 'audits.QuirksModeIssueDetails', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'is_limited_quirks_mode': data.is_limited_quirks_mode,
            'document_node_id': data.document_node_id,
            'url': data.url,
            'frame_id': data.frame_id,
            'loader_id': data.loader_id,
        }
    if casing_strategy == 'camel':
        return {
            'isLimitedQuirksMode': data.is_limited_quirks_mode,
            'documentNodeId': data.document_node_id,
            'url': data.url,
            'frameId': data.frame_id,
            'loaderId': data.loader_id,
        }
    if casing_strategy == 'pascal':
        return {
            'IsLimitedQuirksMode': data.is_limited_quirks_mode,
            'DocumentNodeId': data.document_node_id,
            'Url': data.url,
            'FrameId': data.frame_id,
            'LoaderId': data.loader_id,
        }


def _map_audits__navigator_user_agent_issue_details__to_dict(data: 'audits.NavigatorUserAgentIssueDetails', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'url': data.url,
            'location': to_dict(
                data.location,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'url': data.url,
            'location': to_dict(
                data.location,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'Url': data.url,
            'Location': to_dict(
                data.location,
                casing_strategy
            ),
        }


def _map_audits__generic_issue_details__to_dict(data: 'audits.GenericIssueDetails', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'error_type': data.error_type,
            'frame_id': data.frame_id,
            'violating_node_id': data.violating_node_id,
            'violating_node_attribute': data.violating_node_attribute,
            'request': to_dict(
                data.request,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'errorType': data.error_type,
            'frameId': data.frame_id,
            'violatingNodeId': data.violating_node_id,
            'violatingNodeAttribute': data.violating_node_attribute,
            'request': to_dict(
                data.request,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'ErrorType': data.error_type,
            'FrameId': data.frame_id,
            'ViolatingNodeId': data.violating_node_id,
            'ViolatingNodeAttribute': data.violating_node_attribute,
            'Request': to_dict(
                data.request,
                casing_strategy
            ),
        }


def _map_audits__deprecation_issue_details__to_dict(data: 'audits.DeprecationIssueDetails', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'affected_frame': to_dict(
                data.affected_frame,
                casing_strategy
            ),
            'source_code_location': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'type': data.type,
        }
    if casing_strategy == 'camel':
        return {
            'affectedFrame': to_dict(
                data.affected_frame,
                casing_strategy
            ),
            'sourceCodeLocation': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'type': data.type,
        }
    if casing_strategy == 'pascal':
        return {
            'AffectedFrame': to_dict(
                data.affected_frame,
                casing_strategy
            ),
            'SourceCodeLocation': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'Type': data.type,
        }


def _map_audits__bounce_tracking_issue_details__to_dict(data: 'audits.BounceTrackingIssueDetails', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'tracking_sites': [
                item
                for item in data.tracking_sites
            ],
        }
    if casing_strategy == 'camel':
        return {
            'trackingSites': [
                item
                for item in data.tracking_sites
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'TrackingSites': [
                item
                for item in data.tracking_sites
            ],
        }


def _map_audits__federated_auth_request_issue_details__to_dict(data: 'audits.FederatedAuthRequestIssueDetails', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'federated_auth_request_issue_reason': data.federated_auth_request_issue_reason,
        }
    if casing_strategy == 'camel':
        return {
            'federatedAuthRequestIssueReason': data.federated_auth_request_issue_reason,
        }
    if casing_strategy == 'pascal':
        return {
            'FederatedAuthRequestIssueReason': data.federated_auth_request_issue_reason,
        }


def _map_audits__federated_auth_user_info_request_issue_details__to_dict(data: 'audits.FederatedAuthUserInfoRequestIssueDetails', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'federated_auth_user_info_request_issue_reason': data.federated_auth_user_info_request_issue_reason,
        }
    if casing_strategy == 'camel':
        return {
            'federatedAuthUserInfoRequestIssueReason': data.federated_auth_user_info_request_issue_reason,
        }
    if casing_strategy == 'pascal':
        return {
            'FederatedAuthUserInfoRequestIssueReason': data.federated_auth_user_info_request_issue_reason,
        }


def _map_audits__client_hint_issue_details__to_dict(data: 'audits.ClientHintIssueDetails', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'source_code_location': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'client_hint_issue_reason': data.client_hint_issue_reason,
        }
    if casing_strategy == 'camel':
        return {
            'sourceCodeLocation': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'clientHintIssueReason': data.client_hint_issue_reason,
        }
    if casing_strategy == 'pascal':
        return {
            'SourceCodeLocation': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'ClientHintIssueReason': data.client_hint_issue_reason,
        }


def _map_audits__failed_request_info__to_dict(data: 'audits.FailedRequestInfo', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'url': data.url,
            'failure_message': data.failure_message,
            'request_id': data.request_id,
        }
    if casing_strategy == 'camel':
        return {
            'url': data.url,
            'failureMessage': data.failure_message,
            'requestId': data.request_id,
        }
    if casing_strategy == 'pascal':
        return {
            'Url': data.url,
            'FailureMessage': data.failure_message,
            'RequestId': data.request_id,
        }


def _map_audits__stylesheet_loading_issue_details__to_dict(data: 'audits.StylesheetLoadingIssueDetails', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'source_code_location': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'style_sheet_loading_issue_reason': data.style_sheet_loading_issue_reason,
            'failed_request_info': to_dict(
                data.failed_request_info,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'sourceCodeLocation': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'styleSheetLoadingIssueReason': data.style_sheet_loading_issue_reason,
            'failedRequestInfo': to_dict(
                data.failed_request_info,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'SourceCodeLocation': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'StyleSheetLoadingIssueReason': data.style_sheet_loading_issue_reason,
            'FailedRequestInfo': to_dict(
                data.failed_request_info,
                casing_strategy
            ),
        }


def _map_audits__inspector_issue_details__to_dict(data: 'audits.InspectorIssueDetails', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'cookie_issue_details': to_dict(
                data.cookie_issue_details,
                casing_strategy
            ),
            'mixed_content_issue_details': to_dict(
                data.mixed_content_issue_details,
                casing_strategy
            ),
            'blocked_by_response_issue_details': to_dict(
                data.blocked_by_response_issue_details,
                casing_strategy
            ),
            'heavy_ad_issue_details': to_dict(
                data.heavy_ad_issue_details,
                casing_strategy
            ),
            'content_security_policy_issue_details': to_dict(
                data.content_security_policy_issue_details,
                casing_strategy
            ),
            'shared_array_buffer_issue_details': to_dict(
                data.shared_array_buffer_issue_details,
                casing_strategy
            ),
            'low_text_contrast_issue_details': to_dict(
                data.low_text_contrast_issue_details,
                casing_strategy
            ),
            'cors_issue_details': to_dict(
                data.cors_issue_details,
                casing_strategy
            ),
            'attribution_reporting_issue_details': to_dict(
                data.attribution_reporting_issue_details,
                casing_strategy
            ),
            'quirks_mode_issue_details': to_dict(
                data.quirks_mode_issue_details,
                casing_strategy
            ),
            'navigator_user_agent_issue_details': to_dict(
                data.navigator_user_agent_issue_details,
                casing_strategy
            ),
            'generic_issue_details': to_dict(
                data.generic_issue_details,
                casing_strategy
            ),
            'deprecation_issue_details': to_dict(
                data.deprecation_issue_details,
                casing_strategy
            ),
            'client_hint_issue_details': to_dict(
                data.client_hint_issue_details,
                casing_strategy
            ),
            'federated_auth_request_issue_details': to_dict(
                data.federated_auth_request_issue_details,
                casing_strategy
            ),
            'bounce_tracking_issue_details': to_dict(
                data.bounce_tracking_issue_details,
                casing_strategy
            ),
            'stylesheet_loading_issue_details': to_dict(
                data.stylesheet_loading_issue_details,
                casing_strategy
            ),
            'federated_auth_user_info_request_issue_details': to_dict(
                data.federated_auth_user_info_request_issue_details,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'cookieIssueDetails': to_dict(
                data.cookie_issue_details,
                casing_strategy
            ),
            'mixedContentIssueDetails': to_dict(
                data.mixed_content_issue_details,
                casing_strategy
            ),
            'blockedByResponseIssueDetails': to_dict(
                data.blocked_by_response_issue_details,
                casing_strategy
            ),
            'heavyAdIssueDetails': to_dict(
                data.heavy_ad_issue_details,
                casing_strategy
            ),
            'contentSecurityPolicyIssueDetails': to_dict(
                data.content_security_policy_issue_details,
                casing_strategy
            ),
            'sharedArrayBufferIssueDetails': to_dict(
                data.shared_array_buffer_issue_details,
                casing_strategy
            ),
            'lowTextContrastIssueDetails': to_dict(
                data.low_text_contrast_issue_details,
                casing_strategy
            ),
            'corsIssueDetails': to_dict(
                data.cors_issue_details,
                casing_strategy
            ),
            'attributionReportingIssueDetails': to_dict(
                data.attribution_reporting_issue_details,
                casing_strategy
            ),
            'quirksModeIssueDetails': to_dict(
                data.quirks_mode_issue_details,
                casing_strategy
            ),
            'navigatorUserAgentIssueDetails': to_dict(
                data.navigator_user_agent_issue_details,
                casing_strategy
            ),
            'genericIssueDetails': to_dict(
                data.generic_issue_details,
                casing_strategy
            ),
            'deprecationIssueDetails': to_dict(
                data.deprecation_issue_details,
                casing_strategy
            ),
            'clientHintIssueDetails': to_dict(
                data.client_hint_issue_details,
                casing_strategy
            ),
            'federatedAuthRequestIssueDetails': to_dict(
                data.federated_auth_request_issue_details,
                casing_strategy
            ),
            'bounceTrackingIssueDetails': to_dict(
                data.bounce_tracking_issue_details,
                casing_strategy
            ),
            'stylesheetLoadingIssueDetails': to_dict(
                data.stylesheet_loading_issue_details,
                casing_strategy
            ),
            'federatedAuthUserInfoRequestIssueDetails': to_dict(
                data.federated_auth_user_info_request_issue_details,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'CookieIssueDetails': to_dict(
                data.cookie_issue_details,
                casing_strategy
            ),
            'MixedContentIssueDetails': to_dict(
                data.mixed_content_issue_details,
                casing_strategy
            ),
            'BlockedByResponseIssueDetails': to_dict(
                data.blocked_by_response_issue_details,
                casing_strategy
            ),
            'HeavyAdIssueDetails': to_dict(
                data.heavy_ad_issue_details,
                casing_strategy
            ),
            'ContentSecurityPolicyIssueDetails': to_dict(
                data.content_security_policy_issue_details,
                casing_strategy
            ),
            'SharedArrayBufferIssueDetails': to_dict(
                data.shared_array_buffer_issue_details,
                casing_strategy
            ),
            'LowTextContrastIssueDetails': to_dict(
                data.low_text_contrast_issue_details,
                casing_strategy
            ),
            'CorsIssueDetails': to_dict(
                data.cors_issue_details,
                casing_strategy
            ),
            'AttributionReportingIssueDetails': to_dict(
                data.attribution_reporting_issue_details,
                casing_strategy
            ),
            'QuirksModeIssueDetails': to_dict(
                data.quirks_mode_issue_details,
                casing_strategy
            ),
            'NavigatorUserAgentIssueDetails': to_dict(
                data.navigator_user_agent_issue_details,
                casing_strategy
            ),
            'GenericIssueDetails': to_dict(
                data.generic_issue_details,
                casing_strategy
            ),
            'DeprecationIssueDetails': to_dict(
                data.deprecation_issue_details,
                casing_strategy
            ),
            'ClientHintIssueDetails': to_dict(
                data.client_hint_issue_details,
                casing_strategy
            ),
            'FederatedAuthRequestIssueDetails': to_dict(
                data.federated_auth_request_issue_details,
                casing_strategy
            ),
            'BounceTrackingIssueDetails': to_dict(
                data.bounce_tracking_issue_details,
                casing_strategy
            ),
            'StylesheetLoadingIssueDetails': to_dict(
                data.stylesheet_loading_issue_details,
                casing_strategy
            ),
            'FederatedAuthUserInfoRequestIssueDetails': to_dict(
                data.federated_auth_user_info_request_issue_details,
                casing_strategy
            ),
        }


def _map_audits__inspector_issue__to_dict(data: 'audits.InspectorIssue', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'code': data.code,
            'details': to_dict(
                data.details,
                casing_strategy
            ),
            'issue_id': data.issue_id,
        }
    if casing_strategy == 'camel':
        return {
            'code': data.code,
            'details': to_dict(
                data.details,
                casing_strategy
            ),
            'issueId': data.issue_id,
        }
    if casing_strategy == 'pascal':
        return {
            'Code': data.code,
            'Details': to_dict(
                data.details,
                casing_strategy
            ),
            'IssueId': data.issue_id,
        }


def _map_autofill__credit_card__to_dict(data: 'autofill.CreditCard', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'number': data.number,
            'name': data.name,
            'expiry_month': data.expiry_month,
            'expiry_year': data.expiry_year,
            'cvc': data.cvc,
        }
    if casing_strategy == 'camel':
        return {
            'number': data.number,
            'name': data.name,
            'expiryMonth': data.expiry_month,
            'expiryYear': data.expiry_year,
            'cvc': data.cvc,
        }
    if casing_strategy == 'pascal':
        return {
            'Number': data.number,
            'Name': data.name,
            'ExpiryMonth': data.expiry_month,
            'ExpiryYear': data.expiry_year,
            'Cvc': data.cvc,
        }


def _map_autofill__address_field__to_dict(data: 'autofill.AddressField', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
        }


def _map_autofill__address_fields__to_dict(data: 'autofill.AddressFields', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'fields': [
                to_dict(item, casing_strategy)
                for item in data.fields
            ],
        }
    if casing_strategy == 'camel':
        return {
            'fields': [
                to_dict(item, casing_strategy)
                for item in data.fields
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Fields': [
                to_dict(item, casing_strategy)
                for item in data.fields
            ],
        }


def _map_autofill__address__to_dict(data: 'autofill.Address', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'fields': [
                to_dict(item, casing_strategy)
                for item in data.fields
            ],
        }
    if casing_strategy == 'camel':
        return {
            'fields': [
                to_dict(item, casing_strategy)
                for item in data.fields
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Fields': [
                to_dict(item, casing_strategy)
                for item in data.fields
            ],
        }


def _map_autofill__address_ui__to_dict(data: 'autofill.AddressUI', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'address_fields': [
                to_dict(item, casing_strategy)
                for item in data.address_fields
            ],
        }
    if casing_strategy == 'camel':
        return {
            'addressFields': [
                to_dict(item, casing_strategy)
                for item in data.address_fields
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'AddressFields': [
                to_dict(item, casing_strategy)
                for item in data.address_fields
            ],
        }


def _map_autofill__filled_field__to_dict(data: 'autofill.FilledField', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'html_type': data.html_type,
            'id': data.id,
            'name': data.name,
            'value': data.value,
            'autofill_type': data.autofill_type,
            'filling_strategy': data.filling_strategy,
        }
    if casing_strategy == 'camel':
        return {
            'htmlType': data.html_type,
            'id': data.id,
            'name': data.name,
            'value': data.value,
            'autofillType': data.autofill_type,
            'fillingStrategy': data.filling_strategy,
        }
    if casing_strategy == 'pascal':
        return {
            'HtmlType': data.html_type,
            'Id': data.id,
            'Name': data.name,
            'Value': data.value,
            'AutofillType': data.autofill_type,
            'FillingStrategy': data.filling_strategy,
        }


def _map_background_service__event_metadata__to_dict(data: 'background_service.EventMetadata', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'key': data.key,
            'value': data.value,
        }
    if casing_strategy == 'camel':
        return {
            'key': data.key,
            'value': data.value,
        }
    if casing_strategy == 'pascal':
        return {
            'Key': data.key,
            'Value': data.value,
        }


def _map_background_service__background_service_event__to_dict(data: 'background_service.BackgroundServiceEvent', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'timestamp': data.timestamp,
            'origin': data.origin,
            'service_worker_registration_id': data.service_worker_registration_id,
            'service': data.service,
            'event_name': data.event_name,
            'instance_id': data.instance_id,
            'event_metadata': [
                to_dict(item, casing_strategy)
                for item in data.event_metadata
            ],
            'storage_key': data.storage_key,
        }
    if casing_strategy == 'camel':
        return {
            'timestamp': data.timestamp,
            'origin': data.origin,
            'serviceWorkerRegistrationId': data.service_worker_registration_id,
            'service': data.service,
            'eventName': data.event_name,
            'instanceId': data.instance_id,
            'eventMetadata': [
                to_dict(item, casing_strategy)
                for item in data.event_metadata
            ],
            'storageKey': data.storage_key,
        }
    if casing_strategy == 'pascal':
        return {
            'Timestamp': data.timestamp,
            'Origin': data.origin,
            'ServiceWorkerRegistrationId': data.service_worker_registration_id,
            'Service': data.service,
            'EventName': data.event_name,
            'InstanceId': data.instance_id,
            'EventMetadata': [
                to_dict(item, casing_strategy)
                for item in data.event_metadata
            ],
            'StorageKey': data.storage_key,
        }


def _map_browser__bounds__to_dict(data: 'browser.Bounds', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'left': data.left,
            'top': data.top,
            'width': data.width,
            'height': data.height,
            'window_state': data.window_state,
        }
    if casing_strategy == 'camel':
        return {
            'left': data.left,
            'top': data.top,
            'width': data.width,
            'height': data.height,
            'windowState': data.window_state,
        }
    if casing_strategy == 'pascal':
        return {
            'Left': data.left,
            'Top': data.top,
            'Width': data.width,
            'Height': data.height,
            'WindowState': data.window_state,
        }


def _map_browser__permission_descriptor__to_dict(data: 'browser.PermissionDescriptor', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'sysex': data.sysex,
            'user_visible_only': data.user_visible_only,
            'allow_without_sanitization': data.allow_without_sanitization,
            'pan_tilt_zoom': data.pan_tilt_zoom,
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'sysex': data.sysex,
            'userVisibleOnly': data.user_visible_only,
            'allowWithoutSanitization': data.allow_without_sanitization,
            'panTiltZoom': data.pan_tilt_zoom,
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Sysex': data.sysex,
            'UserVisibleOnly': data.user_visible_only,
            'AllowWithoutSanitization': data.allow_without_sanitization,
            'PanTiltZoom': data.pan_tilt_zoom,
        }


def _map_browser__bucket__to_dict(data: 'browser.Bucket', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'low': data.low,
            'high': data.high,
            'count': data.count,
        }
    if casing_strategy == 'camel':
        return {
            'low': data.low,
            'high': data.high,
            'count': data.count,
        }
    if casing_strategy == 'pascal':
        return {
            'Low': data.low,
            'High': data.high,
            'Count': data.count,
        }


def _map_browser__histogram__to_dict(data: 'browser.Histogram', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'sum': data.sum,
            'count': data.count,
            'buckets': [
                to_dict(item, casing_strategy)
                for item in data.buckets
            ],
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'sum': data.sum,
            'count': data.count,
            'buckets': [
                to_dict(item, casing_strategy)
                for item in data.buckets
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Sum': data.sum,
            'Count': data.count,
            'Buckets': [
                to_dict(item, casing_strategy)
                for item in data.buckets
            ],
        }


def _map_css__pseudo_element_matches__to_dict(data: 'css.PseudoElementMatches', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'pseudo_type': data.pseudo_type,
            'pseudo_identifier': data.pseudo_identifier,
            'matches': [
                to_dict(item, casing_strategy)
                for item in data.matches
            ],
        }
    if casing_strategy == 'camel':
        return {
            'pseudoType': data.pseudo_type,
            'pseudoIdentifier': data.pseudo_identifier,
            'matches': [
                to_dict(item, casing_strategy)
                for item in data.matches
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'PseudoType': data.pseudo_type,
            'PseudoIdentifier': data.pseudo_identifier,
            'Matches': [
                to_dict(item, casing_strategy)
                for item in data.matches
            ],
        }


def _map_css__inherited_style_entry__to_dict(data: 'css.InheritedStyleEntry', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'inline_style': to_dict(
                data.inline_style,
                casing_strategy
            ),
            'matched_css_rules': [
                to_dict(item, casing_strategy)
                for item in data.matched_css_rules
            ],
        }
    if casing_strategy == 'camel':
        return {
            'inlineStyle': to_dict(
                data.inline_style,
                casing_strategy
            ),
            'matchedCSSRules': [
                to_dict(item, casing_strategy)
                for item in data.matched_css_rules
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'InlineStyle': to_dict(
                data.inline_style,
                casing_strategy
            ),
            'MatchedCSSRules': [
                to_dict(item, casing_strategy)
                for item in data.matched_css_rules
            ],
        }


def _map_css__inherited_pseudo_element_matches__to_dict(data: 'css.InheritedPseudoElementMatches', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'pseudo_elements': [
                to_dict(item, casing_strategy)
                for item in data.pseudo_elements
            ],
        }
    if casing_strategy == 'camel':
        return {
            'pseudoElements': [
                to_dict(item, casing_strategy)
                for item in data.pseudo_elements
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'PseudoElements': [
                to_dict(item, casing_strategy)
                for item in data.pseudo_elements
            ],
        }


def _map_css__rule_match__to_dict(data: 'css.RuleMatch', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'rule': to_dict(
                data.rule,
                casing_strategy
            ),
            'matching_selectors': [
                item
                for item in data.matching_selectors
            ],
        }
    if casing_strategy == 'camel':
        return {
            'rule': to_dict(
                data.rule,
                casing_strategy
            ),
            'matchingSelectors': [
                item
                for item in data.matching_selectors
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Rule': to_dict(
                data.rule,
                casing_strategy
            ),
            'MatchingSelectors': [
                item
                for item in data.matching_selectors
            ],
        }


def _map_css__value__to_dict(data: 'css.Value', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'text': data.text,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'specificity': to_dict(
                data.specificity,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'text': data.text,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'specificity': to_dict(
                data.specificity,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'Text': data.text,
            'Range': to_dict(
                data.range,
                casing_strategy
            ),
            'Specificity': to_dict(
                data.specificity,
                casing_strategy
            ),
        }


def _map_css__specificity__to_dict(data: 'css.Specificity', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'a': data.a,
            'b': data.b,
            'c': data.c,
        }
    if casing_strategy == 'camel':
        return {
            'a': data.a,
            'b': data.b,
            'c': data.c,
        }
    if casing_strategy == 'pascal':
        return {
            'A': data.a,
            'B': data.b,
            'C': data.c,
        }


def _map_css__selector_list__to_dict(data: 'css.SelectorList', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'selectors': [
                to_dict(item, casing_strategy)
                for item in data.selectors
            ],
            'text': data.text,
        }
    if casing_strategy == 'camel':
        return {
            'selectors': [
                to_dict(item, casing_strategy)
                for item in data.selectors
            ],
            'text': data.text,
        }
    if casing_strategy == 'pascal':
        return {
            'Selectors': [
                to_dict(item, casing_strategy)
                for item in data.selectors
            ],
            'Text': data.text,
        }


def _map_css__css_style_sheet_header__to_dict(data: 'css.CSSStyleSheetHeader', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'style_sheet_id': data.style_sheet_id,
            'frame_id': data.frame_id,
            'source_url': data.source_url,
            'source_map_url': data.source_map_url,
            'origin': data.origin,
            'title': data.title,
            'owner_node': data.owner_node,
            'disabled': data.disabled,
            'has_source_url': data.has_source_url,
            'is_inline': data.is_inline,
            'is_mutable': data.is_mutable,
            'is_constructed': data.is_constructed,
            'start_line': data.start_line,
            'start_column': data.start_column,
            'length': data.length,
            'end_line': data.end_line,
            'end_column': data.end_column,
            'loading_failed': data.loading_failed,
        }
    if casing_strategy == 'camel':
        return {
            'styleSheetId': data.style_sheet_id,
            'frameId': data.frame_id,
            'sourceURL': data.source_url,
            'sourceMapURL': data.source_map_url,
            'origin': data.origin,
            'title': data.title,
            'ownerNode': data.owner_node,
            'disabled': data.disabled,
            'hasSourceURL': data.has_source_url,
            'isInline': data.is_inline,
            'isMutable': data.is_mutable,
            'isConstructed': data.is_constructed,
            'startLine': data.start_line,
            'startColumn': data.start_column,
            'length': data.length,
            'endLine': data.end_line,
            'endColumn': data.end_column,
            'loadingFailed': data.loading_failed,
        }
    if casing_strategy == 'pascal':
        return {
            'StyleSheetId': data.style_sheet_id,
            'FrameId': data.frame_id,
            'SourceURL': data.source_url,
            'SourceMapURL': data.source_map_url,
            'Origin': data.origin,
            'Title': data.title,
            'OwnerNode': data.owner_node,
            'Disabled': data.disabled,
            'HasSourceURL': data.has_source_url,
            'IsInline': data.is_inline,
            'IsMutable': data.is_mutable,
            'IsConstructed': data.is_constructed,
            'StartLine': data.start_line,
            'StartColumn': data.start_column,
            'Length': data.length,
            'EndLine': data.end_line,
            'EndColumn': data.end_column,
            'LoadingFailed': data.loading_failed,
        }


def _map_css__css_rule__to_dict(data: 'css.CSSRule', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'style_sheet_id': data.style_sheet_id,
            'selector_list': to_dict(
                data.selector_list,
                casing_strategy
            ),
            'nesting_selectors': [
                item
                for item in data.nesting_selectors
            ],
            'origin': data.origin,
            'style': to_dict(
                data.style,
                casing_strategy
            ),
            'media': [
                to_dict(item, casing_strategy)
                for item in data.media
            ],
            'container_queries': [
                to_dict(item, casing_strategy)
                for item in data.container_queries
            ],
            'supports': [
                to_dict(item, casing_strategy)
                for item in data.supports
            ],
            'layers': [
                to_dict(item, casing_strategy)
                for item in data.layers
            ],
            'scopes': [
                to_dict(item, casing_strategy)
                for item in data.scopes
            ],
            'rule_types': [
                item
                for item in data.rule_types
            ],
        }
    if casing_strategy == 'camel':
        return {
            'styleSheetId': data.style_sheet_id,
            'selectorList': to_dict(
                data.selector_list,
                casing_strategy
            ),
            'nestingSelectors': [
                item
                for item in data.nesting_selectors
            ],
            'origin': data.origin,
            'style': to_dict(
                data.style,
                casing_strategy
            ),
            'media': [
                to_dict(item, casing_strategy)
                for item in data.media
            ],
            'containerQueries': [
                to_dict(item, casing_strategy)
                for item in data.container_queries
            ],
            'supports': [
                to_dict(item, casing_strategy)
                for item in data.supports
            ],
            'layers': [
                to_dict(item, casing_strategy)
                for item in data.layers
            ],
            'scopes': [
                to_dict(item, casing_strategy)
                for item in data.scopes
            ],
            'ruleTypes': [
                item
                for item in data.rule_types
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'StyleSheetId': data.style_sheet_id,
            'SelectorList': to_dict(
                data.selector_list,
                casing_strategy
            ),
            'NestingSelectors': [
                item
                for item in data.nesting_selectors
            ],
            'Origin': data.origin,
            'Style': to_dict(
                data.style,
                casing_strategy
            ),
            'Media': [
                to_dict(item, casing_strategy)
                for item in data.media
            ],
            'ContainerQueries': [
                to_dict(item, casing_strategy)
                for item in data.container_queries
            ],
            'Supports': [
                to_dict(item, casing_strategy)
                for item in data.supports
            ],
            'Layers': [
                to_dict(item, casing_strategy)
                for item in data.layers
            ],
            'Scopes': [
                to_dict(item, casing_strategy)
                for item in data.scopes
            ],
            'RuleTypes': [
                item
                for item in data.rule_types
            ],
        }


def _map_css__rule_usage__to_dict(data: 'css.RuleUsage', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'style_sheet_id': data.style_sheet_id,
            'start_offset': data.start_offset,
            'end_offset': data.end_offset,
            'used': data.used,
        }
    if casing_strategy == 'camel':
        return {
            'styleSheetId': data.style_sheet_id,
            'startOffset': data.start_offset,
            'endOffset': data.end_offset,
            'used': data.used,
        }
    if casing_strategy == 'pascal':
        return {
            'StyleSheetId': data.style_sheet_id,
            'StartOffset': data.start_offset,
            'EndOffset': data.end_offset,
            'Used': data.used,
        }


def _map_css__source_range__to_dict(data: 'css.SourceRange', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'start_line': data.start_line,
            'start_column': data.start_column,
            'end_line': data.end_line,
            'end_column': data.end_column,
        }
    if casing_strategy == 'camel':
        return {
            'startLine': data.start_line,
            'startColumn': data.start_column,
            'endLine': data.end_line,
            'endColumn': data.end_column,
        }
    if casing_strategy == 'pascal':
        return {
            'StartLine': data.start_line,
            'StartColumn': data.start_column,
            'EndLine': data.end_line,
            'EndColumn': data.end_column,
        }


def _map_css__shorthand_entry__to_dict(data: 'css.ShorthandEntry', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
            'important': data.important,
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
            'important': data.important,
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
            'Important': data.important,
        }


def _map_css__css_computed_style_property__to_dict(data: 'css.CSSComputedStyleProperty', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
        }


def _map_css__css_style__to_dict(data: 'css.CSSStyle', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'style_sheet_id': data.style_sheet_id,
            'css_properties': [
                to_dict(item, casing_strategy)
                for item in data.css_properties
            ],
            'shorthand_entries': [
                to_dict(item, casing_strategy)
                for item in data.shorthand_entries
            ],
            'css_text': data.css_text,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'styleSheetId': data.style_sheet_id,
            'cssProperties': [
                to_dict(item, casing_strategy)
                for item in data.css_properties
            ],
            'shorthandEntries': [
                to_dict(item, casing_strategy)
                for item in data.shorthand_entries
            ],
            'cssText': data.css_text,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'StyleSheetId': data.style_sheet_id,
            'CssProperties': [
                to_dict(item, casing_strategy)
                for item in data.css_properties
            ],
            'ShorthandEntries': [
                to_dict(item, casing_strategy)
                for item in data.shorthand_entries
            ],
            'CssText': data.css_text,
            'Range': to_dict(
                data.range,
                casing_strategy
            ),
        }


def _map_css__css_property__to_dict(data: 'css.CSSProperty', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
            'important': data.important,
            'implicit': data.implicit,
            'text': data.text,
            'parsed_ok': data.parsed_ok,
            'disabled': data.disabled,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'longhand_properties': [
                to_dict(item, casing_strategy)
                for item in data.longhand_properties
            ],
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
            'important': data.important,
            'implicit': data.implicit,
            'text': data.text,
            'parsedOk': data.parsed_ok,
            'disabled': data.disabled,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'longhandProperties': [
                to_dict(item, casing_strategy)
                for item in data.longhand_properties
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
            'Important': data.important,
            'Implicit': data.implicit,
            'Text': data.text,
            'ParsedOk': data.parsed_ok,
            'Disabled': data.disabled,
            'Range': to_dict(
                data.range,
                casing_strategy
            ),
            'LonghandProperties': [
                to_dict(item, casing_strategy)
                for item in data.longhand_properties
            ],
        }


def _map_css__css_media__to_dict(data: 'css.CSSMedia', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'text': data.text,
            'source': data.source,
            'source_url': data.source_url,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'style_sheet_id': data.style_sheet_id,
            'media_list': [
                to_dict(item, casing_strategy)
                for item in data.media_list
            ],
        }
    if casing_strategy == 'camel':
        return {
            'text': data.text,
            'source': data.source,
            'sourceURL': data.source_url,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'styleSheetId': data.style_sheet_id,
            'mediaList': [
                to_dict(item, casing_strategy)
                for item in data.media_list
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Text': data.text,
            'Source': data.source,
            'SourceURL': data.source_url,
            'Range': to_dict(
                data.range,
                casing_strategy
            ),
            'StyleSheetId': data.style_sheet_id,
            'MediaList': [
                to_dict(item, casing_strategy)
                for item in data.media_list
            ],
        }


def _map_css__media_query__to_dict(data: 'css.MediaQuery', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'expressions': [
                to_dict(item, casing_strategy)
                for item in data.expressions
            ],
            'active': data.active,
        }
    if casing_strategy == 'camel':
        return {
            'expressions': [
                to_dict(item, casing_strategy)
                for item in data.expressions
            ],
            'active': data.active,
        }
    if casing_strategy == 'pascal':
        return {
            'Expressions': [
                to_dict(item, casing_strategy)
                for item in data.expressions
            ],
            'Active': data.active,
        }


def _map_css__media_query_expression__to_dict(data: 'css.MediaQueryExpression', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'value': data.value,
            'unit': data.unit,
            'feature': data.feature,
            'value_range': to_dict(
                data.value_range,
                casing_strategy
            ),
            'computed_length': data.computed_length,
        }
    if casing_strategy == 'camel':
        return {
            'value': data.value,
            'unit': data.unit,
            'feature': data.feature,
            'valueRange': to_dict(
                data.value_range,
                casing_strategy
            ),
            'computedLength': data.computed_length,
        }
    if casing_strategy == 'pascal':
        return {
            'Value': data.value,
            'Unit': data.unit,
            'Feature': data.feature,
            'ValueRange': to_dict(
                data.value_range,
                casing_strategy
            ),
            'ComputedLength': data.computed_length,
        }


def _map_css__css_container_query__to_dict(data: 'css.CSSContainerQuery', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'text': data.text,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'style_sheet_id': data.style_sheet_id,
            'name': data.name,
            'physical_axes': data.physical_axes,
            'logical_axes': data.logical_axes,
        }
    if casing_strategy == 'camel':
        return {
            'text': data.text,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'styleSheetId': data.style_sheet_id,
            'name': data.name,
            'physicalAxes': data.physical_axes,
            'logicalAxes': data.logical_axes,
        }
    if casing_strategy == 'pascal':
        return {
            'Text': data.text,
            'Range': to_dict(
                data.range,
                casing_strategy
            ),
            'StyleSheetId': data.style_sheet_id,
            'Name': data.name,
            'PhysicalAxes': data.physical_axes,
            'LogicalAxes': data.logical_axes,
        }


def _map_css__css_supports__to_dict(data: 'css.CSSSupports', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'text': data.text,
            'active': data.active,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'style_sheet_id': data.style_sheet_id,
        }
    if casing_strategy == 'camel':
        return {
            'text': data.text,
            'active': data.active,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'styleSheetId': data.style_sheet_id,
        }
    if casing_strategy == 'pascal':
        return {
            'Text': data.text,
            'Active': data.active,
            'Range': to_dict(
                data.range,
                casing_strategy
            ),
            'StyleSheetId': data.style_sheet_id,
        }


def _map_css__css_scope__to_dict(data: 'css.CSSScope', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'text': data.text,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'style_sheet_id': data.style_sheet_id,
        }
    if casing_strategy == 'camel':
        return {
            'text': data.text,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'styleSheetId': data.style_sheet_id,
        }
    if casing_strategy == 'pascal':
        return {
            'Text': data.text,
            'Range': to_dict(
                data.range,
                casing_strategy
            ),
            'StyleSheetId': data.style_sheet_id,
        }


def _map_css__css_layer__to_dict(data: 'css.CSSLayer', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'text': data.text,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'style_sheet_id': data.style_sheet_id,
        }
    if casing_strategy == 'camel':
        return {
            'text': data.text,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'styleSheetId': data.style_sheet_id,
        }
    if casing_strategy == 'pascal':
        return {
            'Text': data.text,
            'Range': to_dict(
                data.range,
                casing_strategy
            ),
            'StyleSheetId': data.style_sheet_id,
        }


def _map_css__css_layer_data__to_dict(data: 'css.CSSLayerData', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'sub_layers': [
                to_dict(item, casing_strategy)
                for item in data.sub_layers
            ],
            'order': data.order,
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'subLayers': [
                to_dict(item, casing_strategy)
                for item in data.sub_layers
            ],
            'order': data.order,
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'SubLayers': [
                to_dict(item, casing_strategy)
                for item in data.sub_layers
            ],
            'Order': data.order,
        }


def _map_css__platform_font_usage__to_dict(data: 'css.PlatformFontUsage', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'family_name': data.family_name,
            'is_custom_font': data.is_custom_font,
            'glyph_count': data.glyph_count,
        }
    if casing_strategy == 'camel':
        return {
            'familyName': data.family_name,
            'isCustomFont': data.is_custom_font,
            'glyphCount': data.glyph_count,
        }
    if casing_strategy == 'pascal':
        return {
            'FamilyName': data.family_name,
            'IsCustomFont': data.is_custom_font,
            'GlyphCount': data.glyph_count,
        }


def _map_css__font_variation_axis__to_dict(data: 'css.FontVariationAxis', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'tag': data.tag,
            'name': data.name,
            'min_value': data.min_value,
            'max_value': data.max_value,
            'default_value': data.default_value,
        }
    if casing_strategy == 'camel':
        return {
            'tag': data.tag,
            'name': data.name,
            'minValue': data.min_value,
            'maxValue': data.max_value,
            'defaultValue': data.default_value,
        }
    if casing_strategy == 'pascal':
        return {
            'Tag': data.tag,
            'Name': data.name,
            'MinValue': data.min_value,
            'MaxValue': data.max_value,
            'DefaultValue': data.default_value,
        }


def _map_css__font_face__to_dict(data: 'css.FontFace', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'font_family': data.font_family,
            'font_style': data.font_style,
            'font_variant': data.font_variant,
            'font_weight': data.font_weight,
            'font_stretch': data.font_stretch,
            'font_display': data.font_display,
            'unicode_range': data.unicode_range,
            'src': data.src,
            'platform_font_family': data.platform_font_family,
            'font_variation_axes': [
                to_dict(item, casing_strategy)
                for item in data.font_variation_axes
            ],
        }
    if casing_strategy == 'camel':
        return {
            'fontFamily': data.font_family,
            'fontStyle': data.font_style,
            'fontVariant': data.font_variant,
            'fontWeight': data.font_weight,
            'fontStretch': data.font_stretch,
            'fontDisplay': data.font_display,
            'unicodeRange': data.unicode_range,
            'src': data.src,
            'platformFontFamily': data.platform_font_family,
            'fontVariationAxes': [
                to_dict(item, casing_strategy)
                for item in data.font_variation_axes
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'FontFamily': data.font_family,
            'FontStyle': data.font_style,
            'FontVariant': data.font_variant,
            'FontWeight': data.font_weight,
            'FontStretch': data.font_stretch,
            'FontDisplay': data.font_display,
            'UnicodeRange': data.unicode_range,
            'Src': data.src,
            'PlatformFontFamily': data.platform_font_family,
            'FontVariationAxes': [
                to_dict(item, casing_strategy)
                for item in data.font_variation_axes
            ],
        }


def _map_css__css_try_rule__to_dict(data: 'css.CSSTryRule', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'style_sheet_id': data.style_sheet_id,
            'origin': data.origin,
            'style': to_dict(
                data.style,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'styleSheetId': data.style_sheet_id,
            'origin': data.origin,
            'style': to_dict(
                data.style,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'StyleSheetId': data.style_sheet_id,
            'Origin': data.origin,
            'Style': to_dict(
                data.style,
                casing_strategy
            ),
        }


def _map_css__css_position_fallback_rule__to_dict(data: 'css.CSSPositionFallbackRule', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': to_dict(
                data.name,
                casing_strategy
            ),
            'try_rules': [
                to_dict(item, casing_strategy)
                for item in data.try_rules
            ],
        }
    if casing_strategy == 'camel':
        return {
            'name': to_dict(
                data.name,
                casing_strategy
            ),
            'tryRules': [
                to_dict(item, casing_strategy)
                for item in data.try_rules
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Name': to_dict(
                data.name,
                casing_strategy
            ),
            'TryRules': [
                to_dict(item, casing_strategy)
                for item in data.try_rules
            ],
        }


def _map_css__css_keyframes_rule__to_dict(data: 'css.CSSKeyframesRule', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'animation_name': to_dict(
                data.animation_name,
                casing_strategy
            ),
            'keyframes': [
                to_dict(item, casing_strategy)
                for item in data.keyframes
            ],
        }
    if casing_strategy == 'camel':
        return {
            'animationName': to_dict(
                data.animation_name,
                casing_strategy
            ),
            'keyframes': [
                to_dict(item, casing_strategy)
                for item in data.keyframes
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'AnimationName': to_dict(
                data.animation_name,
                casing_strategy
            ),
            'Keyframes': [
                to_dict(item, casing_strategy)
                for item in data.keyframes
            ],
        }


def _map_css__css_property_registration__to_dict(data: 'css.CSSPropertyRegistration', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'property_name': data.property_name,
            'initial_value': to_dict(
                data.initial_value,
                casing_strategy
            ),
            'inherits': data.inherits,
            'syntax': data.syntax,
        }
    if casing_strategy == 'camel':
        return {
            'propertyName': data.property_name,
            'initialValue': to_dict(
                data.initial_value,
                casing_strategy
            ),
            'inherits': data.inherits,
            'syntax': data.syntax,
        }
    if casing_strategy == 'pascal':
        return {
            'PropertyName': data.property_name,
            'InitialValue': to_dict(
                data.initial_value,
                casing_strategy
            ),
            'Inherits': data.inherits,
            'Syntax': data.syntax,
        }


def _map_css__css_property_rule__to_dict(data: 'css.CSSPropertyRule', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'style_sheet_id': data.style_sheet_id,
            'origin': data.origin,
            'property_name': to_dict(
                data.property_name,
                casing_strategy
            ),
            'style': to_dict(
                data.style,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'styleSheetId': data.style_sheet_id,
            'origin': data.origin,
            'propertyName': to_dict(
                data.property_name,
                casing_strategy
            ),
            'style': to_dict(
                data.style,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'StyleSheetId': data.style_sheet_id,
            'Origin': data.origin,
            'PropertyName': to_dict(
                data.property_name,
                casing_strategy
            ),
            'Style': to_dict(
                data.style,
                casing_strategy
            ),
        }


def _map_css__css_keyframe_rule__to_dict(data: 'css.CSSKeyframeRule', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'style_sheet_id': data.style_sheet_id,
            'origin': data.origin,
            'key_text': to_dict(
                data.key_text,
                casing_strategy
            ),
            'style': to_dict(
                data.style,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'styleSheetId': data.style_sheet_id,
            'origin': data.origin,
            'keyText': to_dict(
                data.key_text,
                casing_strategy
            ),
            'style': to_dict(
                data.style,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'StyleSheetId': data.style_sheet_id,
            'Origin': data.origin,
            'KeyText': to_dict(
                data.key_text,
                casing_strategy
            ),
            'Style': to_dict(
                data.style,
                casing_strategy
            ),
        }


def _map_css__style_declaration_edit__to_dict(data: 'css.StyleDeclarationEdit', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'style_sheet_id': data.style_sheet_id,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'text': data.text,
        }
    if casing_strategy == 'camel':
        return {
            'styleSheetId': data.style_sheet_id,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'text': data.text,
        }
    if casing_strategy == 'pascal':
        return {
            'StyleSheetId': data.style_sheet_id,
            'Range': to_dict(
                data.range,
                casing_strategy
            ),
            'Text': data.text,
        }


def _map_cache_storage__data_entry__to_dict(data: 'cache_storage.DataEntry', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'request_url': data.request_url,
            'request_method': data.request_method,
            'request_headers': [
                to_dict(item, casing_strategy)
                for item in data.request_headers
            ],
            'response_time': data.response_time,
            'response_status': data.response_status,
            'response_status_text': data.response_status_text,
            'response_type': data.response_type,
            'response_headers': [
                to_dict(item, casing_strategy)
                for item in data.response_headers
            ],
        }
    if casing_strategy == 'camel':
        return {
            'requestURL': data.request_url,
            'requestMethod': data.request_method,
            'requestHeaders': [
                to_dict(item, casing_strategy)
                for item in data.request_headers
            ],
            'responseTime': data.response_time,
            'responseStatus': data.response_status,
            'responseStatusText': data.response_status_text,
            'responseType': data.response_type,
            'responseHeaders': [
                to_dict(item, casing_strategy)
                for item in data.response_headers
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'RequestURL': data.request_url,
            'RequestMethod': data.request_method,
            'RequestHeaders': [
                to_dict(item, casing_strategy)
                for item in data.request_headers
            ],
            'ResponseTime': data.response_time,
            'ResponseStatus': data.response_status,
            'ResponseStatusText': data.response_status_text,
            'ResponseType': data.response_type,
            'ResponseHeaders': [
                to_dict(item, casing_strategy)
                for item in data.response_headers
            ],
        }


def _map_cache_storage__cache__to_dict(data: 'cache_storage.Cache', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'cache_id': data.cache_id,
            'security_origin': data.security_origin,
            'storage_key': data.storage_key,
            'storage_bucket': to_dict(
                data.storage_bucket,
                casing_strategy
            ),
            'cache_name': data.cache_name,
        }
    if casing_strategy == 'camel':
        return {
            'cacheId': data.cache_id,
            'securityOrigin': data.security_origin,
            'storageKey': data.storage_key,
            'storageBucket': to_dict(
                data.storage_bucket,
                casing_strategy
            ),
            'cacheName': data.cache_name,
        }
    if casing_strategy == 'pascal':
        return {
            'CacheId': data.cache_id,
            'SecurityOrigin': data.security_origin,
            'StorageKey': data.storage_key,
            'StorageBucket': to_dict(
                data.storage_bucket,
                casing_strategy
            ),
            'CacheName': data.cache_name,
        }


def _map_cache_storage__header__to_dict(data: 'cache_storage.Header', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
        }


def _map_cache_storage__cached_response__to_dict(data: 'cache_storage.CachedResponse', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'body': data.body,
        }
    if casing_strategy == 'camel':
        return {
            'body': data.body,
        }
    if casing_strategy == 'pascal':
        return {
            'Body': data.body,
        }


def _map_cast__sink__to_dict(data: 'cast.Sink', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'id': data.id,
            'session': data.session,
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'id': data.id,
            'session': data.session,
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Id': data.id,
            'Session': data.session,
        }


def _map_dom__backend_node__to_dict(data: 'dom.BackendNode', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'node_type': data.node_type,
            'node_name': data.node_name,
            'backend_node_id': data.backend_node_id,
        }
    if casing_strategy == 'camel':
        return {
            'nodeType': data.node_type,
            'nodeName': data.node_name,
            'backendNodeId': data.backend_node_id,
        }
    if casing_strategy == 'pascal':
        return {
            'NodeType': data.node_type,
            'NodeName': data.node_name,
            'BackendNodeId': data.backend_node_id,
        }


def _map_dom__node__to_dict(data: 'dom.Node', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'node_id': data.node_id,
            'parent_id': data.parent_id,
            'backend_node_id': data.backend_node_id,
            'node_type': data.node_type,
            'node_name': data.node_name,
            'local_name': data.local_name,
            'node_value': data.node_value,
            'child_node_count': data.child_node_count,
            'children': [
                to_dict(item, casing_strategy)
                for item in data.children
            ],
            'attributes': [
                item
                for item in data.attributes
            ],
            'document_url': data.document_url,
            'base_url': data.base_url,
            'public_id': data.public_id,
            'system_id': data.system_id,
            'internal_subset': data.internal_subset,
            'xml_version': data.xml_version,
            'name': data.name,
            'value': data.value,
            'pseudo_type': data.pseudo_type,
            'pseudo_identifier': data.pseudo_identifier,
            'shadow_root_type': data.shadow_root_type,
            'frame_id': data.frame_id,
            'content_document': to_dict(
                data.content_document,
                casing_strategy
            ),
            'shadow_roots': [
                to_dict(item, casing_strategy)
                for item in data.shadow_roots
            ],
            'template_content': to_dict(
                data.template_content,
                casing_strategy
            ),
            'pseudo_elements': [
                to_dict(item, casing_strategy)
                for item in data.pseudo_elements
            ],
            'imported_document': to_dict(
                data.imported_document,
                casing_strategy
            ),
            'distributed_nodes': [
                to_dict(item, casing_strategy)
                for item in data.distributed_nodes
            ],
            'is_svg': data.is_svg,
            'compatibility_mode': data.compatibility_mode,
            'assigned_slot': to_dict(
                data.assigned_slot,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'nodeId': data.node_id,
            'parentId': data.parent_id,
            'backendNodeId': data.backend_node_id,
            'nodeType': data.node_type,
            'nodeName': data.node_name,
            'localName': data.local_name,
            'nodeValue': data.node_value,
            'childNodeCount': data.child_node_count,
            'children': [
                to_dict(item, casing_strategy)
                for item in data.children
            ],
            'attributes': [
                item
                for item in data.attributes
            ],
            'documentURL': data.document_url,
            'baseURL': data.base_url,
            'publicId': data.public_id,
            'systemId': data.system_id,
            'internalSubset': data.internal_subset,
            'xmlVersion': data.xml_version,
            'name': data.name,
            'value': data.value,
            'pseudoType': data.pseudo_type,
            'pseudoIdentifier': data.pseudo_identifier,
            'shadowRootType': data.shadow_root_type,
            'frameId': data.frame_id,
            'contentDocument': to_dict(
                data.content_document,
                casing_strategy
            ),
            'shadowRoots': [
                to_dict(item, casing_strategy)
                for item in data.shadow_roots
            ],
            'templateContent': to_dict(
                data.template_content,
                casing_strategy
            ),
            'pseudoElements': [
                to_dict(item, casing_strategy)
                for item in data.pseudo_elements
            ],
            'importedDocument': to_dict(
                data.imported_document,
                casing_strategy
            ),
            'distributedNodes': [
                to_dict(item, casing_strategy)
                for item in data.distributed_nodes
            ],
            'isSVG': data.is_svg,
            'compatibilityMode': data.compatibility_mode,
            'assignedSlot': to_dict(
                data.assigned_slot,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'NodeId': data.node_id,
            'ParentId': data.parent_id,
            'BackendNodeId': data.backend_node_id,
            'NodeType': data.node_type,
            'NodeName': data.node_name,
            'LocalName': data.local_name,
            'NodeValue': data.node_value,
            'ChildNodeCount': data.child_node_count,
            'Children': [
                to_dict(item, casing_strategy)
                for item in data.children
            ],
            'Attributes': [
                item
                for item in data.attributes
            ],
            'DocumentURL': data.document_url,
            'BaseURL': data.base_url,
            'PublicId': data.public_id,
            'SystemId': data.system_id,
            'InternalSubset': data.internal_subset,
            'XmlVersion': data.xml_version,
            'Name': data.name,
            'Value': data.value,
            'PseudoType': data.pseudo_type,
            'PseudoIdentifier': data.pseudo_identifier,
            'ShadowRootType': data.shadow_root_type,
            'FrameId': data.frame_id,
            'ContentDocument': to_dict(
                data.content_document,
                casing_strategy
            ),
            'ShadowRoots': [
                to_dict(item, casing_strategy)
                for item in data.shadow_roots
            ],
            'TemplateContent': to_dict(
                data.template_content,
                casing_strategy
            ),
            'PseudoElements': [
                to_dict(item, casing_strategy)
                for item in data.pseudo_elements
            ],
            'ImportedDocument': to_dict(
                data.imported_document,
                casing_strategy
            ),
            'DistributedNodes': [
                to_dict(item, casing_strategy)
                for item in data.distributed_nodes
            ],
            'IsSVG': data.is_svg,
            'CompatibilityMode': data.compatibility_mode,
            'AssignedSlot': to_dict(
                data.assigned_slot,
                casing_strategy
            ),
        }


def _map_dom__rgba__to_dict(data: 'dom.RGBA', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'r': data.r,
            'g': data.g,
            'b': data.b,
            'a': data.a,
        }
    if casing_strategy == 'camel':
        return {
            'r': data.r,
            'g': data.g,
            'b': data.b,
            'a': data.a,
        }
    if casing_strategy == 'pascal':
        return {
            'R': data.r,
            'G': data.g,
            'B': data.b,
            'A': data.a,
        }


def _map_dom__box_model__to_dict(data: 'dom.BoxModel', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'content': data.content,
            'padding': data.padding,
            'border': data.border,
            'margin': data.margin,
            'width': data.width,
            'height': data.height,
            'shape_outside': to_dict(
                data.shape_outside,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'content': data.content,
            'padding': data.padding,
            'border': data.border,
            'margin': data.margin,
            'width': data.width,
            'height': data.height,
            'shapeOutside': to_dict(
                data.shape_outside,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'Content': data.content,
            'Padding': data.padding,
            'Border': data.border,
            'Margin': data.margin,
            'Width': data.width,
            'Height': data.height,
            'ShapeOutside': to_dict(
                data.shape_outside,
                casing_strategy
            ),
        }


def _map_dom__shape_outside_info__to_dict(data: 'dom.ShapeOutsideInfo', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'bounds': data.bounds,
            'shape': [
                item
                for item in data.shape
            ],
            'margin_shape': [
                item
                for item in data.margin_shape
            ],
        }
    if casing_strategy == 'camel':
        return {
            'bounds': data.bounds,
            'shape': [
                item
                for item in data.shape
            ],
            'marginShape': [
                item
                for item in data.margin_shape
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Bounds': data.bounds,
            'Shape': [
                item
                for item in data.shape
            ],
            'MarginShape': [
                item
                for item in data.margin_shape
            ],
        }


def _map_dom__rect__to_dict(data: 'dom.Rect', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'x': data.x,
            'y': data.y,
            'width': data.width,
            'height': data.height,
        }
    if casing_strategy == 'camel':
        return {
            'x': data.x,
            'y': data.y,
            'width': data.width,
            'height': data.height,
        }
    if casing_strategy == 'pascal':
        return {
            'X': data.x,
            'Y': data.y,
            'Width': data.width,
            'Height': data.height,
        }


def _map_dom__css_computed_style_property__to_dict(data: 'dom.CSSComputedStyleProperty', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
        }


def _map_dom_debugger__event_listener__to_dict(data: 'dom_debugger.EventListener', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'use_capture': data.use_capture,
            'passive': data.passive,
            'once': data.once,
            'script_id': data.script_id,
            'line_number': data.line_number,
            'column_number': data.column_number,
            'handler': to_dict(
                data.handler,
                casing_strategy
            ),
            'original_handler': to_dict(
                data.original_handler,
                casing_strategy
            ),
            'backend_node_id': data.backend_node_id,
        }
    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'useCapture': data.use_capture,
            'passive': data.passive,
            'once': data.once,
            'scriptId': data.script_id,
            'lineNumber': data.line_number,
            'columnNumber': data.column_number,
            'handler': to_dict(
                data.handler,
                casing_strategy
            ),
            'originalHandler': to_dict(
                data.original_handler,
                casing_strategy
            ),
            'backendNodeId': data.backend_node_id,
        }
    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'UseCapture': data.use_capture,
            'Passive': data.passive,
            'Once': data.once,
            'ScriptId': data.script_id,
            'LineNumber': data.line_number,
            'ColumnNumber': data.column_number,
            'Handler': to_dict(
                data.handler,
                casing_strategy
            ),
            'OriginalHandler': to_dict(
                data.original_handler,
                casing_strategy
            ),
            'BackendNodeId': data.backend_node_id,
        }


def _map_dom_snapshot__dom_node__to_dict(data: 'dom_snapshot.DOMNode', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'node_type': data.node_type,
            'node_name': data.node_name,
            'node_value': data.node_value,
            'text_value': data.text_value,
            'input_value': data.input_value,
            'input_checked': data.input_checked,
            'option_selected': data.option_selected,
            'backend_node_id': data.backend_node_id,
            'child_node_indexes': [
                item
                for item in data.child_node_indexes
            ],
            'attributes': [
                to_dict(item, casing_strategy)
                for item in data.attributes
            ],
            'pseudo_element_indexes': [
                item
                for item in data.pseudo_element_indexes
            ],
            'layout_node_index': data.layout_node_index,
            'document_url': data.document_url,
            'base_url': data.base_url,
            'content_language': data.content_language,
            'document_encoding': data.document_encoding,
            'public_id': data.public_id,
            'system_id': data.system_id,
            'frame_id': data.frame_id,
            'content_document_index': data.content_document_index,
            'pseudo_type': data.pseudo_type,
            'shadow_root_type': data.shadow_root_type,
            'is_clickable': data.is_clickable,
            'event_listeners': [
                to_dict(item, casing_strategy)
                for item in data.event_listeners
            ],
            'current_source_url': data.current_source_url,
            'origin_url': data.origin_url,
            'scroll_offset_x': data.scroll_offset_x,
            'scroll_offset_y': data.scroll_offset_y,
        }
    if casing_strategy == 'camel':
        return {
            'nodeType': data.node_type,
            'nodeName': data.node_name,
            'nodeValue': data.node_value,
            'textValue': data.text_value,
            'inputValue': data.input_value,
            'inputChecked': data.input_checked,
            'optionSelected': data.option_selected,
            'backendNodeId': data.backend_node_id,
            'childNodeIndexes': [
                item
                for item in data.child_node_indexes
            ],
            'attributes': [
                to_dict(item, casing_strategy)
                for item in data.attributes
            ],
            'pseudoElementIndexes': [
                item
                for item in data.pseudo_element_indexes
            ],
            'layoutNodeIndex': data.layout_node_index,
            'documentURL': data.document_url,
            'baseURL': data.base_url,
            'contentLanguage': data.content_language,
            'documentEncoding': data.document_encoding,
            'publicId': data.public_id,
            'systemId': data.system_id,
            'frameId': data.frame_id,
            'contentDocumentIndex': data.content_document_index,
            'pseudoType': data.pseudo_type,
            'shadowRootType': data.shadow_root_type,
            'isClickable': data.is_clickable,
            'eventListeners': [
                to_dict(item, casing_strategy)
                for item in data.event_listeners
            ],
            'currentSourceURL': data.current_source_url,
            'originURL': data.origin_url,
            'scrollOffsetX': data.scroll_offset_x,
            'scrollOffsetY': data.scroll_offset_y,
        }
    if casing_strategy == 'pascal':
        return {
            'NodeType': data.node_type,
            'NodeName': data.node_name,
            'NodeValue': data.node_value,
            'TextValue': data.text_value,
            'InputValue': data.input_value,
            'InputChecked': data.input_checked,
            'OptionSelected': data.option_selected,
            'BackendNodeId': data.backend_node_id,
            'ChildNodeIndexes': [
                item
                for item in data.child_node_indexes
            ],
            'Attributes': [
                to_dict(item, casing_strategy)
                for item in data.attributes
            ],
            'PseudoElementIndexes': [
                item
                for item in data.pseudo_element_indexes
            ],
            'LayoutNodeIndex': data.layout_node_index,
            'DocumentURL': data.document_url,
            'BaseURL': data.base_url,
            'ContentLanguage': data.content_language,
            'DocumentEncoding': data.document_encoding,
            'PublicId': data.public_id,
            'SystemId': data.system_id,
            'FrameId': data.frame_id,
            'ContentDocumentIndex': data.content_document_index,
            'PseudoType': data.pseudo_type,
            'ShadowRootType': data.shadow_root_type,
            'IsClickable': data.is_clickable,
            'EventListeners': [
                to_dict(item, casing_strategy)
                for item in data.event_listeners
            ],
            'CurrentSourceURL': data.current_source_url,
            'OriginURL': data.origin_url,
            'ScrollOffsetX': data.scroll_offset_x,
            'ScrollOffsetY': data.scroll_offset_y,
        }


def _map_dom_snapshot__inline_text_box__to_dict(data: 'dom_snapshot.InlineTextBox', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'bounding_box': to_dict(
                data.bounding_box,
                casing_strategy
            ),
            'start_character_index': data.start_character_index,
            'num_characters': data.num_characters,
        }
    if casing_strategy == 'camel':
        return {
            'boundingBox': to_dict(
                data.bounding_box,
                casing_strategy
            ),
            'startCharacterIndex': data.start_character_index,
            'numCharacters': data.num_characters,
        }
    if casing_strategy == 'pascal':
        return {
            'BoundingBox': to_dict(
                data.bounding_box,
                casing_strategy
            ),
            'StartCharacterIndex': data.start_character_index,
            'NumCharacters': data.num_characters,
        }


def _map_dom_snapshot__layout_tree_node__to_dict(data: 'dom_snapshot.LayoutTreeNode', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'dom_node_index': data.dom_node_index,
            'bounding_box': to_dict(
                data.bounding_box,
                casing_strategy
            ),
            'layout_text': data.layout_text,
            'inline_text_nodes': [
                to_dict(item, casing_strategy)
                for item in data.inline_text_nodes
            ],
            'style_index': data.style_index,
            'paint_order': data.paint_order,
            'is_stacking_context': data.is_stacking_context,
        }
    if casing_strategy == 'camel':
        return {
            'domNodeIndex': data.dom_node_index,
            'boundingBox': to_dict(
                data.bounding_box,
                casing_strategy
            ),
            'layoutText': data.layout_text,
            'inlineTextNodes': [
                to_dict(item, casing_strategy)
                for item in data.inline_text_nodes
            ],
            'styleIndex': data.style_index,
            'paintOrder': data.paint_order,
            'isStackingContext': data.is_stacking_context,
        }
    if casing_strategy == 'pascal':
        return {
            'DomNodeIndex': data.dom_node_index,
            'BoundingBox': to_dict(
                data.bounding_box,
                casing_strategy
            ),
            'LayoutText': data.layout_text,
            'InlineTextNodes': [
                to_dict(item, casing_strategy)
                for item in data.inline_text_nodes
            ],
            'StyleIndex': data.style_index,
            'PaintOrder': data.paint_order,
            'IsStackingContext': data.is_stacking_context,
        }


def _map_dom_snapshot__computed_style__to_dict(data: 'dom_snapshot.ComputedStyle', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'properties': [
                to_dict(item, casing_strategy)
                for item in data.properties
            ],
        }
    if casing_strategy == 'camel':
        return {
            'properties': [
                to_dict(item, casing_strategy)
                for item in data.properties
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Properties': [
                to_dict(item, casing_strategy)
                for item in data.properties
            ],
        }


def _map_dom_snapshot__name_value__to_dict(data: 'dom_snapshot.NameValue', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
        }


def _map_dom_snapshot__rare_string_data__to_dict(data: 'dom_snapshot.RareStringData', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'index': [
                item
                for item in data.index
            ],
            'value': [
                item
                for item in data.value
            ],
        }
    if casing_strategy == 'camel':
        return {
            'index': [
                item
                for item in data.index
            ],
            'value': [
                item
                for item in data.value
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Index': [
                item
                for item in data.index
            ],
            'Value': [
                item
                for item in data.value
            ],
        }


def _map_dom_snapshot__rare_boolean_data__to_dict(data: 'dom_snapshot.RareBooleanData', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'index': [
                item
                for item in data.index
            ],
        }
    if casing_strategy == 'camel':
        return {
            'index': [
                item
                for item in data.index
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Index': [
                item
                for item in data.index
            ],
        }


def _map_dom_snapshot__rare_integer_data__to_dict(data: 'dom_snapshot.RareIntegerData', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'index': [
                item
                for item in data.index
            ],
            'value': [
                item
                for item in data.value
            ],
        }
    if casing_strategy == 'camel':
        return {
            'index': [
                item
                for item in data.index
            ],
            'value': [
                item
                for item in data.value
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Index': [
                item
                for item in data.index
            ],
            'Value': [
                item
                for item in data.value
            ],
        }


def _map_dom_snapshot__document_snapshot__to_dict(data: 'dom_snapshot.DocumentSnapshot', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'document_url': data.document_url,
            'title': data.title,
            'base_url': data.base_url,
            'content_language': data.content_language,
            'encoding_name': data.encoding_name,
            'public_id': data.public_id,
            'system_id': data.system_id,
            'frame_id': data.frame_id,
            'nodes': to_dict(
                data.nodes,
                casing_strategy
            ),
            'layout': to_dict(
                data.layout,
                casing_strategy
            ),
            'text_boxes': to_dict(
                data.text_boxes,
                casing_strategy
            ),
            'scroll_offset_x': data.scroll_offset_x,
            'scroll_offset_y': data.scroll_offset_y,
            'content_width': data.content_width,
            'content_height': data.content_height,
        }
    if casing_strategy == 'camel':
        return {
            'documentURL': data.document_url,
            'title': data.title,
            'baseURL': data.base_url,
            'contentLanguage': data.content_language,
            'encodingName': data.encoding_name,
            'publicId': data.public_id,
            'systemId': data.system_id,
            'frameId': data.frame_id,
            'nodes': to_dict(
                data.nodes,
                casing_strategy
            ),
            'layout': to_dict(
                data.layout,
                casing_strategy
            ),
            'textBoxes': to_dict(
                data.text_boxes,
                casing_strategy
            ),
            'scrollOffsetX': data.scroll_offset_x,
            'scrollOffsetY': data.scroll_offset_y,
            'contentWidth': data.content_width,
            'contentHeight': data.content_height,
        }
    if casing_strategy == 'pascal':
        return {
            'DocumentURL': data.document_url,
            'Title': data.title,
            'BaseURL': data.base_url,
            'ContentLanguage': data.content_language,
            'EncodingName': data.encoding_name,
            'PublicId': data.public_id,
            'SystemId': data.system_id,
            'FrameId': data.frame_id,
            'Nodes': to_dict(
                data.nodes,
                casing_strategy
            ),
            'Layout': to_dict(
                data.layout,
                casing_strategy
            ),
            'TextBoxes': to_dict(
                data.text_boxes,
                casing_strategy
            ),
            'ScrollOffsetX': data.scroll_offset_x,
            'ScrollOffsetY': data.scroll_offset_y,
            'ContentWidth': data.content_width,
            'ContentHeight': data.content_height,
        }


def _map_dom_snapshot__node_tree_snapshot__to_dict(data: 'dom_snapshot.NodeTreeSnapshot', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'parent_index': [
                item
                for item in data.parent_index
            ],
            'node_type': [
                item
                for item in data.node_type
            ],
            'shadow_root_type': to_dict(
                data.shadow_root_type,
                casing_strategy
            ),
            'node_name': [
                item
                for item in data.node_name
            ],
            'node_value': [
                item
                for item in data.node_value
            ],
            'backend_node_id': [
                item
                for item in data.backend_node_id
            ],
            'attributes': [
                item
                for item in data.attributes
            ],
            'text_value': to_dict(
                data.text_value,
                casing_strategy
            ),
            'input_value': to_dict(
                data.input_value,
                casing_strategy
            ),
            'input_checked': to_dict(
                data.input_checked,
                casing_strategy
            ),
            'option_selected': to_dict(
                data.option_selected,
                casing_strategy
            ),
            'content_document_index': to_dict(
                data.content_document_index,
                casing_strategy
            ),
            'pseudo_type': to_dict(
                data.pseudo_type,
                casing_strategy
            ),
            'pseudo_identifier': to_dict(
                data.pseudo_identifier,
                casing_strategy
            ),
            'is_clickable': to_dict(
                data.is_clickable,
                casing_strategy
            ),
            'current_source_url': to_dict(
                data.current_source_url,
                casing_strategy
            ),
            'origin_url': to_dict(
                data.origin_url,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'parentIndex': [
                item
                for item in data.parent_index
            ],
            'nodeType': [
                item
                for item in data.node_type
            ],
            'shadowRootType': to_dict(
                data.shadow_root_type,
                casing_strategy
            ),
            'nodeName': [
                item
                for item in data.node_name
            ],
            'nodeValue': [
                item
                for item in data.node_value
            ],
            'backendNodeId': [
                item
                for item in data.backend_node_id
            ],
            'attributes': [
                item
                for item in data.attributes
            ],
            'textValue': to_dict(
                data.text_value,
                casing_strategy
            ),
            'inputValue': to_dict(
                data.input_value,
                casing_strategy
            ),
            'inputChecked': to_dict(
                data.input_checked,
                casing_strategy
            ),
            'optionSelected': to_dict(
                data.option_selected,
                casing_strategy
            ),
            'contentDocumentIndex': to_dict(
                data.content_document_index,
                casing_strategy
            ),
            'pseudoType': to_dict(
                data.pseudo_type,
                casing_strategy
            ),
            'pseudoIdentifier': to_dict(
                data.pseudo_identifier,
                casing_strategy
            ),
            'isClickable': to_dict(
                data.is_clickable,
                casing_strategy
            ),
            'currentSourceURL': to_dict(
                data.current_source_url,
                casing_strategy
            ),
            'originURL': to_dict(
                data.origin_url,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'ParentIndex': [
                item
                for item in data.parent_index
            ],
            'NodeType': [
                item
                for item in data.node_type
            ],
            'ShadowRootType': to_dict(
                data.shadow_root_type,
                casing_strategy
            ),
            'NodeName': [
                item
                for item in data.node_name
            ],
            'NodeValue': [
                item
                for item in data.node_value
            ],
            'BackendNodeId': [
                item
                for item in data.backend_node_id
            ],
            'Attributes': [
                item
                for item in data.attributes
            ],
            'TextValue': to_dict(
                data.text_value,
                casing_strategy
            ),
            'InputValue': to_dict(
                data.input_value,
                casing_strategy
            ),
            'InputChecked': to_dict(
                data.input_checked,
                casing_strategy
            ),
            'OptionSelected': to_dict(
                data.option_selected,
                casing_strategy
            ),
            'ContentDocumentIndex': to_dict(
                data.content_document_index,
                casing_strategy
            ),
            'PseudoType': to_dict(
                data.pseudo_type,
                casing_strategy
            ),
            'PseudoIdentifier': to_dict(
                data.pseudo_identifier,
                casing_strategy
            ),
            'IsClickable': to_dict(
                data.is_clickable,
                casing_strategy
            ),
            'CurrentSourceURL': to_dict(
                data.current_source_url,
                casing_strategy
            ),
            'OriginURL': to_dict(
                data.origin_url,
                casing_strategy
            ),
        }


def _map_dom_snapshot__layout_tree_snapshot__to_dict(data: 'dom_snapshot.LayoutTreeSnapshot', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'node_index': [
                item
                for item in data.node_index
            ],
            'styles': [
                item
                for item in data.styles
            ],
            'bounds': [
                item
                for item in data.bounds
            ],
            'text': [
                item
                for item in data.text
            ],
            'stacking_contexts': to_dict(
                data.stacking_contexts,
                casing_strategy
            ),
            'paint_orders': [
                item
                for item in data.paint_orders
            ],
            'offset_rects': [
                item
                for item in data.offset_rects
            ],
            'scroll_rects': [
                item
                for item in data.scroll_rects
            ],
            'client_rects': [
                item
                for item in data.client_rects
            ],
            'blended_background_colors': [
                item
                for item in data.blended_background_colors
            ],
            'text_color_opacities': [
                item
                for item in data.text_color_opacities
            ],
        }
    if casing_strategy == 'camel':
        return {
            'nodeIndex': [
                item
                for item in data.node_index
            ],
            'styles': [
                item
                for item in data.styles
            ],
            'bounds': [
                item
                for item in data.bounds
            ],
            'text': [
                item
                for item in data.text
            ],
            'stackingContexts': to_dict(
                data.stacking_contexts,
                casing_strategy
            ),
            'paintOrders': [
                item
                for item in data.paint_orders
            ],
            'offsetRects': [
                item
                for item in data.offset_rects
            ],
            'scrollRects': [
                item
                for item in data.scroll_rects
            ],
            'clientRects': [
                item
                for item in data.client_rects
            ],
            'blendedBackgroundColors': [
                item
                for item in data.blended_background_colors
            ],
            'textColorOpacities': [
                item
                for item in data.text_color_opacities
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'NodeIndex': [
                item
                for item in data.node_index
            ],
            'Styles': [
                item
                for item in data.styles
            ],
            'Bounds': [
                item
                for item in data.bounds
            ],
            'Text': [
                item
                for item in data.text
            ],
            'StackingContexts': to_dict(
                data.stacking_contexts,
                casing_strategy
            ),
            'PaintOrders': [
                item
                for item in data.paint_orders
            ],
            'OffsetRects': [
                item
                for item in data.offset_rects
            ],
            'ScrollRects': [
                item
                for item in data.scroll_rects
            ],
            'ClientRects': [
                item
                for item in data.client_rects
            ],
            'BlendedBackgroundColors': [
                item
                for item in data.blended_background_colors
            ],
            'TextColorOpacities': [
                item
                for item in data.text_color_opacities
            ],
        }


def _map_dom_snapshot__text_box_snapshot__to_dict(data: 'dom_snapshot.TextBoxSnapshot', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'layout_index': [
                item
                for item in data.layout_index
            ],
            'bounds': [
                item
                for item in data.bounds
            ],
            'start': [
                item
                for item in data.start
            ],
            'length': [
                item
                for item in data.length
            ],
        }
    if casing_strategy == 'camel':
        return {
            'layoutIndex': [
                item
                for item in data.layout_index
            ],
            'bounds': [
                item
                for item in data.bounds
            ],
            'start': [
                item
                for item in data.start
            ],
            'length': [
                item
                for item in data.length
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'LayoutIndex': [
                item
                for item in data.layout_index
            ],
            'Bounds': [
                item
                for item in data.bounds
            ],
            'Start': [
                item
                for item in data.start
            ],
            'Length': [
                item
                for item in data.length
            ],
        }


def _map_dom_storage__storage_id__to_dict(data: 'dom_storage.StorageId', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'security_origin': data.security_origin,
            'storage_key': data.storage_key,
            'is_local_storage': data.is_local_storage,
        }
    if casing_strategy == 'camel':
        return {
            'securityOrigin': data.security_origin,
            'storageKey': data.storage_key,
            'isLocalStorage': data.is_local_storage,
        }
    if casing_strategy == 'pascal':
        return {
            'SecurityOrigin': data.security_origin,
            'StorageKey': data.storage_key,
            'IsLocalStorage': data.is_local_storage,
        }


def _map_database__database__to_dict(data: 'database.Database', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'id': data.id,
            'domain': data.domain,
            'name': data.name,
            'version': data.version,
        }
    if casing_strategy == 'camel':
        return {
            'id': data.id,
            'domain': data.domain,
            'name': data.name,
            'version': data.version,
        }
    if casing_strategy == 'pascal':
        return {
            'Id': data.id,
            'Domain': data.domain,
            'Name': data.name,
            'Version': data.version,
        }


def _map_database__error__to_dict(data: 'database.Error', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'message': data.message,
            'code': data.code,
        }
    if casing_strategy == 'camel':
        return {
            'message': data.message,
            'code': data.code,
        }
    if casing_strategy == 'pascal':
        return {
            'Message': data.message,
            'Code': data.code,
        }


def _map_emulation__screen_orientation__to_dict(data: 'emulation.ScreenOrientation', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'angle': data.angle,
        }
    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'angle': data.angle,
        }
    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'Angle': data.angle,
        }


def _map_emulation__display_feature__to_dict(data: 'emulation.DisplayFeature', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'orientation': data.orientation,
            'offset': data.offset,
            'mask_length': data.mask_length,
        }
    if casing_strategy == 'camel':
        return {
            'orientation': data.orientation,
            'offset': data.offset,
            'maskLength': data.mask_length,
        }
    if casing_strategy == 'pascal':
        return {
            'Orientation': data.orientation,
            'Offset': data.offset,
            'MaskLength': data.mask_length,
        }


def _map_emulation__media_feature__to_dict(data: 'emulation.MediaFeature', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
        }


def _map_emulation__user_agent_brand_version__to_dict(data: 'emulation.UserAgentBrandVersion', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'brand': data.brand,
            'version': data.version,
        }
    if casing_strategy == 'camel':
        return {
            'brand': data.brand,
            'version': data.version,
        }
    if casing_strategy == 'pascal':
        return {
            'Brand': data.brand,
            'Version': data.version,
        }


def _map_emulation__user_agent_metadata__to_dict(data: 'emulation.UserAgentMetadata', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'brands': [
                to_dict(item, casing_strategy)
                for item in data.brands
            ],
            'full_version_list': [
                to_dict(item, casing_strategy)
                for item in data.full_version_list
            ],
            'full_version': data.full_version,
            'platform': data.platform,
            'platform_version': data.platform_version,
            'architecture': data.architecture,
            'model': data.model,
            'mobile': data.mobile,
            'bitness': data.bitness,
            'wow64': data.wow64,
        }
    if casing_strategy == 'camel':
        return {
            'brands': [
                to_dict(item, casing_strategy)
                for item in data.brands
            ],
            'fullVersionList': [
                to_dict(item, casing_strategy)
                for item in data.full_version_list
            ],
            'fullVersion': data.full_version,
            'platform': data.platform,
            'platformVersion': data.platform_version,
            'architecture': data.architecture,
            'model': data.model,
            'mobile': data.mobile,
            'bitness': data.bitness,
            'wow64': data.wow64,
        }
    if casing_strategy == 'pascal':
        return {
            'Brands': [
                to_dict(item, casing_strategy)
                for item in data.brands
            ],
            'FullVersionList': [
                to_dict(item, casing_strategy)
                for item in data.full_version_list
            ],
            'FullVersion': data.full_version,
            'Platform': data.platform,
            'PlatformVersion': data.platform_version,
            'Architecture': data.architecture,
            'Model': data.model,
            'Mobile': data.mobile,
            'Bitness': data.bitness,
            'Wow64': data.wow64,
        }


def _map_headless_experimental__screenshot_params__to_dict(data: 'headless_experimental.ScreenshotParams', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'format': data.format,
            'quality': data.quality,
            'optimize_for_speed': data.optimize_for_speed,
        }
    if casing_strategy == 'camel':
        return {
            'format': data.format,
            'quality': data.quality,
            'optimizeForSpeed': data.optimize_for_speed,
        }
    if casing_strategy == 'pascal':
        return {
            'Format': data.format,
            'Quality': data.quality,
            'OptimizeForSpeed': data.optimize_for_speed,
        }


def _map_indexed_db__database_with_object_stores__to_dict(data: 'indexed_db.DatabaseWithObjectStores', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'version': data.version,
            'object_stores': [
                to_dict(item, casing_strategy)
                for item in data.object_stores
            ],
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'version': data.version,
            'objectStores': [
                to_dict(item, casing_strategy)
                for item in data.object_stores
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Version': data.version,
            'ObjectStores': [
                to_dict(item, casing_strategy)
                for item in data.object_stores
            ],
        }


def _map_indexed_db__object_store__to_dict(data: 'indexed_db.ObjectStore', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'key_path': to_dict(
                data.key_path,
                casing_strategy
            ),
            'auto_increment': data.auto_increment,
            'indexes': [
                to_dict(item, casing_strategy)
                for item in data.indexes
            ],
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'keyPath': to_dict(
                data.key_path,
                casing_strategy
            ),
            'autoIncrement': data.auto_increment,
            'indexes': [
                to_dict(item, casing_strategy)
                for item in data.indexes
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'KeyPath': to_dict(
                data.key_path,
                casing_strategy
            ),
            'AutoIncrement': data.auto_increment,
            'Indexes': [
                to_dict(item, casing_strategy)
                for item in data.indexes
            ],
        }


def _map_indexed_db__object_store_index__to_dict(data: 'indexed_db.ObjectStoreIndex', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'key_path': to_dict(
                data.key_path,
                casing_strategy
            ),
            'unique': data.unique,
            'multi_entry': data.multi_entry,
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'keyPath': to_dict(
                data.key_path,
                casing_strategy
            ),
            'unique': data.unique,
            'multiEntry': data.multi_entry,
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'KeyPath': to_dict(
                data.key_path,
                casing_strategy
            ),
            'Unique': data.unique,
            'MultiEntry': data.multi_entry,
        }


def _map_indexed_db__key__to_dict(data: 'indexed_db.Key', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'number': data.number,
            'string': data.string,
            'date': data.date,
            'array': [
                to_dict(item, casing_strategy)
                for item in data.array
            ],
        }
    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'number': data.number,
            'string': data.string,
            'date': data.date,
            'array': [
                to_dict(item, casing_strategy)
                for item in data.array
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'Number': data.number,
            'String': data.string,
            'Date': data.date,
            'Array': [
                to_dict(item, casing_strategy)
                for item in data.array
            ],
        }


def _map_indexed_db__key_range__to_dict(data: 'indexed_db.KeyRange', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'lower': to_dict(
                data.lower,
                casing_strategy
            ),
            'upper': to_dict(
                data.upper,
                casing_strategy
            ),
            'lower_open': data.lower_open,
            'upper_open': data.upper_open,
        }
    if casing_strategy == 'camel':
        return {
            'lower': to_dict(
                data.lower,
                casing_strategy
            ),
            'upper': to_dict(
                data.upper,
                casing_strategy
            ),
            'lowerOpen': data.lower_open,
            'upperOpen': data.upper_open,
        }
    if casing_strategy == 'pascal':
        return {
            'Lower': to_dict(
                data.lower,
                casing_strategy
            ),
            'Upper': to_dict(
                data.upper,
                casing_strategy
            ),
            'LowerOpen': data.lower_open,
            'UpperOpen': data.upper_open,
        }


def _map_indexed_db__data_entry__to_dict(data: 'indexed_db.DataEntry', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'key': to_dict(
                data.key,
                casing_strategy
            ),
            'primary_key': to_dict(
                data.primary_key,
                casing_strategy
            ),
            'value': to_dict(
                data.value,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'key': to_dict(
                data.key,
                casing_strategy
            ),
            'primaryKey': to_dict(
                data.primary_key,
                casing_strategy
            ),
            'value': to_dict(
                data.value,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'Key': to_dict(
                data.key,
                casing_strategy
            ),
            'PrimaryKey': to_dict(
                data.primary_key,
                casing_strategy
            ),
            'Value': to_dict(
                data.value,
                casing_strategy
            ),
        }


def _map_indexed_db__key_path__to_dict(data: 'indexed_db.KeyPath', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'string': data.string,
            'array': [
                item
                for item in data.array
            ],
        }
    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'string': data.string,
            'array': [
                item
                for item in data.array
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'String': data.string,
            'Array': [
                item
                for item in data.array
            ],
        }


def _map_input__touch_point__to_dict(data: 'input_.TouchPoint', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'x': data.x,
            'y': data.y,
            'radius_x': data.radius_x,
            'radius_y': data.radius_y,
            'rotation_angle': data.rotation_angle,
            'force': data.force,
            'tangential_pressure': data.tangential_pressure,
            'tilt_x': data.tilt_x,
            'tilt_y': data.tilt_y,
            'twist': data.twist,
            'id': data.id,
        }
    if casing_strategy == 'camel':
        return {
            'x': data.x,
            'y': data.y,
            'radiusX': data.radius_x,
            'radiusY': data.radius_y,
            'rotationAngle': data.rotation_angle,
            'force': data.force,
            'tangentialPressure': data.tangential_pressure,
            'tiltX': data.tilt_x,
            'tiltY': data.tilt_y,
            'twist': data.twist,
            'id': data.id,
        }
    if casing_strategy == 'pascal':
        return {
            'X': data.x,
            'Y': data.y,
            'RadiusX': data.radius_x,
            'RadiusY': data.radius_y,
            'RotationAngle': data.rotation_angle,
            'Force': data.force,
            'TangentialPressure': data.tangential_pressure,
            'TiltX': data.tilt_x,
            'TiltY': data.tilt_y,
            'Twist': data.twist,
            'Id': data.id,
        }


def _map_input__drag_data_item__to_dict(data: 'input_.DragDataItem', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'mime_type': data.mime_type,
            'data': data.data,
            'title': data.title,
            'base_url': data.base_url,
        }
    if casing_strategy == 'camel':
        return {
            'mimeType': data.mime_type,
            'data': data.data,
            'title': data.title,
            'baseURL': data.base_url,
        }
    if casing_strategy == 'pascal':
        return {
            'MimeType': data.mime_type,
            'Data': data.data,
            'Title': data.title,
            'BaseURL': data.base_url,
        }


def _map_input__drag_data__to_dict(data: 'input_.DragData', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'items': [
                to_dict(item, casing_strategy)
                for item in data.items
            ],
            'files': [
                item
                for item in data.files
            ],
            'drag_operations_mask': data.drag_operations_mask,
        }
    if casing_strategy == 'camel':
        return {
            'items': [
                to_dict(item, casing_strategy)
                for item in data.items
            ],
            'files': [
                item
                for item in data.files
            ],
            'dragOperationsMask': data.drag_operations_mask,
        }
    if casing_strategy == 'pascal':
        return {
            'Items': [
                to_dict(item, casing_strategy)
                for item in data.items
            ],
            'Files': [
                item
                for item in data.files
            ],
            'DragOperationsMask': data.drag_operations_mask,
        }


def _map_layer_tree__scroll_rect__to_dict(data: 'layer_tree.ScrollRect', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'rect': to_dict(
                data.rect,
                casing_strategy
            ),
            'type': data.type,
        }
    if casing_strategy == 'camel':
        return {
            'rect': to_dict(
                data.rect,
                casing_strategy
            ),
            'type': data.type,
        }
    if casing_strategy == 'pascal':
        return {
            'Rect': to_dict(
                data.rect,
                casing_strategy
            ),
            'Type': data.type,
        }


def _map_layer_tree__sticky_position_constraint__to_dict(data: 'layer_tree.StickyPositionConstraint', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'sticky_box_rect': to_dict(
                data.sticky_box_rect,
                casing_strategy
            ),
            'containing_block_rect': to_dict(
                data.containing_block_rect,
                casing_strategy
            ),
            'nearest_layer_shifting_sticky_box': data.nearest_layer_shifting_sticky_box,
            'nearest_layer_shifting_containing_block': data.nearest_layer_shifting_containing_block,
        }
    if casing_strategy == 'camel':
        return {
            'stickyBoxRect': to_dict(
                data.sticky_box_rect,
                casing_strategy
            ),
            'containingBlockRect': to_dict(
                data.containing_block_rect,
                casing_strategy
            ),
            'nearestLayerShiftingStickyBox': data.nearest_layer_shifting_sticky_box,
            'nearestLayerShiftingContainingBlock': data.nearest_layer_shifting_containing_block,
        }
    if casing_strategy == 'pascal':
        return {
            'StickyBoxRect': to_dict(
                data.sticky_box_rect,
                casing_strategy
            ),
            'ContainingBlockRect': to_dict(
                data.containing_block_rect,
                casing_strategy
            ),
            'NearestLayerShiftingStickyBox': data.nearest_layer_shifting_sticky_box,
            'NearestLayerShiftingContainingBlock': data.nearest_layer_shifting_containing_block,
        }


def _map_layer_tree__picture_tile__to_dict(data: 'layer_tree.PictureTile', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'x': data.x,
            'y': data.y,
            'picture': data.picture,
        }
    if casing_strategy == 'camel':
        return {
            'x': data.x,
            'y': data.y,
            'picture': data.picture,
        }
    if casing_strategy == 'pascal':
        return {
            'X': data.x,
            'Y': data.y,
            'Picture': data.picture,
        }


def _map_layer_tree__layer__to_dict(data: 'layer_tree.Layer', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'layer_id': data.layer_id,
            'parent_layer_id': data.parent_layer_id,
            'backend_node_id': data.backend_node_id,
            'offset_x': data.offset_x,
            'offset_y': data.offset_y,
            'width': data.width,
            'height': data.height,
            'transform': [
                item
                for item in data.transform
            ],
            'anchor_x': data.anchor_x,
            'anchor_y': data.anchor_y,
            'anchor_z': data.anchor_z,
            'paint_count': data.paint_count,
            'draws_content': data.draws_content,
            'invisible': data.invisible,
            'scroll_rects': [
                to_dict(item, casing_strategy)
                for item in data.scroll_rects
            ],
            'sticky_position_constraint': to_dict(
                data.sticky_position_constraint,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'layerId': data.layer_id,
            'parentLayerId': data.parent_layer_id,
            'backendNodeId': data.backend_node_id,
            'offsetX': data.offset_x,
            'offsetY': data.offset_y,
            'width': data.width,
            'height': data.height,
            'transform': [
                item
                for item in data.transform
            ],
            'anchorX': data.anchor_x,
            'anchorY': data.anchor_y,
            'anchorZ': data.anchor_z,
            'paintCount': data.paint_count,
            'drawsContent': data.draws_content,
            'invisible': data.invisible,
            'scrollRects': [
                to_dict(item, casing_strategy)
                for item in data.scroll_rects
            ],
            'stickyPositionConstraint': to_dict(
                data.sticky_position_constraint,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'LayerId': data.layer_id,
            'ParentLayerId': data.parent_layer_id,
            'BackendNodeId': data.backend_node_id,
            'OffsetX': data.offset_x,
            'OffsetY': data.offset_y,
            'Width': data.width,
            'Height': data.height,
            'Transform': [
                item
                for item in data.transform
            ],
            'AnchorX': data.anchor_x,
            'AnchorY': data.anchor_y,
            'AnchorZ': data.anchor_z,
            'PaintCount': data.paint_count,
            'DrawsContent': data.draws_content,
            'Invisible': data.invisible,
            'ScrollRects': [
                to_dict(item, casing_strategy)
                for item in data.scroll_rects
            ],
            'StickyPositionConstraint': to_dict(
                data.sticky_position_constraint,
                casing_strategy
            ),
        }


def _map_log__log_entry__to_dict(data: 'log.LogEntry', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'source': data.source,
            'level': data.level,
            'text': data.text,
            'category': data.category,
            'timestamp': data.timestamp,
            'url': data.url,
            'line_number': data.line_number,
            'stack_trace': to_dict(
                data.stack_trace,
                casing_strategy
            ),
            'network_request_id': data.network_request_id,
            'worker_id': data.worker_id,
            'args': [
                to_dict(item, casing_strategy)
                for item in data.args
            ],
        }
    if casing_strategy == 'camel':
        return {
            'source': data.source,
            'level': data.level,
            'text': data.text,
            'category': data.category,
            'timestamp': data.timestamp,
            'url': data.url,
            'lineNumber': data.line_number,
            'stackTrace': to_dict(
                data.stack_trace,
                casing_strategy
            ),
            'networkRequestId': data.network_request_id,
            'workerId': data.worker_id,
            'args': [
                to_dict(item, casing_strategy)
                for item in data.args
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Source': data.source,
            'Level': data.level,
            'Text': data.text,
            'Category': data.category,
            'Timestamp': data.timestamp,
            'Url': data.url,
            'LineNumber': data.line_number,
            'StackTrace': to_dict(
                data.stack_trace,
                casing_strategy
            ),
            'NetworkRequestId': data.network_request_id,
            'WorkerId': data.worker_id,
            'Args': [
                to_dict(item, casing_strategy)
                for item in data.args
            ],
        }


def _map_log__violation_setting__to_dict(data: 'log.ViolationSetting', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'threshold': data.threshold,
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'threshold': data.threshold,
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Threshold': data.threshold,
        }


def _map_memory__sampling_profile_node__to_dict(data: 'memory.SamplingProfileNode', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'size': data.size,
            'total': data.total,
            'stack': [
                item
                for item in data.stack
            ],
        }
    if casing_strategy == 'camel':
        return {
            'size': data.size,
            'total': data.total,
            'stack': [
                item
                for item in data.stack
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Size': data.size,
            'Total': data.total,
            'Stack': [
                item
                for item in data.stack
            ],
        }


def _map_memory__sampling_profile__to_dict(data: 'memory.SamplingProfile', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'samples': [
                to_dict(item, casing_strategy)
                for item in data.samples
            ],
            'modules': [
                to_dict(item, casing_strategy)
                for item in data.modules
            ],
        }
    if casing_strategy == 'camel':
        return {
            'samples': [
                to_dict(item, casing_strategy)
                for item in data.samples
            ],
            'modules': [
                to_dict(item, casing_strategy)
                for item in data.modules
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Samples': [
                to_dict(item, casing_strategy)
                for item in data.samples
            ],
            'Modules': [
                to_dict(item, casing_strategy)
                for item in data.modules
            ],
        }


def _map_memory__module__to_dict(data: 'memory.Module', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'uuid': data.uuid,
            'base_address': data.base_address,
            'size': data.size,
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'uuid': data.uuid,
            'baseAddress': data.base_address,
            'size': data.size,
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Uuid': data.uuid,
            'BaseAddress': data.base_address,
            'Size': data.size,
        }


def _map_network__resource_timing__to_dict(data: 'network.ResourceTiming', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'request_time': data.request_time,
            'proxy_start': data.proxy_start,
            'proxy_end': data.proxy_end,
            'dns_start': data.dns_start,
            'dns_end': data.dns_end,
            'connect_start': data.connect_start,
            'connect_end': data.connect_end,
            'ssl_start': data.ssl_start,
            'ssl_end': data.ssl_end,
            'worker_start': data.worker_start,
            'worker_ready': data.worker_ready,
            'worker_fetch_start': data.worker_fetch_start,
            'worker_respond_with_settled': data.worker_respond_with_settled,
            'send_start': data.send_start,
            'send_end': data.send_end,
            'push_start': data.push_start,
            'push_end': data.push_end,
            'receive_headers_start': data.receive_headers_start,
            'receive_headers_end': data.receive_headers_end,
        }
    if casing_strategy == 'camel':
        return {
            'requestTime': data.request_time,
            'proxyStart': data.proxy_start,
            'proxyEnd': data.proxy_end,
            'dnsStart': data.dns_start,
            'dnsEnd': data.dns_end,
            'connectStart': data.connect_start,
            'connectEnd': data.connect_end,
            'sslStart': data.ssl_start,
            'sslEnd': data.ssl_end,
            'workerStart': data.worker_start,
            'workerReady': data.worker_ready,
            'workerFetchStart': data.worker_fetch_start,
            'workerRespondWithSettled': data.worker_respond_with_settled,
            'sendStart': data.send_start,
            'sendEnd': data.send_end,
            'pushStart': data.push_start,
            'pushEnd': data.push_end,
            'receiveHeadersStart': data.receive_headers_start,
            'receiveHeadersEnd': data.receive_headers_end,
        }
    if casing_strategy == 'pascal':
        return {
            'RequestTime': data.request_time,
            'ProxyStart': data.proxy_start,
            'ProxyEnd': data.proxy_end,
            'DnsStart': data.dns_start,
            'DnsEnd': data.dns_end,
            'ConnectStart': data.connect_start,
            'ConnectEnd': data.connect_end,
            'SslStart': data.ssl_start,
            'SslEnd': data.ssl_end,
            'WorkerStart': data.worker_start,
            'WorkerReady': data.worker_ready,
            'WorkerFetchStart': data.worker_fetch_start,
            'WorkerRespondWithSettled': data.worker_respond_with_settled,
            'SendStart': data.send_start,
            'SendEnd': data.send_end,
            'PushStart': data.push_start,
            'PushEnd': data.push_end,
            'ReceiveHeadersStart': data.receive_headers_start,
            'ReceiveHeadersEnd': data.receive_headers_end,
        }


def _map_network__post_data_entry__to_dict(data: 'network.PostDataEntry', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'bytes': data.bytes,
        }
    if casing_strategy == 'camel':
        return {
            'bytes': data.bytes,
        }
    if casing_strategy == 'pascal':
        return {
            'Bytes': data.bytes,
        }


def _map_network__request__to_dict(data: 'network.Request', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'url': data.url,
            'url_fragment': data.url_fragment,
            'method': data.method,
            'headers': data.headers,
            'post_data': data.post_data,
            'has_post_data': data.has_post_data,
            'post_data_entries': [
                to_dict(item, casing_strategy)
                for item in data.post_data_entries
            ],
            'mixed_content_type': data.mixed_content_type,
            'initial_priority': data.initial_priority,
            'referrer_policy': data.referrer_policy,
            'is_link_preload': data.is_link_preload,
            'trust_token_params': to_dict(
                data.trust_token_params,
                casing_strategy
            ),
            'is_same_site': data.is_same_site,
        }
    if casing_strategy == 'camel':
        return {
            'url': data.url,
            'urlFragment': data.url_fragment,
            'method': data.method,
            'headers': data.headers,
            'postData': data.post_data,
            'hasPostData': data.has_post_data,
            'postDataEntries': [
                to_dict(item, casing_strategy)
                for item in data.post_data_entries
            ],
            'mixedContentType': data.mixed_content_type,
            'initialPriority': data.initial_priority,
            'referrerPolicy': data.referrer_policy,
            'isLinkPreload': data.is_link_preload,
            'trustTokenParams': to_dict(
                data.trust_token_params,
                casing_strategy
            ),
            'isSameSite': data.is_same_site,
        }
    if casing_strategy == 'pascal':
        return {
            'Url': data.url,
            'UrlFragment': data.url_fragment,
            'Method': data.method,
            'Headers': data.headers,
            'PostData': data.post_data,
            'HasPostData': data.has_post_data,
            'PostDataEntries': [
                to_dict(item, casing_strategy)
                for item in data.post_data_entries
            ],
            'MixedContentType': data.mixed_content_type,
            'InitialPriority': data.initial_priority,
            'ReferrerPolicy': data.referrer_policy,
            'IsLinkPreload': data.is_link_preload,
            'TrustTokenParams': to_dict(
                data.trust_token_params,
                casing_strategy
            ),
            'IsSameSite': data.is_same_site,
        }


def _map_network__signed_certificate_timestamp__to_dict(data: 'network.SignedCertificateTimestamp', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'status': data.status,
            'origin': data.origin,
            'log_description': data.log_description,
            'log_id': data.log_id,
            'timestamp': data.timestamp,
            'hash_algorithm': data.hash_algorithm,
            'signature_algorithm': data.signature_algorithm,
            'signature_data': data.signature_data,
        }
    if casing_strategy == 'camel':
        return {
            'status': data.status,
            'origin': data.origin,
            'logDescription': data.log_description,
            'logId': data.log_id,
            'timestamp': data.timestamp,
            'hashAlgorithm': data.hash_algorithm,
            'signatureAlgorithm': data.signature_algorithm,
            'signatureData': data.signature_data,
        }
    if casing_strategy == 'pascal':
        return {
            'Status': data.status,
            'Origin': data.origin,
            'LogDescription': data.log_description,
            'LogId': data.log_id,
            'Timestamp': data.timestamp,
            'HashAlgorithm': data.hash_algorithm,
            'SignatureAlgorithm': data.signature_algorithm,
            'SignatureData': data.signature_data,
        }


def _map_network__security_details__to_dict(data: 'network.SecurityDetails', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'protocol': data.protocol,
            'key_exchange': data.key_exchange,
            'key_exchange_group': data.key_exchange_group,
            'cipher': data.cipher,
            'mac': data.mac,
            'certificate_id': data.certificate_id,
            'subject_name': data.subject_name,
            'san_list': [
                item
                for item in data.san_list
            ],
            'issuer': data.issuer,
            'valid_from': data.valid_from,
            'valid_to': data.valid_to,
            'signed_certificate_timestamp_list': [
                to_dict(item, casing_strategy)
                for item in data.signed_certificate_timestamp_list
            ],
            'certificate_transparency_compliance': data.certificate_transparency_compliance,
            'server_signature_algorithm': data.server_signature_algorithm,
            'encrypted_client_hello': data.encrypted_client_hello,
        }
    if casing_strategy == 'camel':
        return {
            'protocol': data.protocol,
            'keyExchange': data.key_exchange,
            'keyExchangeGroup': data.key_exchange_group,
            'cipher': data.cipher,
            'mac': data.mac,
            'certificateId': data.certificate_id,
            'subjectName': data.subject_name,
            'sanList': [
                item
                for item in data.san_list
            ],
            'issuer': data.issuer,
            'validFrom': data.valid_from,
            'validTo': data.valid_to,
            'signedCertificateTimestampList': [
                to_dict(item, casing_strategy)
                for item in data.signed_certificate_timestamp_list
            ],
            'certificateTransparencyCompliance': data.certificate_transparency_compliance,
            'serverSignatureAlgorithm': data.server_signature_algorithm,
            'encryptedClientHello': data.encrypted_client_hello,
        }
    if casing_strategy == 'pascal':
        return {
            'Protocol': data.protocol,
            'KeyExchange': data.key_exchange,
            'KeyExchangeGroup': data.key_exchange_group,
            'Cipher': data.cipher,
            'Mac': data.mac,
            'CertificateId': data.certificate_id,
            'SubjectName': data.subject_name,
            'SanList': [
                item
                for item in data.san_list
            ],
            'Issuer': data.issuer,
            'ValidFrom': data.valid_from,
            'ValidTo': data.valid_to,
            'SignedCertificateTimestampList': [
                to_dict(item, casing_strategy)
                for item in data.signed_certificate_timestamp_list
            ],
            'CertificateTransparencyCompliance': data.certificate_transparency_compliance,
            'ServerSignatureAlgorithm': data.server_signature_algorithm,
            'EncryptedClientHello': data.encrypted_client_hello,
        }


def _map_network__cors_error_status__to_dict(data: 'network.CorsErrorStatus', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'cors_error': data.cors_error,
            'failed_parameter': data.failed_parameter,
        }
    if casing_strategy == 'camel':
        return {
            'corsError': data.cors_error,
            'failedParameter': data.failed_parameter,
        }
    if casing_strategy == 'pascal':
        return {
            'CorsError': data.cors_error,
            'FailedParameter': data.failed_parameter,
        }


def _map_network__trust_token_params__to_dict(data: 'network.TrustTokenParams', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'operation': data.operation,
            'refresh_policy': data.refresh_policy,
            'issuers': [
                item
                for item in data.issuers
            ],
        }
    if casing_strategy == 'camel':
        return {
            'operation': data.operation,
            'refreshPolicy': data.refresh_policy,
            'issuers': [
                item
                for item in data.issuers
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Operation': data.operation,
            'RefreshPolicy': data.refresh_policy,
            'Issuers': [
                item
                for item in data.issuers
            ],
        }


def _map_network__response__to_dict(data: 'network.Response', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'url': data.url,
            'status': data.status,
            'status_text': data.status_text,
            'headers': data.headers,
            'headers_text': data.headers_text,
            'mime_type': data.mime_type,
            'request_headers': data.request_headers,
            'request_headers_text': data.request_headers_text,
            'connection_reused': data.connection_reused,
            'connection_id': data.connection_id,
            'remote_ip_address': data.remote_ip_address,
            'remote_port': data.remote_port,
            'from_disk_cache': data.from_disk_cache,
            'from_service_worker': data.from_service_worker,
            'from_prefetch_cache': data.from_prefetch_cache,
            'encoded_data_length': data.encoded_data_length,
            'timing': to_dict(
                data.timing,
                casing_strategy
            ),
            'service_worker_response_source': data.service_worker_response_source,
            'response_time': data.response_time,
            'cache_storage_cache_name': data.cache_storage_cache_name,
            'protocol': data.protocol,
            'alternate_protocol_usage': data.alternate_protocol_usage,
            'security_state': data.security_state,
            'security_details': to_dict(
                data.security_details,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'url': data.url,
            'status': data.status,
            'statusText': data.status_text,
            'headers': data.headers,
            'headersText': data.headers_text,
            'mimeType': data.mime_type,
            'requestHeaders': data.request_headers,
            'requestHeadersText': data.request_headers_text,
            'connectionReused': data.connection_reused,
            'connectionId': data.connection_id,
            'remoteIPAddress': data.remote_ip_address,
            'remotePort': data.remote_port,
            'fromDiskCache': data.from_disk_cache,
            'fromServiceWorker': data.from_service_worker,
            'fromPrefetchCache': data.from_prefetch_cache,
            'encodedDataLength': data.encoded_data_length,
            'timing': to_dict(
                data.timing,
                casing_strategy
            ),
            'serviceWorkerResponseSource': data.service_worker_response_source,
            'responseTime': data.response_time,
            'cacheStorageCacheName': data.cache_storage_cache_name,
            'protocol': data.protocol,
            'alternateProtocolUsage': data.alternate_protocol_usage,
            'securityState': data.security_state,
            'securityDetails': to_dict(
                data.security_details,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'Url': data.url,
            'Status': data.status,
            'StatusText': data.status_text,
            'Headers': data.headers,
            'HeadersText': data.headers_text,
            'MimeType': data.mime_type,
            'RequestHeaders': data.request_headers,
            'RequestHeadersText': data.request_headers_text,
            'ConnectionReused': data.connection_reused,
            'ConnectionId': data.connection_id,
            'RemoteIPAddress': data.remote_ip_address,
            'RemotePort': data.remote_port,
            'FromDiskCache': data.from_disk_cache,
            'FromServiceWorker': data.from_service_worker,
            'FromPrefetchCache': data.from_prefetch_cache,
            'EncodedDataLength': data.encoded_data_length,
            'Timing': to_dict(
                data.timing,
                casing_strategy
            ),
            'ServiceWorkerResponseSource': data.service_worker_response_source,
            'ResponseTime': data.response_time,
            'CacheStorageCacheName': data.cache_storage_cache_name,
            'Protocol': data.protocol,
            'AlternateProtocolUsage': data.alternate_protocol_usage,
            'SecurityState': data.security_state,
            'SecurityDetails': to_dict(
                data.security_details,
                casing_strategy
            ),
        }


def _map_network__web_socket_request__to_dict(data: 'network.WebSocketRequest', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'headers': data.headers,
        }
    if casing_strategy == 'camel':
        return {
            'headers': data.headers,
        }
    if casing_strategy == 'pascal':
        return {
            'Headers': data.headers,
        }


def _map_network__web_socket_response__to_dict(data: 'network.WebSocketResponse', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'status': data.status,
            'status_text': data.status_text,
            'headers': data.headers,
            'headers_text': data.headers_text,
            'request_headers': data.request_headers,
            'request_headers_text': data.request_headers_text,
        }
    if casing_strategy == 'camel':
        return {
            'status': data.status,
            'statusText': data.status_text,
            'headers': data.headers,
            'headersText': data.headers_text,
            'requestHeaders': data.request_headers,
            'requestHeadersText': data.request_headers_text,
        }
    if casing_strategy == 'pascal':
        return {
            'Status': data.status,
            'StatusText': data.status_text,
            'Headers': data.headers,
            'HeadersText': data.headers_text,
            'RequestHeaders': data.request_headers,
            'RequestHeadersText': data.request_headers_text,
        }


def _map_network__web_socket_frame__to_dict(data: 'network.WebSocketFrame', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'opcode': data.opcode,
            'mask': data.mask,
            'payload_data': data.payload_data,
        }
    if casing_strategy == 'camel':
        return {
            'opcode': data.opcode,
            'mask': data.mask,
            'payloadData': data.payload_data,
        }
    if casing_strategy == 'pascal':
        return {
            'Opcode': data.opcode,
            'Mask': data.mask,
            'PayloadData': data.payload_data,
        }


def _map_network__cached_resource__to_dict(data: 'network.CachedResource', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'url': data.url,
            'type': data.type,
            'response': to_dict(
                data.response,
                casing_strategy
            ),
            'body_size': data.body_size,
        }
    if casing_strategy == 'camel':
        return {
            'url': data.url,
            'type': data.type,
            'response': to_dict(
                data.response,
                casing_strategy
            ),
            'bodySize': data.body_size,
        }
    if casing_strategy == 'pascal':
        return {
            'Url': data.url,
            'Type': data.type,
            'Response': to_dict(
                data.response,
                casing_strategy
            ),
            'BodySize': data.body_size,
        }


def _map_network__initiator__to_dict(data: 'network.Initiator', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'stack': to_dict(
                data.stack,
                casing_strategy
            ),
            'url': data.url,
            'line_number': data.line_number,
            'column_number': data.column_number,
            'request_id': data.request_id,
        }
    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'stack': to_dict(
                data.stack,
                casing_strategy
            ),
            'url': data.url,
            'lineNumber': data.line_number,
            'columnNumber': data.column_number,
            'requestId': data.request_id,
        }
    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'Stack': to_dict(
                data.stack,
                casing_strategy
            ),
            'Url': data.url,
            'LineNumber': data.line_number,
            'ColumnNumber': data.column_number,
            'RequestId': data.request_id,
        }


def _map_network__cookie__to_dict(data: 'network.Cookie', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
            'domain': data.domain,
            'path': data.path,
            'expires': data.expires,
            'size': data.size,
            'http_only': data.http_only,
            'secure': data.secure,
            'session': data.session,
            'same_site': data.same_site,
            'priority': data.priority,
            'same_party': data.same_party,
            'source_scheme': data.source_scheme,
            'source_port': data.source_port,
            'partition_key': data.partition_key,
            'partition_key_opaque': data.partition_key_opaque,
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
            'domain': data.domain,
            'path': data.path,
            'expires': data.expires,
            'size': data.size,
            'httpOnly': data.http_only,
            'secure': data.secure,
            'session': data.session,
            'sameSite': data.same_site,
            'priority': data.priority,
            'sameParty': data.same_party,
            'sourceScheme': data.source_scheme,
            'sourcePort': data.source_port,
            'partitionKey': data.partition_key,
            'partitionKeyOpaque': data.partition_key_opaque,
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
            'Domain': data.domain,
            'Path': data.path,
            'Expires': data.expires,
            'Size': data.size,
            'HttpOnly': data.http_only,
            'Secure': data.secure,
            'Session': data.session,
            'SameSite': data.same_site,
            'Priority': data.priority,
            'SameParty': data.same_party,
            'SourceScheme': data.source_scheme,
            'SourcePort': data.source_port,
            'PartitionKey': data.partition_key,
            'PartitionKeyOpaque': data.partition_key_opaque,
        }


def _map_network__blocked_set_cookie_with_reason__to_dict(data: 'network.BlockedSetCookieWithReason', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'blocked_reasons': [
                item
                for item in data.blocked_reasons
            ],
            'cookie_line': data.cookie_line,
            'cookie': to_dict(
                data.cookie,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'blockedReasons': [
                item
                for item in data.blocked_reasons
            ],
            'cookieLine': data.cookie_line,
            'cookie': to_dict(
                data.cookie,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'BlockedReasons': [
                item
                for item in data.blocked_reasons
            ],
            'CookieLine': data.cookie_line,
            'Cookie': to_dict(
                data.cookie,
                casing_strategy
            ),
        }


def _map_network__blocked_cookie_with_reason__to_dict(data: 'network.BlockedCookieWithReason', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'blocked_reasons': [
                item
                for item in data.blocked_reasons
            ],
            'cookie': to_dict(
                data.cookie,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'blockedReasons': [
                item
                for item in data.blocked_reasons
            ],
            'cookie': to_dict(
                data.cookie,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'BlockedReasons': [
                item
                for item in data.blocked_reasons
            ],
            'Cookie': to_dict(
                data.cookie,
                casing_strategy
            ),
        }


def _map_network__cookie_param__to_dict(data: 'network.CookieParam', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
            'url': data.url,
            'domain': data.domain,
            'path': data.path,
            'secure': data.secure,
            'http_only': data.http_only,
            'same_site': data.same_site,
            'expires': data.expires,
            'priority': data.priority,
            'same_party': data.same_party,
            'source_scheme': data.source_scheme,
            'source_port': data.source_port,
            'partition_key': data.partition_key,
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
            'url': data.url,
            'domain': data.domain,
            'path': data.path,
            'secure': data.secure,
            'httpOnly': data.http_only,
            'sameSite': data.same_site,
            'expires': data.expires,
            'priority': data.priority,
            'sameParty': data.same_party,
            'sourceScheme': data.source_scheme,
            'sourcePort': data.source_port,
            'partitionKey': data.partition_key,
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
            'Url': data.url,
            'Domain': data.domain,
            'Path': data.path,
            'Secure': data.secure,
            'HttpOnly': data.http_only,
            'SameSite': data.same_site,
            'Expires': data.expires,
            'Priority': data.priority,
            'SameParty': data.same_party,
            'SourceScheme': data.source_scheme,
            'SourcePort': data.source_port,
            'PartitionKey': data.partition_key,
        }


def _map_network__auth_challenge__to_dict(data: 'network.AuthChallenge', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'source': data.source,
            'origin': data.origin,
            'scheme': data.scheme,
            'realm': data.realm,
        }
    if casing_strategy == 'camel':
        return {
            'source': data.source,
            'origin': data.origin,
            'scheme': data.scheme,
            'realm': data.realm,
        }
    if casing_strategy == 'pascal':
        return {
            'Source': data.source,
            'Origin': data.origin,
            'Scheme': data.scheme,
            'Realm': data.realm,
        }


def _map_network__auth_challenge_response__to_dict(data: 'network.AuthChallengeResponse', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'response': data.response,
            'username': data.username,
            'password': data.password,
        }
    if casing_strategy == 'camel':
        return {
            'response': data.response,
            'username': data.username,
            'password': data.password,
        }
    if casing_strategy == 'pascal':
        return {
            'Response': data.response,
            'Username': data.username,
            'Password': data.password,
        }


def _map_network__request_pattern__to_dict(data: 'network.RequestPattern', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'url_pattern': data.url_pattern,
            'resource_type': data.resource_type,
            'interception_stage': data.interception_stage,
        }
    if casing_strategy == 'camel':
        return {
            'urlPattern': data.url_pattern,
            'resourceType': data.resource_type,
            'interceptionStage': data.interception_stage,
        }
    if casing_strategy == 'pascal':
        return {
            'UrlPattern': data.url_pattern,
            'ResourceType': data.resource_type,
            'InterceptionStage': data.interception_stage,
        }


def _map_network__signed_exchange_signature__to_dict(data: 'network.SignedExchangeSignature', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'label': data.label,
            'signature': data.signature,
            'integrity': data.integrity,
            'cert_url': data.cert_url,
            'cert_sha256': data.cert_sha256,
            'validity_url': data.validity_url,
            'date': data.date,
            'expires': data.expires,
            'certificates': [
                item
                for item in data.certificates
            ],
        }
    if casing_strategy == 'camel':
        return {
            'label': data.label,
            'signature': data.signature,
            'integrity': data.integrity,
            'certUrl': data.cert_url,
            'certSha256': data.cert_sha256,
            'validityUrl': data.validity_url,
            'date': data.date,
            'expires': data.expires,
            'certificates': [
                item
                for item in data.certificates
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Label': data.label,
            'Signature': data.signature,
            'Integrity': data.integrity,
            'CertUrl': data.cert_url,
            'CertSha256': data.cert_sha256,
            'ValidityUrl': data.validity_url,
            'Date': data.date,
            'Expires': data.expires,
            'Certificates': [
                item
                for item in data.certificates
            ],
        }


def _map_network__signed_exchange_header__to_dict(data: 'network.SignedExchangeHeader', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'request_url': data.request_url,
            'response_code': data.response_code,
            'response_headers': data.response_headers,
            'signatures': [
                to_dict(item, casing_strategy)
                for item in data.signatures
            ],
            'header_integrity': data.header_integrity,
        }
    if casing_strategy == 'camel':
        return {
            'requestUrl': data.request_url,
            'responseCode': data.response_code,
            'responseHeaders': data.response_headers,
            'signatures': [
                to_dict(item, casing_strategy)
                for item in data.signatures
            ],
            'headerIntegrity': data.header_integrity,
        }
    if casing_strategy == 'pascal':
        return {
            'RequestUrl': data.request_url,
            'ResponseCode': data.response_code,
            'ResponseHeaders': data.response_headers,
            'Signatures': [
                to_dict(item, casing_strategy)
                for item in data.signatures
            ],
            'HeaderIntegrity': data.header_integrity,
        }


def _map_network__signed_exchange_error__to_dict(data: 'network.SignedExchangeError', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'message': data.message,
            'signature_index': data.signature_index,
            'error_field': data.error_field,
        }
    if casing_strategy == 'camel':
        return {
            'message': data.message,
            'signatureIndex': data.signature_index,
            'errorField': data.error_field,
        }
    if casing_strategy == 'pascal':
        return {
            'Message': data.message,
            'SignatureIndex': data.signature_index,
            'ErrorField': data.error_field,
        }


def _map_network__signed_exchange_info__to_dict(data: 'network.SignedExchangeInfo', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'outer_response': to_dict(
                data.outer_response,
                casing_strategy
            ),
            'header': to_dict(
                data.header,
                casing_strategy
            ),
            'security_details': to_dict(
                data.security_details,
                casing_strategy
            ),
            'errors': [
                to_dict(item, casing_strategy)
                for item in data.errors
            ],
        }
    if casing_strategy == 'camel':
        return {
            'outerResponse': to_dict(
                data.outer_response,
                casing_strategy
            ),
            'header': to_dict(
                data.header,
                casing_strategy
            ),
            'securityDetails': to_dict(
                data.security_details,
                casing_strategy
            ),
            'errors': [
                to_dict(item, casing_strategy)
                for item in data.errors
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'OuterResponse': to_dict(
                data.outer_response,
                casing_strategy
            ),
            'Header': to_dict(
                data.header,
                casing_strategy
            ),
            'SecurityDetails': to_dict(
                data.security_details,
                casing_strategy
            ),
            'Errors': [
                to_dict(item, casing_strategy)
                for item in data.errors
            ],
        }


def _map_network__connect_timing__to_dict(data: 'network.ConnectTiming', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'request_time': data.request_time,
        }
    if casing_strategy == 'camel':
        return {
            'requestTime': data.request_time,
        }
    if casing_strategy == 'pascal':
        return {
            'RequestTime': data.request_time,
        }


def _map_network__client_security_state__to_dict(data: 'network.ClientSecurityState', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'initiator_is_secure_context': data.initiator_is_secure_context,
            'initiator_ip_address_space': data.initiator_ip_address_space,
            'private_network_request_policy': data.private_network_request_policy,
        }
    if casing_strategy == 'camel':
        return {
            'initiatorIsSecureContext': data.initiator_is_secure_context,
            'initiatorIPAddressSpace': data.initiator_ip_address_space,
            'privateNetworkRequestPolicy': data.private_network_request_policy,
        }
    if casing_strategy == 'pascal':
        return {
            'InitiatorIsSecureContext': data.initiator_is_secure_context,
            'InitiatorIPAddressSpace': data.initiator_ip_address_space,
            'PrivateNetworkRequestPolicy': data.private_network_request_policy,
        }


def _map_network__cross_origin_opener_policy_status__to_dict(data: 'network.CrossOriginOpenerPolicyStatus', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'value': data.value,
            'report_only_value': data.report_only_value,
            'reporting_endpoint': data.reporting_endpoint,
            'report_only_reporting_endpoint': data.report_only_reporting_endpoint,
        }
    if casing_strategy == 'camel':
        return {
            'value': data.value,
            'reportOnlyValue': data.report_only_value,
            'reportingEndpoint': data.reporting_endpoint,
            'reportOnlyReportingEndpoint': data.report_only_reporting_endpoint,
        }
    if casing_strategy == 'pascal':
        return {
            'Value': data.value,
            'ReportOnlyValue': data.report_only_value,
            'ReportingEndpoint': data.reporting_endpoint,
            'ReportOnlyReportingEndpoint': data.report_only_reporting_endpoint,
        }


def _map_network__cross_origin_embedder_policy_status__to_dict(data: 'network.CrossOriginEmbedderPolicyStatus', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'value': data.value,
            'report_only_value': data.report_only_value,
            'reporting_endpoint': data.reporting_endpoint,
            'report_only_reporting_endpoint': data.report_only_reporting_endpoint,
        }
    if casing_strategy == 'camel':
        return {
            'value': data.value,
            'reportOnlyValue': data.report_only_value,
            'reportingEndpoint': data.reporting_endpoint,
            'reportOnlyReportingEndpoint': data.report_only_reporting_endpoint,
        }
    if casing_strategy == 'pascal':
        return {
            'Value': data.value,
            'ReportOnlyValue': data.report_only_value,
            'ReportingEndpoint': data.reporting_endpoint,
            'ReportOnlyReportingEndpoint': data.report_only_reporting_endpoint,
        }


def _map_network__content_security_policy_status__to_dict(data: 'network.ContentSecurityPolicyStatus', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'effective_directives': data.effective_directives,
            'is_enforced': data.is_enforced,
            'source': data.source,
        }
    if casing_strategy == 'camel':
        return {
            'effectiveDirectives': data.effective_directives,
            'isEnforced': data.is_enforced,
            'source': data.source,
        }
    if casing_strategy == 'pascal':
        return {
            'EffectiveDirectives': data.effective_directives,
            'IsEnforced': data.is_enforced,
            'Source': data.source,
        }


def _map_network__security_isolation_status__to_dict(data: 'network.SecurityIsolationStatus', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'coop': to_dict(
                data.coop,
                casing_strategy
            ),
            'coep': to_dict(
                data.coep,
                casing_strategy
            ),
            'csp': [
                to_dict(item, casing_strategy)
                for item in data.csp
            ],
        }
    if casing_strategy == 'camel':
        return {
            'coop': to_dict(
                data.coop,
                casing_strategy
            ),
            'coep': to_dict(
                data.coep,
                casing_strategy
            ),
            'csp': [
                to_dict(item, casing_strategy)
                for item in data.csp
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Coop': to_dict(
                data.coop,
                casing_strategy
            ),
            'Coep': to_dict(
                data.coep,
                casing_strategy
            ),
            'Csp': [
                to_dict(item, casing_strategy)
                for item in data.csp
            ],
        }


def _map_network__reporting_api_report__to_dict(data: 'network.ReportingApiReport', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'id': data.id,
            'initiator_url': data.initiator_url,
            'destination': data.destination,
            'type': data.type,
            'timestamp': data.timestamp,
            'depth': data.depth,
            'completed_attempts': data.completed_attempts,
            'body': data.body,
            'status': data.status,
        }
    if casing_strategy == 'camel':
        return {
            'id': data.id,
            'initiatorUrl': data.initiator_url,
            'destination': data.destination,
            'type': data.type,
            'timestamp': data.timestamp,
            'depth': data.depth,
            'completedAttempts': data.completed_attempts,
            'body': data.body,
            'status': data.status,
        }
    if casing_strategy == 'pascal':
        return {
            'Id': data.id,
            'InitiatorUrl': data.initiator_url,
            'Destination': data.destination,
            'Type': data.type,
            'Timestamp': data.timestamp,
            'Depth': data.depth,
            'CompletedAttempts': data.completed_attempts,
            'Body': data.body,
            'Status': data.status,
        }


def _map_network__reporting_api_endpoint__to_dict(data: 'network.ReportingApiEndpoint', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'url': data.url,
            'group_name': data.group_name,
        }
    if casing_strategy == 'camel':
        return {
            'url': data.url,
            'groupName': data.group_name,
        }
    if casing_strategy == 'pascal':
        return {
            'Url': data.url,
            'GroupName': data.group_name,
        }


def _map_network__load_network_resource_page_result__to_dict(data: 'network.LoadNetworkResourcePageResult', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'success': data.success,
            'net_error': data.net_error,
            'net_error_name': data.net_error_name,
            'http_status_code': data.http_status_code,
            'stream': data.stream,
            'headers': data.headers,
        }
    if casing_strategy == 'camel':
        return {
            'success': data.success,
            'netError': data.net_error,
            'netErrorName': data.net_error_name,
            'httpStatusCode': data.http_status_code,
            'stream': data.stream,
            'headers': data.headers,
        }
    if casing_strategy == 'pascal':
        return {
            'Success': data.success,
            'NetError': data.net_error,
            'NetErrorName': data.net_error_name,
            'HttpStatusCode': data.http_status_code,
            'Stream': data.stream,
            'Headers': data.headers,
        }


def _map_network__load_network_resource_options__to_dict(data: 'network.LoadNetworkResourceOptions', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'disable_cache': data.disable_cache,
            'include_credentials': data.include_credentials,
        }
    if casing_strategy == 'camel':
        return {
            'disableCache': data.disable_cache,
            'includeCredentials': data.include_credentials,
        }
    if casing_strategy == 'pascal':
        return {
            'DisableCache': data.disable_cache,
            'IncludeCredentials': data.include_credentials,
        }


def _map_overlay__source_order_config__to_dict(data: 'overlay.SourceOrderConfig', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'parent_outline_color': to_dict(
                data.parent_outline_color,
                casing_strategy
            ),
            'child_outline_color': to_dict(
                data.child_outline_color,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'parentOutlineColor': to_dict(
                data.parent_outline_color,
                casing_strategy
            ),
            'childOutlineColor': to_dict(
                data.child_outline_color,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'ParentOutlineColor': to_dict(
                data.parent_outline_color,
                casing_strategy
            ),
            'ChildOutlineColor': to_dict(
                data.child_outline_color,
                casing_strategy
            ),
        }


def _map_overlay__grid_highlight_config__to_dict(data: 'overlay.GridHighlightConfig', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'show_grid_extension_lines': data.show_grid_extension_lines,
            'show_positive_line_numbers': data.show_positive_line_numbers,
            'show_negative_line_numbers': data.show_negative_line_numbers,
            'show_area_names': data.show_area_names,
            'show_line_names': data.show_line_names,
            'show_track_sizes': data.show_track_sizes,
            'grid_border_color': to_dict(
                data.grid_border_color,
                casing_strategy
            ),
            'cell_border_color': to_dict(
                data.cell_border_color,
                casing_strategy
            ),
            'row_line_color': to_dict(
                data.row_line_color,
                casing_strategy
            ),
            'column_line_color': to_dict(
                data.column_line_color,
                casing_strategy
            ),
            'grid_border_dash': data.grid_border_dash,
            'cell_border_dash': data.cell_border_dash,
            'row_line_dash': data.row_line_dash,
            'column_line_dash': data.column_line_dash,
            'row_gap_color': to_dict(
                data.row_gap_color,
                casing_strategy
            ),
            'row_hatch_color': to_dict(
                data.row_hatch_color,
                casing_strategy
            ),
            'column_gap_color': to_dict(
                data.column_gap_color,
                casing_strategy
            ),
            'column_hatch_color': to_dict(
                data.column_hatch_color,
                casing_strategy
            ),
            'area_border_color': to_dict(
                data.area_border_color,
                casing_strategy
            ),
            'grid_background_color': to_dict(
                data.grid_background_color,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'showGridExtensionLines': data.show_grid_extension_lines,
            'showPositiveLineNumbers': data.show_positive_line_numbers,
            'showNegativeLineNumbers': data.show_negative_line_numbers,
            'showAreaNames': data.show_area_names,
            'showLineNames': data.show_line_names,
            'showTrackSizes': data.show_track_sizes,
            'gridBorderColor': to_dict(
                data.grid_border_color,
                casing_strategy
            ),
            'cellBorderColor': to_dict(
                data.cell_border_color,
                casing_strategy
            ),
            'rowLineColor': to_dict(
                data.row_line_color,
                casing_strategy
            ),
            'columnLineColor': to_dict(
                data.column_line_color,
                casing_strategy
            ),
            'gridBorderDash': data.grid_border_dash,
            'cellBorderDash': data.cell_border_dash,
            'rowLineDash': data.row_line_dash,
            'columnLineDash': data.column_line_dash,
            'rowGapColor': to_dict(
                data.row_gap_color,
                casing_strategy
            ),
            'rowHatchColor': to_dict(
                data.row_hatch_color,
                casing_strategy
            ),
            'columnGapColor': to_dict(
                data.column_gap_color,
                casing_strategy
            ),
            'columnHatchColor': to_dict(
                data.column_hatch_color,
                casing_strategy
            ),
            'areaBorderColor': to_dict(
                data.area_border_color,
                casing_strategy
            ),
            'gridBackgroundColor': to_dict(
                data.grid_background_color,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'ShowGridExtensionLines': data.show_grid_extension_lines,
            'ShowPositiveLineNumbers': data.show_positive_line_numbers,
            'ShowNegativeLineNumbers': data.show_negative_line_numbers,
            'ShowAreaNames': data.show_area_names,
            'ShowLineNames': data.show_line_names,
            'ShowTrackSizes': data.show_track_sizes,
            'GridBorderColor': to_dict(
                data.grid_border_color,
                casing_strategy
            ),
            'CellBorderColor': to_dict(
                data.cell_border_color,
                casing_strategy
            ),
            'RowLineColor': to_dict(
                data.row_line_color,
                casing_strategy
            ),
            'ColumnLineColor': to_dict(
                data.column_line_color,
                casing_strategy
            ),
            'GridBorderDash': data.grid_border_dash,
            'CellBorderDash': data.cell_border_dash,
            'RowLineDash': data.row_line_dash,
            'ColumnLineDash': data.column_line_dash,
            'RowGapColor': to_dict(
                data.row_gap_color,
                casing_strategy
            ),
            'RowHatchColor': to_dict(
                data.row_hatch_color,
                casing_strategy
            ),
            'ColumnGapColor': to_dict(
                data.column_gap_color,
                casing_strategy
            ),
            'ColumnHatchColor': to_dict(
                data.column_hatch_color,
                casing_strategy
            ),
            'AreaBorderColor': to_dict(
                data.area_border_color,
                casing_strategy
            ),
            'GridBackgroundColor': to_dict(
                data.grid_background_color,
                casing_strategy
            ),
        }


def _map_overlay__flex_container_highlight_config__to_dict(data: 'overlay.FlexContainerHighlightConfig', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'container_border': to_dict(
                data.container_border,
                casing_strategy
            ),
            'line_separator': to_dict(
                data.line_separator,
                casing_strategy
            ),
            'item_separator': to_dict(
                data.item_separator,
                casing_strategy
            ),
            'main_distributed_space': to_dict(
                data.main_distributed_space,
                casing_strategy
            ),
            'cross_distributed_space': to_dict(
                data.cross_distributed_space,
                casing_strategy
            ),
            'row_gap_space': to_dict(
                data.row_gap_space,
                casing_strategy
            ),
            'column_gap_space': to_dict(
                data.column_gap_space,
                casing_strategy
            ),
            'cross_alignment': to_dict(
                data.cross_alignment,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'containerBorder': to_dict(
                data.container_border,
                casing_strategy
            ),
            'lineSeparator': to_dict(
                data.line_separator,
                casing_strategy
            ),
            'itemSeparator': to_dict(
                data.item_separator,
                casing_strategy
            ),
            'mainDistributedSpace': to_dict(
                data.main_distributed_space,
                casing_strategy
            ),
            'crossDistributedSpace': to_dict(
                data.cross_distributed_space,
                casing_strategy
            ),
            'rowGapSpace': to_dict(
                data.row_gap_space,
                casing_strategy
            ),
            'columnGapSpace': to_dict(
                data.column_gap_space,
                casing_strategy
            ),
            'crossAlignment': to_dict(
                data.cross_alignment,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'ContainerBorder': to_dict(
                data.container_border,
                casing_strategy
            ),
            'LineSeparator': to_dict(
                data.line_separator,
                casing_strategy
            ),
            'ItemSeparator': to_dict(
                data.item_separator,
                casing_strategy
            ),
            'MainDistributedSpace': to_dict(
                data.main_distributed_space,
                casing_strategy
            ),
            'CrossDistributedSpace': to_dict(
                data.cross_distributed_space,
                casing_strategy
            ),
            'RowGapSpace': to_dict(
                data.row_gap_space,
                casing_strategy
            ),
            'ColumnGapSpace': to_dict(
                data.column_gap_space,
                casing_strategy
            ),
            'CrossAlignment': to_dict(
                data.cross_alignment,
                casing_strategy
            ),
        }


def _map_overlay__flex_item_highlight_config__to_dict(data: 'overlay.FlexItemHighlightConfig', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'base_size_box': to_dict(
                data.base_size_box,
                casing_strategy
            ),
            'base_size_border': to_dict(
                data.base_size_border,
                casing_strategy
            ),
            'flexibility_arrow': to_dict(
                data.flexibility_arrow,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'baseSizeBox': to_dict(
                data.base_size_box,
                casing_strategy
            ),
            'baseSizeBorder': to_dict(
                data.base_size_border,
                casing_strategy
            ),
            'flexibilityArrow': to_dict(
                data.flexibility_arrow,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'BaseSizeBox': to_dict(
                data.base_size_box,
                casing_strategy
            ),
            'BaseSizeBorder': to_dict(
                data.base_size_border,
                casing_strategy
            ),
            'FlexibilityArrow': to_dict(
                data.flexibility_arrow,
                casing_strategy
            ),
        }


def _map_overlay__line_style__to_dict(data: 'overlay.LineStyle', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'color': to_dict(
                data.color,
                casing_strategy
            ),
            'pattern': data.pattern,
        }
    if casing_strategy == 'camel':
        return {
            'color': to_dict(
                data.color,
                casing_strategy
            ),
            'pattern': data.pattern,
        }
    if casing_strategy == 'pascal':
        return {
            'Color': to_dict(
                data.color,
                casing_strategy
            ),
            'Pattern': data.pattern,
        }


def _map_overlay__box_style__to_dict(data: 'overlay.BoxStyle', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'fill_color': to_dict(
                data.fill_color,
                casing_strategy
            ),
            'hatch_color': to_dict(
                data.hatch_color,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'fillColor': to_dict(
                data.fill_color,
                casing_strategy
            ),
            'hatchColor': to_dict(
                data.hatch_color,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'FillColor': to_dict(
                data.fill_color,
                casing_strategy
            ),
            'HatchColor': to_dict(
                data.hatch_color,
                casing_strategy
            ),
        }


def _map_overlay__highlight_config__to_dict(data: 'overlay.HighlightConfig', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'show_info': data.show_info,
            'show_styles': data.show_styles,
            'show_rulers': data.show_rulers,
            'show_accessibility_info': data.show_accessibility_info,
            'show_extension_lines': data.show_extension_lines,
            'content_color': to_dict(
                data.content_color,
                casing_strategy
            ),
            'padding_color': to_dict(
                data.padding_color,
                casing_strategy
            ),
            'border_color': to_dict(
                data.border_color,
                casing_strategy
            ),
            'margin_color': to_dict(
                data.margin_color,
                casing_strategy
            ),
            'event_target_color': to_dict(
                data.event_target_color,
                casing_strategy
            ),
            'shape_color': to_dict(
                data.shape_color,
                casing_strategy
            ),
            'shape_margin_color': to_dict(
                data.shape_margin_color,
                casing_strategy
            ),
            'css_grid_color': to_dict(
                data.css_grid_color,
                casing_strategy
            ),
            'color_format': data.color_format,
            'grid_highlight_config': to_dict(
                data.grid_highlight_config,
                casing_strategy
            ),
            'flex_container_highlight_config': to_dict(
                data.flex_container_highlight_config,
                casing_strategy
            ),
            'flex_item_highlight_config': to_dict(
                data.flex_item_highlight_config,
                casing_strategy
            ),
            'contrast_algorithm': data.contrast_algorithm,
            'container_query_container_highlight_config': to_dict(
                data.container_query_container_highlight_config,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'showInfo': data.show_info,
            'showStyles': data.show_styles,
            'showRulers': data.show_rulers,
            'showAccessibilityInfo': data.show_accessibility_info,
            'showExtensionLines': data.show_extension_lines,
            'contentColor': to_dict(
                data.content_color,
                casing_strategy
            ),
            'paddingColor': to_dict(
                data.padding_color,
                casing_strategy
            ),
            'borderColor': to_dict(
                data.border_color,
                casing_strategy
            ),
            'marginColor': to_dict(
                data.margin_color,
                casing_strategy
            ),
            'eventTargetColor': to_dict(
                data.event_target_color,
                casing_strategy
            ),
            'shapeColor': to_dict(
                data.shape_color,
                casing_strategy
            ),
            'shapeMarginColor': to_dict(
                data.shape_margin_color,
                casing_strategy
            ),
            'cssGridColor': to_dict(
                data.css_grid_color,
                casing_strategy
            ),
            'colorFormat': data.color_format,
            'gridHighlightConfig': to_dict(
                data.grid_highlight_config,
                casing_strategy
            ),
            'flexContainerHighlightConfig': to_dict(
                data.flex_container_highlight_config,
                casing_strategy
            ),
            'flexItemHighlightConfig': to_dict(
                data.flex_item_highlight_config,
                casing_strategy
            ),
            'contrastAlgorithm': data.contrast_algorithm,
            'containerQueryContainerHighlightConfig': to_dict(
                data.container_query_container_highlight_config,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'ShowInfo': data.show_info,
            'ShowStyles': data.show_styles,
            'ShowRulers': data.show_rulers,
            'ShowAccessibilityInfo': data.show_accessibility_info,
            'ShowExtensionLines': data.show_extension_lines,
            'ContentColor': to_dict(
                data.content_color,
                casing_strategy
            ),
            'PaddingColor': to_dict(
                data.padding_color,
                casing_strategy
            ),
            'BorderColor': to_dict(
                data.border_color,
                casing_strategy
            ),
            'MarginColor': to_dict(
                data.margin_color,
                casing_strategy
            ),
            'EventTargetColor': to_dict(
                data.event_target_color,
                casing_strategy
            ),
            'ShapeColor': to_dict(
                data.shape_color,
                casing_strategy
            ),
            'ShapeMarginColor': to_dict(
                data.shape_margin_color,
                casing_strategy
            ),
            'CssGridColor': to_dict(
                data.css_grid_color,
                casing_strategy
            ),
            'ColorFormat': data.color_format,
            'GridHighlightConfig': to_dict(
                data.grid_highlight_config,
                casing_strategy
            ),
            'FlexContainerHighlightConfig': to_dict(
                data.flex_container_highlight_config,
                casing_strategy
            ),
            'FlexItemHighlightConfig': to_dict(
                data.flex_item_highlight_config,
                casing_strategy
            ),
            'ContrastAlgorithm': data.contrast_algorithm,
            'ContainerQueryContainerHighlightConfig': to_dict(
                data.container_query_container_highlight_config,
                casing_strategy
            ),
        }


def _map_overlay__grid_node_highlight_config__to_dict(data: 'overlay.GridNodeHighlightConfig', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'grid_highlight_config': to_dict(
                data.grid_highlight_config,
                casing_strategy
            ),
            'node_id': data.node_id,
        }
    if casing_strategy == 'camel':
        return {
            'gridHighlightConfig': to_dict(
                data.grid_highlight_config,
                casing_strategy
            ),
            'nodeId': data.node_id,
        }
    if casing_strategy == 'pascal':
        return {
            'GridHighlightConfig': to_dict(
                data.grid_highlight_config,
                casing_strategy
            ),
            'NodeId': data.node_id,
        }


def _map_overlay__flex_node_highlight_config__to_dict(data: 'overlay.FlexNodeHighlightConfig', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'flex_container_highlight_config': to_dict(
                data.flex_container_highlight_config,
                casing_strategy
            ),
            'node_id': data.node_id,
        }
    if casing_strategy == 'camel':
        return {
            'flexContainerHighlightConfig': to_dict(
                data.flex_container_highlight_config,
                casing_strategy
            ),
            'nodeId': data.node_id,
        }
    if casing_strategy == 'pascal':
        return {
            'FlexContainerHighlightConfig': to_dict(
                data.flex_container_highlight_config,
                casing_strategy
            ),
            'NodeId': data.node_id,
        }


def _map_overlay__scroll_snap_container_highlight_config__to_dict(data: 'overlay.ScrollSnapContainerHighlightConfig', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'snapport_border': to_dict(
                data.snapport_border,
                casing_strategy
            ),
            'snap_area_border': to_dict(
                data.snap_area_border,
                casing_strategy
            ),
            'scroll_margin_color': to_dict(
                data.scroll_margin_color,
                casing_strategy
            ),
            'scroll_padding_color': to_dict(
                data.scroll_padding_color,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'snapportBorder': to_dict(
                data.snapport_border,
                casing_strategy
            ),
            'snapAreaBorder': to_dict(
                data.snap_area_border,
                casing_strategy
            ),
            'scrollMarginColor': to_dict(
                data.scroll_margin_color,
                casing_strategy
            ),
            'scrollPaddingColor': to_dict(
                data.scroll_padding_color,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'SnapportBorder': to_dict(
                data.snapport_border,
                casing_strategy
            ),
            'SnapAreaBorder': to_dict(
                data.snap_area_border,
                casing_strategy
            ),
            'ScrollMarginColor': to_dict(
                data.scroll_margin_color,
                casing_strategy
            ),
            'ScrollPaddingColor': to_dict(
                data.scroll_padding_color,
                casing_strategy
            ),
        }


def _map_overlay__scroll_snap_highlight_config__to_dict(data: 'overlay.ScrollSnapHighlightConfig', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'scroll_snap_container_highlight_config': to_dict(
                data.scroll_snap_container_highlight_config,
                casing_strategy
            ),
            'node_id': data.node_id,
        }
    if casing_strategy == 'camel':
        return {
            'scrollSnapContainerHighlightConfig': to_dict(
                data.scroll_snap_container_highlight_config,
                casing_strategy
            ),
            'nodeId': data.node_id,
        }
    if casing_strategy == 'pascal':
        return {
            'ScrollSnapContainerHighlightConfig': to_dict(
                data.scroll_snap_container_highlight_config,
                casing_strategy
            ),
            'NodeId': data.node_id,
        }


def _map_overlay__hinge_config__to_dict(data: 'overlay.HingeConfig', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'rect': to_dict(
                data.rect,
                casing_strategy
            ),
            'content_color': to_dict(
                data.content_color,
                casing_strategy
            ),
            'outline_color': to_dict(
                data.outline_color,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'rect': to_dict(
                data.rect,
                casing_strategy
            ),
            'contentColor': to_dict(
                data.content_color,
                casing_strategy
            ),
            'outlineColor': to_dict(
                data.outline_color,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'Rect': to_dict(
                data.rect,
                casing_strategy
            ),
            'ContentColor': to_dict(
                data.content_color,
                casing_strategy
            ),
            'OutlineColor': to_dict(
                data.outline_color,
                casing_strategy
            ),
        }


def _map_overlay__container_query_highlight_config__to_dict(data: 'overlay.ContainerQueryHighlightConfig', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'container_query_container_highlight_config': to_dict(
                data.container_query_container_highlight_config,
                casing_strategy
            ),
            'node_id': data.node_id,
        }
    if casing_strategy == 'camel':
        return {
            'containerQueryContainerHighlightConfig': to_dict(
                data.container_query_container_highlight_config,
                casing_strategy
            ),
            'nodeId': data.node_id,
        }
    if casing_strategy == 'pascal':
        return {
            'ContainerQueryContainerHighlightConfig': to_dict(
                data.container_query_container_highlight_config,
                casing_strategy
            ),
            'NodeId': data.node_id,
        }


def _map_overlay__container_query_container_highlight_config__to_dict(data: 'overlay.ContainerQueryContainerHighlightConfig', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'container_border': to_dict(
                data.container_border,
                casing_strategy
            ),
            'descendant_border': to_dict(
                data.descendant_border,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'containerBorder': to_dict(
                data.container_border,
                casing_strategy
            ),
            'descendantBorder': to_dict(
                data.descendant_border,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'ContainerBorder': to_dict(
                data.container_border,
                casing_strategy
            ),
            'DescendantBorder': to_dict(
                data.descendant_border,
                casing_strategy
            ),
        }


def _map_overlay__isolated_element_highlight_config__to_dict(data: 'overlay.IsolatedElementHighlightConfig', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'isolation_mode_highlight_config': to_dict(
                data.isolation_mode_highlight_config,
                casing_strategy
            ),
            'node_id': data.node_id,
        }
    if casing_strategy == 'camel':
        return {
            'isolationModeHighlightConfig': to_dict(
                data.isolation_mode_highlight_config,
                casing_strategy
            ),
            'nodeId': data.node_id,
        }
    if casing_strategy == 'pascal':
        return {
            'IsolationModeHighlightConfig': to_dict(
                data.isolation_mode_highlight_config,
                casing_strategy
            ),
            'NodeId': data.node_id,
        }


def _map_overlay__isolation_mode_highlight_config__to_dict(data: 'overlay.IsolationModeHighlightConfig', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'resizer_color': to_dict(
                data.resizer_color,
                casing_strategy
            ),
            'resizer_handle_color': to_dict(
                data.resizer_handle_color,
                casing_strategy
            ),
            'mask_color': to_dict(
                data.mask_color,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'resizerColor': to_dict(
                data.resizer_color,
                casing_strategy
            ),
            'resizerHandleColor': to_dict(
                data.resizer_handle_color,
                casing_strategy
            ),
            'maskColor': to_dict(
                data.mask_color,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'ResizerColor': to_dict(
                data.resizer_color,
                casing_strategy
            ),
            'ResizerHandleColor': to_dict(
                data.resizer_handle_color,
                casing_strategy
            ),
            'MaskColor': to_dict(
                data.mask_color,
                casing_strategy
            ),
        }


def _map_page__ad_frame_status__to_dict(data: 'page.AdFrameStatus', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'ad_frame_type': data.ad_frame_type,
            'explanations': [
                item
                for item in data.explanations
            ],
        }
    if casing_strategy == 'camel':
        return {
            'adFrameType': data.ad_frame_type,
            'explanations': [
                item
                for item in data.explanations
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'AdFrameType': data.ad_frame_type,
            'Explanations': [
                item
                for item in data.explanations
            ],
        }


def _map_page__ad_script_id__to_dict(data: 'page.AdScriptId', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'script_id': data.script_id,
            'debugger_id': data.debugger_id,
        }
    if casing_strategy == 'camel':
        return {
            'scriptId': data.script_id,
            'debuggerId': data.debugger_id,
        }
    if casing_strategy == 'pascal':
        return {
            'ScriptId': data.script_id,
            'DebuggerId': data.debugger_id,
        }


def _map_page__permissions_policy_block_locator__to_dict(data: 'page.PermissionsPolicyBlockLocator', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'frame_id': data.frame_id,
            'block_reason': data.block_reason,
        }
    if casing_strategy == 'camel':
        return {
            'frameId': data.frame_id,
            'blockReason': data.block_reason,
        }
    if casing_strategy == 'pascal':
        return {
            'FrameId': data.frame_id,
            'BlockReason': data.block_reason,
        }


def _map_page__permissions_policy_feature_state__to_dict(data: 'page.PermissionsPolicyFeatureState', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'feature': data.feature,
            'allowed': data.allowed,
            'locator': to_dict(
                data.locator,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'feature': data.feature,
            'allowed': data.allowed,
            'locator': to_dict(
                data.locator,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'Feature': data.feature,
            'Allowed': data.allowed,
            'Locator': to_dict(
                data.locator,
                casing_strategy
            ),
        }


def _map_page__origin_trial_token__to_dict(data: 'page.OriginTrialToken', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'origin': data.origin,
            'match_sub_domains': data.match_sub_domains,
            'trial_name': data.trial_name,
            'expiry_time': data.expiry_time,
            'is_third_party': data.is_third_party,
            'usage_restriction': data.usage_restriction,
        }
    if casing_strategy == 'camel':
        return {
            'origin': data.origin,
            'matchSubDomains': data.match_sub_domains,
            'trialName': data.trial_name,
            'expiryTime': data.expiry_time,
            'isThirdParty': data.is_third_party,
            'usageRestriction': data.usage_restriction,
        }
    if casing_strategy == 'pascal':
        return {
            'Origin': data.origin,
            'MatchSubDomains': data.match_sub_domains,
            'TrialName': data.trial_name,
            'ExpiryTime': data.expiry_time,
            'IsThirdParty': data.is_third_party,
            'UsageRestriction': data.usage_restriction,
        }


def _map_page__origin_trial_token_with_status__to_dict(data: 'page.OriginTrialTokenWithStatus', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'raw_token_text': data.raw_token_text,
            'parsed_token': to_dict(
                data.parsed_token,
                casing_strategy
            ),
            'status': data.status,
        }
    if casing_strategy == 'camel':
        return {
            'rawTokenText': data.raw_token_text,
            'parsedToken': to_dict(
                data.parsed_token,
                casing_strategy
            ),
            'status': data.status,
        }
    if casing_strategy == 'pascal':
        return {
            'RawTokenText': data.raw_token_text,
            'ParsedToken': to_dict(
                data.parsed_token,
                casing_strategy
            ),
            'Status': data.status,
        }


def _map_page__origin_trial__to_dict(data: 'page.OriginTrial', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'trial_name': data.trial_name,
            'status': data.status,
            'tokens_with_status': [
                to_dict(item, casing_strategy)
                for item in data.tokens_with_status
            ],
        }
    if casing_strategy == 'camel':
        return {
            'trialName': data.trial_name,
            'status': data.status,
            'tokensWithStatus': [
                to_dict(item, casing_strategy)
                for item in data.tokens_with_status
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'TrialName': data.trial_name,
            'Status': data.status,
            'TokensWithStatus': [
                to_dict(item, casing_strategy)
                for item in data.tokens_with_status
            ],
        }


def _map_page__frame__to_dict(data: 'page.Frame', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'id': data.id,
            'parent_id': data.parent_id,
            'loader_id': data.loader_id,
            'name': data.name,
            'url': data.url,
            'url_fragment': data.url_fragment,
            'domain_and_registry': data.domain_and_registry,
            'security_origin': data.security_origin,
            'mime_type': data.mime_type,
            'unreachable_url': data.unreachable_url,
            'ad_frame_status': to_dict(
                data.ad_frame_status,
                casing_strategy
            ),
            'secure_context_type': data.secure_context_type,
            'cross_origin_isolated_context_type': data.cross_origin_isolated_context_type,
            'gated_api_features': [
                item
                for item in data.gated_api_features
            ],
        }
    if casing_strategy == 'camel':
        return {
            'id': data.id,
            'parentId': data.parent_id,
            'loaderId': data.loader_id,
            'name': data.name,
            'url': data.url,
            'urlFragment': data.url_fragment,
            'domainAndRegistry': data.domain_and_registry,
            'securityOrigin': data.security_origin,
            'mimeType': data.mime_type,
            'unreachableUrl': data.unreachable_url,
            'adFrameStatus': to_dict(
                data.ad_frame_status,
                casing_strategy
            ),
            'secureContextType': data.secure_context_type,
            'crossOriginIsolatedContextType': data.cross_origin_isolated_context_type,
            'gatedAPIFeatures': [
                item
                for item in data.gated_api_features
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Id': data.id,
            'ParentId': data.parent_id,
            'LoaderId': data.loader_id,
            'Name': data.name,
            'Url': data.url,
            'UrlFragment': data.url_fragment,
            'DomainAndRegistry': data.domain_and_registry,
            'SecurityOrigin': data.security_origin,
            'MimeType': data.mime_type,
            'UnreachableUrl': data.unreachable_url,
            'AdFrameStatus': to_dict(
                data.ad_frame_status,
                casing_strategy
            ),
            'SecureContextType': data.secure_context_type,
            'CrossOriginIsolatedContextType': data.cross_origin_isolated_context_type,
            'GatedAPIFeatures': [
                item
                for item in data.gated_api_features
            ],
        }


def _map_page__frame_resource__to_dict(data: 'page.FrameResource', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'url': data.url,
            'type': data.type,
            'mime_type': data.mime_type,
            'last_modified': data.last_modified,
            'content_size': data.content_size,
            'failed': data.failed,
            'canceled': data.canceled,
        }
    if casing_strategy == 'camel':
        return {
            'url': data.url,
            'type': data.type,
            'mimeType': data.mime_type,
            'lastModified': data.last_modified,
            'contentSize': data.content_size,
            'failed': data.failed,
            'canceled': data.canceled,
        }
    if casing_strategy == 'pascal':
        return {
            'Url': data.url,
            'Type': data.type,
            'MimeType': data.mime_type,
            'LastModified': data.last_modified,
            'ContentSize': data.content_size,
            'Failed': data.failed,
            'Canceled': data.canceled,
        }


def _map_page__frame_resource_tree__to_dict(data: 'page.FrameResourceTree', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'frame': to_dict(
                data.frame,
                casing_strategy
            ),
            'child_frames': [
                to_dict(item, casing_strategy)
                for item in data.child_frames
            ],
            'resources': [
                to_dict(item, casing_strategy)
                for item in data.resources
            ],
        }
    if casing_strategy == 'camel':
        return {
            'frame': to_dict(
                data.frame,
                casing_strategy
            ),
            'childFrames': [
                to_dict(item, casing_strategy)
                for item in data.child_frames
            ],
            'resources': [
                to_dict(item, casing_strategy)
                for item in data.resources
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Frame': to_dict(
                data.frame,
                casing_strategy
            ),
            'ChildFrames': [
                to_dict(item, casing_strategy)
                for item in data.child_frames
            ],
            'Resources': [
                to_dict(item, casing_strategy)
                for item in data.resources
            ],
        }


def _map_page__frame_tree__to_dict(data: 'page.FrameTree', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'frame': to_dict(
                data.frame,
                casing_strategy
            ),
            'child_frames': [
                to_dict(item, casing_strategy)
                for item in data.child_frames
            ],
        }
    if casing_strategy == 'camel':
        return {
            'frame': to_dict(
                data.frame,
                casing_strategy
            ),
            'childFrames': [
                to_dict(item, casing_strategy)
                for item in data.child_frames
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Frame': to_dict(
                data.frame,
                casing_strategy
            ),
            'ChildFrames': [
                to_dict(item, casing_strategy)
                for item in data.child_frames
            ],
        }


def _map_page__navigation_entry__to_dict(data: 'page.NavigationEntry', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'id': data.id,
            'url': data.url,
            'user_typed_url': data.user_typed_url,
            'title': data.title,
            'transition_type': data.transition_type,
        }
    if casing_strategy == 'camel':
        return {
            'id': data.id,
            'url': data.url,
            'userTypedURL': data.user_typed_url,
            'title': data.title,
            'transitionType': data.transition_type,
        }
    if casing_strategy == 'pascal':
        return {
            'Id': data.id,
            'Url': data.url,
            'UserTypedURL': data.user_typed_url,
            'Title': data.title,
            'TransitionType': data.transition_type,
        }


def _map_page__screencast_frame_metadata__to_dict(data: 'page.ScreencastFrameMetadata', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'offset_top': data.offset_top,
            'page_scale_factor': data.page_scale_factor,
            'device_width': data.device_width,
            'device_height': data.device_height,
            'scroll_offset_x': data.scroll_offset_x,
            'scroll_offset_y': data.scroll_offset_y,
            'timestamp': data.timestamp,
        }
    if casing_strategy == 'camel':
        return {
            'offsetTop': data.offset_top,
            'pageScaleFactor': data.page_scale_factor,
            'deviceWidth': data.device_width,
            'deviceHeight': data.device_height,
            'scrollOffsetX': data.scroll_offset_x,
            'scrollOffsetY': data.scroll_offset_y,
            'timestamp': data.timestamp,
        }
    if casing_strategy == 'pascal':
        return {
            'OffsetTop': data.offset_top,
            'PageScaleFactor': data.page_scale_factor,
            'DeviceWidth': data.device_width,
            'DeviceHeight': data.device_height,
            'ScrollOffsetX': data.scroll_offset_x,
            'ScrollOffsetY': data.scroll_offset_y,
            'Timestamp': data.timestamp,
        }


def _map_page__app_manifest_error__to_dict(data: 'page.AppManifestError', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'message': data.message,
            'critical': data.critical,
            'line': data.line,
            'column': data.column,
        }
    if casing_strategy == 'camel':
        return {
            'message': data.message,
            'critical': data.critical,
            'line': data.line,
            'column': data.column,
        }
    if casing_strategy == 'pascal':
        return {
            'Message': data.message,
            'Critical': data.critical,
            'Line': data.line,
            'Column': data.column,
        }


def _map_page__app_manifest_parsed_properties__to_dict(data: 'page.AppManifestParsedProperties', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'scope': data.scope,
        }
    if casing_strategy == 'camel':
        return {
            'scope': data.scope,
        }
    if casing_strategy == 'pascal':
        return {
            'Scope': data.scope,
        }


def _map_page__layout_viewport__to_dict(data: 'page.LayoutViewport', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'page_x': data.page_x,
            'page_y': data.page_y,
            'client_width': data.client_width,
            'client_height': data.client_height,
        }
    if casing_strategy == 'camel':
        return {
            'pageX': data.page_x,
            'pageY': data.page_y,
            'clientWidth': data.client_width,
            'clientHeight': data.client_height,
        }
    if casing_strategy == 'pascal':
        return {
            'PageX': data.page_x,
            'PageY': data.page_y,
            'ClientWidth': data.client_width,
            'ClientHeight': data.client_height,
        }


def _map_page__visual_viewport__to_dict(data: 'page.VisualViewport', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'offset_x': data.offset_x,
            'offset_y': data.offset_y,
            'page_x': data.page_x,
            'page_y': data.page_y,
            'client_width': data.client_width,
            'client_height': data.client_height,
            'scale': data.scale,
            'zoom': data.zoom,
        }
    if casing_strategy == 'camel':
        return {
            'offsetX': data.offset_x,
            'offsetY': data.offset_y,
            'pageX': data.page_x,
            'pageY': data.page_y,
            'clientWidth': data.client_width,
            'clientHeight': data.client_height,
            'scale': data.scale,
            'zoom': data.zoom,
        }
    if casing_strategy == 'pascal':
        return {
            'OffsetX': data.offset_x,
            'OffsetY': data.offset_y,
            'PageX': data.page_x,
            'PageY': data.page_y,
            'ClientWidth': data.client_width,
            'ClientHeight': data.client_height,
            'Scale': data.scale,
            'Zoom': data.zoom,
        }


def _map_page__viewport__to_dict(data: 'page.Viewport', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'x': data.x,
            'y': data.y,
            'width': data.width,
            'height': data.height,
            'scale': data.scale,
        }
    if casing_strategy == 'camel':
        return {
            'x': data.x,
            'y': data.y,
            'width': data.width,
            'height': data.height,
            'scale': data.scale,
        }
    if casing_strategy == 'pascal':
        return {
            'X': data.x,
            'Y': data.y,
            'Width': data.width,
            'Height': data.height,
            'Scale': data.scale,
        }


def _map_page__font_families__to_dict(data: 'page.FontFamilies', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'standard': data.standard,
            'fixed': data.fixed,
            'serif': data.serif,
            'sans_serif': data.sans_serif,
            'cursive': data.cursive,
            'fantasy': data.fantasy,
            'math': data.math,
        }
    if casing_strategy == 'camel':
        return {
            'standard': data.standard,
            'fixed': data.fixed,
            'serif': data.serif,
            'sansSerif': data.sans_serif,
            'cursive': data.cursive,
            'fantasy': data.fantasy,
            'math': data.math,
        }
    if casing_strategy == 'pascal':
        return {
            'Standard': data.standard,
            'Fixed': data.fixed,
            'Serif': data.serif,
            'SansSerif': data.sans_serif,
            'Cursive': data.cursive,
            'Fantasy': data.fantasy,
            'Math': data.math,
        }


def _map_page__script_font_families__to_dict(data: 'page.ScriptFontFamilies', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'script': data.script,
            'font_families': to_dict(
                data.font_families,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'script': data.script,
            'fontFamilies': to_dict(
                data.font_families,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'Script': data.script,
            'FontFamilies': to_dict(
                data.font_families,
                casing_strategy
            ),
        }


def _map_page__font_sizes__to_dict(data: 'page.FontSizes', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'standard': data.standard,
            'fixed': data.fixed,
        }
    if casing_strategy == 'camel':
        return {
            'standard': data.standard,
            'fixed': data.fixed,
        }
    if casing_strategy == 'pascal':
        return {
            'Standard': data.standard,
            'Fixed': data.fixed,
        }


def _map_page__installability_error_argument__to_dict(data: 'page.InstallabilityErrorArgument', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
        }


def _map_page__installability_error__to_dict(data: 'page.InstallabilityError', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'error_id': data.error_id,
            'error_arguments': [
                to_dict(item, casing_strategy)
                for item in data.error_arguments
            ],
        }
    if casing_strategy == 'camel':
        return {
            'errorId': data.error_id,
            'errorArguments': [
                to_dict(item, casing_strategy)
                for item in data.error_arguments
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'ErrorId': data.error_id,
            'ErrorArguments': [
                to_dict(item, casing_strategy)
                for item in data.error_arguments
            ],
        }


def _map_page__compilation_cache_params__to_dict(data: 'page.CompilationCacheParams', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'url': data.url,
            'eager': data.eager,
        }
    if casing_strategy == 'camel':
        return {
            'url': data.url,
            'eager': data.eager,
        }
    if casing_strategy == 'pascal':
        return {
            'Url': data.url,
            'Eager': data.eager,
        }


def _map_page__back_forward_cache_not_restored_explanation__to_dict(data: 'page.BackForwardCacheNotRestoredExplanation', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'reason': data.reason,
            'context': data.context,
        }
    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'reason': data.reason,
            'context': data.context,
        }
    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'Reason': data.reason,
            'Context': data.context,
        }


def _map_page__back_forward_cache_not_restored_explanation_tree__to_dict(data: 'page.BackForwardCacheNotRestoredExplanationTree', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'url': data.url,
            'explanations': [
                to_dict(item, casing_strategy)
                for item in data.explanations
            ],
            'children': [
                to_dict(item, casing_strategy)
                for item in data.children
            ],
        }
    if casing_strategy == 'camel':
        return {
            'url': data.url,
            'explanations': [
                to_dict(item, casing_strategy)
                for item in data.explanations
            ],
            'children': [
                to_dict(item, casing_strategy)
                for item in data.children
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Url': data.url,
            'Explanations': [
                to_dict(item, casing_strategy)
                for item in data.explanations
            ],
            'Children': [
                to_dict(item, casing_strategy)
                for item in data.children
            ],
        }


def _map_performance__metric__to_dict(data: 'performance.Metric', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
        }


def _map_performance_timeline__largest_contentful_paint__to_dict(data: 'performance_timeline.LargestContentfulPaint', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'render_time': data.render_time,
            'load_time': data.load_time,
            'size': data.size,
            'element_id': data.element_id,
            'url': data.url,
            'node_id': data.node_id,
        }
    if casing_strategy == 'camel':
        return {
            'renderTime': data.render_time,
            'loadTime': data.load_time,
            'size': data.size,
            'elementId': data.element_id,
            'url': data.url,
            'nodeId': data.node_id,
        }
    if casing_strategy == 'pascal':
        return {
            'RenderTime': data.render_time,
            'LoadTime': data.load_time,
            'Size': data.size,
            'ElementId': data.element_id,
            'Url': data.url,
            'NodeId': data.node_id,
        }


def _map_performance_timeline__layout_shift_attribution__to_dict(data: 'performance_timeline.LayoutShiftAttribution', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'previous_rect': to_dict(
                data.previous_rect,
                casing_strategy
            ),
            'current_rect': to_dict(
                data.current_rect,
                casing_strategy
            ),
            'node_id': data.node_id,
        }
    if casing_strategy == 'camel':
        return {
            'previousRect': to_dict(
                data.previous_rect,
                casing_strategy
            ),
            'currentRect': to_dict(
                data.current_rect,
                casing_strategy
            ),
            'nodeId': data.node_id,
        }
    if casing_strategy == 'pascal':
        return {
            'PreviousRect': to_dict(
                data.previous_rect,
                casing_strategy
            ),
            'CurrentRect': to_dict(
                data.current_rect,
                casing_strategy
            ),
            'NodeId': data.node_id,
        }


def _map_performance_timeline__layout_shift__to_dict(data: 'performance_timeline.LayoutShift', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'value': data.value,
            'had_recent_input': data.had_recent_input,
            'last_input_time': data.last_input_time,
            'sources': [
                to_dict(item, casing_strategy)
                for item in data.sources
            ],
        }
    if casing_strategy == 'camel':
        return {
            'value': data.value,
            'hadRecentInput': data.had_recent_input,
            'lastInputTime': data.last_input_time,
            'sources': [
                to_dict(item, casing_strategy)
                for item in data.sources
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Value': data.value,
            'HadRecentInput': data.had_recent_input,
            'LastInputTime': data.last_input_time,
            'Sources': [
                to_dict(item, casing_strategy)
                for item in data.sources
            ],
        }


def _map_performance_timeline__timeline_event__to_dict(data: 'performance_timeline.TimelineEvent', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'frame_id': data.frame_id,
            'type': data.type,
            'name': data.name,
            'time': data.time,
            'duration': data.duration,
            'lcp_details': to_dict(
                data.lcp_details,
                casing_strategy
            ),
            'layout_shift_details': to_dict(
                data.layout_shift_details,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'frameId': data.frame_id,
            'type': data.type,
            'name': data.name,
            'time': data.time,
            'duration': data.duration,
            'lcpDetails': to_dict(
                data.lcp_details,
                casing_strategy
            ),
            'layoutShiftDetails': to_dict(
                data.layout_shift_details,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'FrameId': data.frame_id,
            'Type': data.type,
            'Name': data.name,
            'Time': data.time,
            'Duration': data.duration,
            'LcpDetails': to_dict(
                data.lcp_details,
                casing_strategy
            ),
            'LayoutShiftDetails': to_dict(
                data.layout_shift_details,
                casing_strategy
            ),
        }


def _map_security__certificate_security_state__to_dict(data: 'security.CertificateSecurityState', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'protocol': data.protocol,
            'key_exchange': data.key_exchange,
            'key_exchange_group': data.key_exchange_group,
            'cipher': data.cipher,
            'mac': data.mac,
            'certificate': [
                item
                for item in data.certificate
            ],
            'subject_name': data.subject_name,
            'issuer': data.issuer,
            'valid_from': data.valid_from,
            'valid_to': data.valid_to,
            'certificate_network_error': data.certificate_network_error,
            'certificate_has_weak_signature': data.certificate_has_weak_signature,
            'certificate_has_sha1_signature': data.certificate_has_sha1_signature,
            'modern_ssl': data.modern_ssl,
            'obsolete_ssl_protocol': data.obsolete_ssl_protocol,
            'obsolete_ssl_key_exchange': data.obsolete_ssl_key_exchange,
            'obsolete_ssl_cipher': data.obsolete_ssl_cipher,
            'obsolete_ssl_signature': data.obsolete_ssl_signature,
        }
    if casing_strategy == 'camel':
        return {
            'protocol': data.protocol,
            'keyExchange': data.key_exchange,
            'keyExchangeGroup': data.key_exchange_group,
            'cipher': data.cipher,
            'mac': data.mac,
            'certificate': [
                item
                for item in data.certificate
            ],
            'subjectName': data.subject_name,
            'issuer': data.issuer,
            'validFrom': data.valid_from,
            'validTo': data.valid_to,
            'certificateNetworkError': data.certificate_network_error,
            'certificateHasWeakSignature': data.certificate_has_weak_signature,
            'certificateHasSha1Signature': data.certificate_has_sha1_signature,
            'modernSSL': data.modern_ssl,
            'obsoleteSslProtocol': data.obsolete_ssl_protocol,
            'obsoleteSslKeyExchange': data.obsolete_ssl_key_exchange,
            'obsoleteSslCipher': data.obsolete_ssl_cipher,
            'obsoleteSslSignature': data.obsolete_ssl_signature,
        }
    if casing_strategy == 'pascal':
        return {
            'Protocol': data.protocol,
            'KeyExchange': data.key_exchange,
            'KeyExchangeGroup': data.key_exchange_group,
            'Cipher': data.cipher,
            'Mac': data.mac,
            'Certificate': [
                item
                for item in data.certificate
            ],
            'SubjectName': data.subject_name,
            'Issuer': data.issuer,
            'ValidFrom': data.valid_from,
            'ValidTo': data.valid_to,
            'CertificateNetworkError': data.certificate_network_error,
            'CertificateHasWeakSignature': data.certificate_has_weak_signature,
            'CertificateHasSha1Signature': data.certificate_has_sha1_signature,
            'ModernSSL': data.modern_ssl,
            'ObsoleteSslProtocol': data.obsolete_ssl_protocol,
            'ObsoleteSslKeyExchange': data.obsolete_ssl_key_exchange,
            'ObsoleteSslCipher': data.obsolete_ssl_cipher,
            'ObsoleteSslSignature': data.obsolete_ssl_signature,
        }


def _map_security__safety_tip_info__to_dict(data: 'security.SafetyTipInfo', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'safety_tip_status': data.safety_tip_status,
            'safe_url': data.safe_url,
        }
    if casing_strategy == 'camel':
        return {
            'safetyTipStatus': data.safety_tip_status,
            'safeUrl': data.safe_url,
        }
    if casing_strategy == 'pascal':
        return {
            'SafetyTipStatus': data.safety_tip_status,
            'SafeUrl': data.safe_url,
        }


def _map_security__visible_security_state__to_dict(data: 'security.VisibleSecurityState', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'security_state': data.security_state,
            'certificate_security_state': to_dict(
                data.certificate_security_state,
                casing_strategy
            ),
            'safety_tip_info': to_dict(
                data.safety_tip_info,
                casing_strategy
            ),
            'security_state_issue_ids': [
                item
                for item in data.security_state_issue_ids
            ],
        }
    if casing_strategy == 'camel':
        return {
            'securityState': data.security_state,
            'certificateSecurityState': to_dict(
                data.certificate_security_state,
                casing_strategy
            ),
            'safetyTipInfo': to_dict(
                data.safety_tip_info,
                casing_strategy
            ),
            'securityStateIssueIds': [
                item
                for item in data.security_state_issue_ids
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'SecurityState': data.security_state,
            'CertificateSecurityState': to_dict(
                data.certificate_security_state,
                casing_strategy
            ),
            'SafetyTipInfo': to_dict(
                data.safety_tip_info,
                casing_strategy
            ),
            'SecurityStateIssueIds': [
                item
                for item in data.security_state_issue_ids
            ],
        }


def _map_security__security_state_explanation__to_dict(data: 'security.SecurityStateExplanation', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'security_state': data.security_state,
            'title': data.title,
            'summary': data.summary,
            'description': data.description,
            'mixed_content_type': data.mixed_content_type,
            'certificate': [
                item
                for item in data.certificate
            ],
            'recommendations': [
                item
                for item in data.recommendations
            ],
        }
    if casing_strategy == 'camel':
        return {
            'securityState': data.security_state,
            'title': data.title,
            'summary': data.summary,
            'description': data.description,
            'mixedContentType': data.mixed_content_type,
            'certificate': [
                item
                for item in data.certificate
            ],
            'recommendations': [
                item
                for item in data.recommendations
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'SecurityState': data.security_state,
            'Title': data.title,
            'Summary': data.summary,
            'Description': data.description,
            'MixedContentType': data.mixed_content_type,
            'Certificate': [
                item
                for item in data.certificate
            ],
            'Recommendations': [
                item
                for item in data.recommendations
            ],
        }


def _map_security__insecure_content_status__to_dict(data: 'security.InsecureContentStatus', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'ran_mixed_content': data.ran_mixed_content,
            'displayed_mixed_content': data.displayed_mixed_content,
            'contained_mixed_form': data.contained_mixed_form,
            'ran_content_with_cert_errors': data.ran_content_with_cert_errors,
            'displayed_content_with_cert_errors': data.displayed_content_with_cert_errors,
            'ran_insecure_content_style': data.ran_insecure_content_style,
            'displayed_insecure_content_style': data.displayed_insecure_content_style,
        }
    if casing_strategy == 'camel':
        return {
            'ranMixedContent': data.ran_mixed_content,
            'displayedMixedContent': data.displayed_mixed_content,
            'containedMixedForm': data.contained_mixed_form,
            'ranContentWithCertErrors': data.ran_content_with_cert_errors,
            'displayedContentWithCertErrors': data.displayed_content_with_cert_errors,
            'ranInsecureContentStyle': data.ran_insecure_content_style,
            'displayedInsecureContentStyle': data.displayed_insecure_content_style,
        }
    if casing_strategy == 'pascal':
        return {
            'RanMixedContent': data.ran_mixed_content,
            'DisplayedMixedContent': data.displayed_mixed_content,
            'ContainedMixedForm': data.contained_mixed_form,
            'RanContentWithCertErrors': data.ran_content_with_cert_errors,
            'DisplayedContentWithCertErrors': data.displayed_content_with_cert_errors,
            'RanInsecureContentStyle': data.ran_insecure_content_style,
            'DisplayedInsecureContentStyle': data.displayed_insecure_content_style,
        }


def _map_service_worker__service_worker_registration__to_dict(data: 'service_worker.ServiceWorkerRegistration', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'registration_id': data.registration_id,
            'scope_url': data.scope_url,
            'is_deleted': data.is_deleted,
        }
    if casing_strategy == 'camel':
        return {
            'registrationId': data.registration_id,
            'scopeURL': data.scope_url,
            'isDeleted': data.is_deleted,
        }
    if casing_strategy == 'pascal':
        return {
            'RegistrationId': data.registration_id,
            'ScopeURL': data.scope_url,
            'IsDeleted': data.is_deleted,
        }


def _map_service_worker__service_worker_version__to_dict(data: 'service_worker.ServiceWorkerVersion', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'version_id': data.version_id,
            'registration_id': data.registration_id,
            'script_url': data.script_url,
            'running_status': data.running_status,
            'status': data.status,
            'script_last_modified': data.script_last_modified,
            'script_response_time': data.script_response_time,
            'controlled_clients': [
                item
                for item in data.controlled_clients
            ],
            'target_id': data.target_id,
        }
    if casing_strategy == 'camel':
        return {
            'versionId': data.version_id,
            'registrationId': data.registration_id,
            'scriptURL': data.script_url,
            'runningStatus': data.running_status,
            'status': data.status,
            'scriptLastModified': data.script_last_modified,
            'scriptResponseTime': data.script_response_time,
            'controlledClients': [
                item
                for item in data.controlled_clients
            ],
            'targetId': data.target_id,
        }
    if casing_strategy == 'pascal':
        return {
            'VersionId': data.version_id,
            'RegistrationId': data.registration_id,
            'ScriptURL': data.script_url,
            'RunningStatus': data.running_status,
            'Status': data.status,
            'ScriptLastModified': data.script_last_modified,
            'ScriptResponseTime': data.script_response_time,
            'ControlledClients': [
                item
                for item in data.controlled_clients
            ],
            'TargetId': data.target_id,
        }


def _map_service_worker__service_worker_error_message__to_dict(data: 'service_worker.ServiceWorkerErrorMessage', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'error_message': data.error_message,
            'registration_id': data.registration_id,
            'version_id': data.version_id,
            'source_url': data.source_url,
            'line_number': data.line_number,
            'column_number': data.column_number,
        }
    if casing_strategy == 'camel':
        return {
            'errorMessage': data.error_message,
            'registrationId': data.registration_id,
            'versionId': data.version_id,
            'sourceURL': data.source_url,
            'lineNumber': data.line_number,
            'columnNumber': data.column_number,
        }
    if casing_strategy == 'pascal':
        return {
            'ErrorMessage': data.error_message,
            'RegistrationId': data.registration_id,
            'VersionId': data.version_id,
            'SourceURL': data.source_url,
            'LineNumber': data.line_number,
            'ColumnNumber': data.column_number,
        }


def _map_storage__usage_for_type__to_dict(data: 'storage.UsageForType', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'storage_type': data.storage_type,
            'usage': data.usage,
        }
    if casing_strategy == 'camel':
        return {
            'storageType': data.storage_type,
            'usage': data.usage,
        }
    if casing_strategy == 'pascal':
        return {
            'StorageType': data.storage_type,
            'Usage': data.usage,
        }


def _map_storage__trust_tokens__to_dict(data: 'storage.TrustTokens', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'issuer_origin': data.issuer_origin,
            'count': data.count,
        }
    if casing_strategy == 'camel':
        return {
            'issuerOrigin': data.issuer_origin,
            'count': data.count,
        }
    if casing_strategy == 'pascal':
        return {
            'IssuerOrigin': data.issuer_origin,
            'Count': data.count,
        }


def _map_storage__interest_group_ad__to_dict(data: 'storage.InterestGroupAd', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'render_url': data.render_url,
            'metadata': data.metadata,
        }
    if casing_strategy == 'camel':
        return {
            'renderUrl': data.render_url,
            'metadata': data.metadata,
        }
    if casing_strategy == 'pascal':
        return {
            'RenderUrl': data.render_url,
            'Metadata': data.metadata,
        }


def _map_storage__interest_group_details__to_dict(data: 'storage.InterestGroupDetails', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'owner_origin': data.owner_origin,
            'name': data.name,
            'expiration_time': data.expiration_time,
            'joining_origin': data.joining_origin,
            'bidding_url': data.bidding_url,
            'bidding_wasm_helper_url': data.bidding_wasm_helper_url,
            'update_url': data.update_url,
            'trusted_bidding_signals_url': data.trusted_bidding_signals_url,
            'trusted_bidding_signals_keys': [
                item
                for item in data.trusted_bidding_signals_keys
            ],
            'user_bidding_signals': data.user_bidding_signals,
            'ads': [
                to_dict(item, casing_strategy)
                for item in data.ads
            ],
            'ad_components': [
                to_dict(item, casing_strategy)
                for item in data.ad_components
            ],
        }
    if casing_strategy == 'camel':
        return {
            'ownerOrigin': data.owner_origin,
            'name': data.name,
            'expirationTime': data.expiration_time,
            'joiningOrigin': data.joining_origin,
            'biddingUrl': data.bidding_url,
            'biddingWasmHelperUrl': data.bidding_wasm_helper_url,
            'updateUrl': data.update_url,
            'trustedBiddingSignalsUrl': data.trusted_bidding_signals_url,
            'trustedBiddingSignalsKeys': [
                item
                for item in data.trusted_bidding_signals_keys
            ],
            'userBiddingSignals': data.user_bidding_signals,
            'ads': [
                to_dict(item, casing_strategy)
                for item in data.ads
            ],
            'adComponents': [
                to_dict(item, casing_strategy)
                for item in data.ad_components
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'OwnerOrigin': data.owner_origin,
            'Name': data.name,
            'ExpirationTime': data.expiration_time,
            'JoiningOrigin': data.joining_origin,
            'BiddingUrl': data.bidding_url,
            'BiddingWasmHelperUrl': data.bidding_wasm_helper_url,
            'UpdateUrl': data.update_url,
            'TrustedBiddingSignalsUrl': data.trusted_bidding_signals_url,
            'TrustedBiddingSignalsKeys': [
                item
                for item in data.trusted_bidding_signals_keys
            ],
            'UserBiddingSignals': data.user_bidding_signals,
            'Ads': [
                to_dict(item, casing_strategy)
                for item in data.ads
            ],
            'AdComponents': [
                to_dict(item, casing_strategy)
                for item in data.ad_components
            ],
        }


def _map_storage__shared_storage_entry__to_dict(data: 'storage.SharedStorageEntry', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'key': data.key,
            'value': data.value,
        }
    if casing_strategy == 'camel':
        return {
            'key': data.key,
            'value': data.value,
        }
    if casing_strategy == 'pascal':
        return {
            'Key': data.key,
            'Value': data.value,
        }


def _map_storage__shared_storage_metadata__to_dict(data: 'storage.SharedStorageMetadata', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'creation_time': data.creation_time,
            'length': data.length,
            'remaining_budget': data.remaining_budget,
        }
    if casing_strategy == 'camel':
        return {
            'creationTime': data.creation_time,
            'length': data.length,
            'remainingBudget': data.remaining_budget,
        }
    if casing_strategy == 'pascal':
        return {
            'CreationTime': data.creation_time,
            'Length': data.length,
            'RemainingBudget': data.remaining_budget,
        }


def _map_storage__shared_storage_reporting_metadata__to_dict(data: 'storage.SharedStorageReportingMetadata', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'event_type': data.event_type,
            'reporting_url': data.reporting_url,
        }
    if casing_strategy == 'camel':
        return {
            'eventType': data.event_type,
            'reportingUrl': data.reporting_url,
        }
    if casing_strategy == 'pascal':
        return {
            'EventType': data.event_type,
            'ReportingUrl': data.reporting_url,
        }


def _map_storage__shared_storage_url_with_metadata__to_dict(data: 'storage.SharedStorageUrlWithMetadata', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'url': data.url,
            'reporting_metadata': [
                to_dict(item, casing_strategy)
                for item in data.reporting_metadata
            ],
        }
    if casing_strategy == 'camel':
        return {
            'url': data.url,
            'reportingMetadata': [
                to_dict(item, casing_strategy)
                for item in data.reporting_metadata
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Url': data.url,
            'ReportingMetadata': [
                to_dict(item, casing_strategy)
                for item in data.reporting_metadata
            ],
        }


def _map_storage__shared_storage_access_params__to_dict(data: 'storage.SharedStorageAccessParams', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'script_source_url': data.script_source_url,
            'operation_name': data.operation_name,
            'serialized_data': data.serialized_data,
            'urls_with_metadata': [
                to_dict(item, casing_strategy)
                for item in data.urls_with_metadata
            ],
            'key': data.key,
            'value': data.value,
            'ignore_if_present': data.ignore_if_present,
        }
    if casing_strategy == 'camel':
        return {
            'scriptSourceUrl': data.script_source_url,
            'operationName': data.operation_name,
            'serializedData': data.serialized_data,
            'urlsWithMetadata': [
                to_dict(item, casing_strategy)
                for item in data.urls_with_metadata
            ],
            'key': data.key,
            'value': data.value,
            'ignoreIfPresent': data.ignore_if_present,
        }
    if casing_strategy == 'pascal':
        return {
            'ScriptSourceUrl': data.script_source_url,
            'OperationName': data.operation_name,
            'SerializedData': data.serialized_data,
            'UrlsWithMetadata': [
                to_dict(item, casing_strategy)
                for item in data.urls_with_metadata
            ],
            'Key': data.key,
            'Value': data.value,
            'IgnoreIfPresent': data.ignore_if_present,
        }


def _map_storage__storage_bucket__to_dict(data: 'storage.StorageBucket', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'storage_key': data.storage_key,
            'name': data.name,
        }
    if casing_strategy == 'camel':
        return {
            'storageKey': data.storage_key,
            'name': data.name,
        }
    if casing_strategy == 'pascal':
        return {
            'StorageKey': data.storage_key,
            'Name': data.name,
        }


def _map_storage__storage_bucket_info__to_dict(data: 'storage.StorageBucketInfo', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'bucket': to_dict(
                data.bucket,
                casing_strategy
            ),
            'id': data.id,
            'expiration': data.expiration,
            'quota': data.quota,
            'persistent': data.persistent,
            'durability': data.durability,
        }
    if casing_strategy == 'camel':
        return {
            'bucket': to_dict(
                data.bucket,
                casing_strategy
            ),
            'id': data.id,
            'expiration': data.expiration,
            'quota': data.quota,
            'persistent': data.persistent,
            'durability': data.durability,
        }
    if casing_strategy == 'pascal':
        return {
            'Bucket': to_dict(
                data.bucket,
                casing_strategy
            ),
            'Id': data.id,
            'Expiration': data.expiration,
            'Quota': data.quota,
            'Persistent': data.persistent,
            'Durability': data.durability,
        }


def _map_storage__attribution_reporting_filter_data_entry__to_dict(data: 'storage.AttributionReportingFilterDataEntry', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'key': data.key,
            'values': [
                item
                for item in data.values
            ],
        }
    if casing_strategy == 'camel':
        return {
            'key': data.key,
            'values': [
                item
                for item in data.values
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Key': data.key,
            'Values': [
                item
                for item in data.values
            ],
        }


def _map_storage__attribution_reporting_aggregation_keys_entry__to_dict(data: 'storage.AttributionReportingAggregationKeysEntry', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'key': data.key,
            'value': data.value,
        }
    if casing_strategy == 'camel':
        return {
            'key': data.key,
            'value': data.value,
        }
    if casing_strategy == 'pascal':
        return {
            'Key': data.key,
            'Value': data.value,
        }


def _map_storage__attribution_reporting_event_report_windows__to_dict(data: 'storage.AttributionReportingEventReportWindows', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'start': data.start,
            'ends': [
                item
                for item in data.ends
            ],
        }
    if casing_strategy == 'camel':
        return {
            'start': data.start,
            'ends': [
                item
                for item in data.ends
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Start': data.start,
            'Ends': [
                item
                for item in data.ends
            ],
        }


def _map_storage__attribution_reporting_source_registration__to_dict(data: 'storage.AttributionReportingSourceRegistration', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'time': data.time,
            'expiry': data.expiry,
            'event_report_window': data.event_report_window,
            'event_report_windows': to_dict(
                data.event_report_windows,
                casing_strategy
            ),
            'aggregatable_report_window': data.aggregatable_report_window,
            'type': data.type,
            'source_origin': data.source_origin,
            'reporting_origin': data.reporting_origin,
            'destination_sites': [
                item
                for item in data.destination_sites
            ],
            'event_id': data.event_id,
            'priority': data.priority,
            'filter_data': [
                to_dict(item, casing_strategy)
                for item in data.filter_data
            ],
            'aggregation_keys': [
                to_dict(item, casing_strategy)
                for item in data.aggregation_keys
            ],
            'debug_key': data.debug_key,
        }
    if casing_strategy == 'camel':
        return {
            'time': data.time,
            'expiry': data.expiry,
            'eventReportWindow': data.event_report_window,
            'eventReportWindows': to_dict(
                data.event_report_windows,
                casing_strategy
            ),
            'aggregatableReportWindow': data.aggregatable_report_window,
            'type': data.type,
            'sourceOrigin': data.source_origin,
            'reportingOrigin': data.reporting_origin,
            'destinationSites': [
                item
                for item in data.destination_sites
            ],
            'eventId': data.event_id,
            'priority': data.priority,
            'filterData': [
                to_dict(item, casing_strategy)
                for item in data.filter_data
            ],
            'aggregationKeys': [
                to_dict(item, casing_strategy)
                for item in data.aggregation_keys
            ],
            'debugKey': data.debug_key,
        }
    if casing_strategy == 'pascal':
        return {
            'Time': data.time,
            'Expiry': data.expiry,
            'EventReportWindow': data.event_report_window,
            'EventReportWindows': to_dict(
                data.event_report_windows,
                casing_strategy
            ),
            'AggregatableReportWindow': data.aggregatable_report_window,
            'Type': data.type,
            'SourceOrigin': data.source_origin,
            'ReportingOrigin': data.reporting_origin,
            'DestinationSites': [
                item
                for item in data.destination_sites
            ],
            'EventId': data.event_id,
            'Priority': data.priority,
            'FilterData': [
                to_dict(item, casing_strategy)
                for item in data.filter_data
            ],
            'AggregationKeys': [
                to_dict(item, casing_strategy)
                for item in data.aggregation_keys
            ],
            'DebugKey': data.debug_key,
        }


def _map_system_info__gpu_device__to_dict(data: 'system_info.GPUDevice', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'vendor_id': data.vendor_id,
            'device_id': data.device_id,
            'sub_sys_id': data.sub_sys_id,
            'revision': data.revision,
            'vendor_string': data.vendor_string,
            'device_string': data.device_string,
            'driver_vendor': data.driver_vendor,
            'driver_version': data.driver_version,
        }
    if casing_strategy == 'camel':
        return {
            'vendorId': data.vendor_id,
            'deviceId': data.device_id,
            'subSysId': data.sub_sys_id,
            'revision': data.revision,
            'vendorString': data.vendor_string,
            'deviceString': data.device_string,
            'driverVendor': data.driver_vendor,
            'driverVersion': data.driver_version,
        }
    if casing_strategy == 'pascal':
        return {
            'VendorId': data.vendor_id,
            'DeviceId': data.device_id,
            'SubSysId': data.sub_sys_id,
            'Revision': data.revision,
            'VendorString': data.vendor_string,
            'DeviceString': data.device_string,
            'DriverVendor': data.driver_vendor,
            'DriverVersion': data.driver_version,
        }


def _map_system_info__size__to_dict(data: 'system_info.Size', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'width': data.width,
            'height': data.height,
        }
    if casing_strategy == 'camel':
        return {
            'width': data.width,
            'height': data.height,
        }
    if casing_strategy == 'pascal':
        return {
            'Width': data.width,
            'Height': data.height,
        }


def _map_system_info__video_decode_accelerator_capability__to_dict(data: 'system_info.VideoDecodeAcceleratorCapability', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'profile': data.profile,
            'max_resolution': to_dict(
                data.max_resolution,
                casing_strategy
            ),
            'min_resolution': to_dict(
                data.min_resolution,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'profile': data.profile,
            'maxResolution': to_dict(
                data.max_resolution,
                casing_strategy
            ),
            'minResolution': to_dict(
                data.min_resolution,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'Profile': data.profile,
            'MaxResolution': to_dict(
                data.max_resolution,
                casing_strategy
            ),
            'MinResolution': to_dict(
                data.min_resolution,
                casing_strategy
            ),
        }


def _map_system_info__video_encode_accelerator_capability__to_dict(data: 'system_info.VideoEncodeAcceleratorCapability', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'profile': data.profile,
            'max_resolution': to_dict(
                data.max_resolution,
                casing_strategy
            ),
            'max_framerate_numerator': data.max_framerate_numerator,
            'max_framerate_denominator': data.max_framerate_denominator,
        }
    if casing_strategy == 'camel':
        return {
            'profile': data.profile,
            'maxResolution': to_dict(
                data.max_resolution,
                casing_strategy
            ),
            'maxFramerateNumerator': data.max_framerate_numerator,
            'maxFramerateDenominator': data.max_framerate_denominator,
        }
    if casing_strategy == 'pascal':
        return {
            'Profile': data.profile,
            'MaxResolution': to_dict(
                data.max_resolution,
                casing_strategy
            ),
            'MaxFramerateNumerator': data.max_framerate_numerator,
            'MaxFramerateDenominator': data.max_framerate_denominator,
        }


def _map_system_info__image_decode_accelerator_capability__to_dict(data: 'system_info.ImageDecodeAcceleratorCapability', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'image_type': data.image_type,
            'max_dimensions': to_dict(
                data.max_dimensions,
                casing_strategy
            ),
            'min_dimensions': to_dict(
                data.min_dimensions,
                casing_strategy
            ),
            'subsamplings': [
                item
                for item in data.subsamplings
            ],
        }
    if casing_strategy == 'camel':
        return {
            'imageType': data.image_type,
            'maxDimensions': to_dict(
                data.max_dimensions,
                casing_strategy
            ),
            'minDimensions': to_dict(
                data.min_dimensions,
                casing_strategy
            ),
            'subsamplings': [
                item
                for item in data.subsamplings
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'ImageType': data.image_type,
            'MaxDimensions': to_dict(
                data.max_dimensions,
                casing_strategy
            ),
            'MinDimensions': to_dict(
                data.min_dimensions,
                casing_strategy
            ),
            'Subsamplings': [
                item
                for item in data.subsamplings
            ],
        }


def _map_system_info__gpu_info__to_dict(data: 'system_info.GPUInfo', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'devices': [
                to_dict(item, casing_strategy)
                for item in data.devices
            ],
            'aux_attributes': data.aux_attributes,
            'feature_status': data.feature_status,
            'driver_bug_workarounds': [
                item
                for item in data.driver_bug_workarounds
            ],
            'video_decoding': [
                to_dict(item, casing_strategy)
                for item in data.video_decoding
            ],
            'video_encoding': [
                to_dict(item, casing_strategy)
                for item in data.video_encoding
            ],
            'image_decoding': [
                to_dict(item, casing_strategy)
                for item in data.image_decoding
            ],
        }
    if casing_strategy == 'camel':
        return {
            'devices': [
                to_dict(item, casing_strategy)
                for item in data.devices
            ],
            'auxAttributes': data.aux_attributes,
            'featureStatus': data.feature_status,
            'driverBugWorkarounds': [
                item
                for item in data.driver_bug_workarounds
            ],
            'videoDecoding': [
                to_dict(item, casing_strategy)
                for item in data.video_decoding
            ],
            'videoEncoding': [
                to_dict(item, casing_strategy)
                for item in data.video_encoding
            ],
            'imageDecoding': [
                to_dict(item, casing_strategy)
                for item in data.image_decoding
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Devices': [
                to_dict(item, casing_strategy)
                for item in data.devices
            ],
            'AuxAttributes': data.aux_attributes,
            'FeatureStatus': data.feature_status,
            'DriverBugWorkarounds': [
                item
                for item in data.driver_bug_workarounds
            ],
            'VideoDecoding': [
                to_dict(item, casing_strategy)
                for item in data.video_decoding
            ],
            'VideoEncoding': [
                to_dict(item, casing_strategy)
                for item in data.video_encoding
            ],
            'ImageDecoding': [
                to_dict(item, casing_strategy)
                for item in data.image_decoding
            ],
        }


def _map_system_info__process_info__to_dict(data: 'system_info.ProcessInfo', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'id': data.id,
            'cpu_time': data.cpu_time,
        }
    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'id': data.id,
            'cpuTime': data.cpu_time,
        }
    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'Id': data.id,
            'CpuTime': data.cpu_time,
        }


def _map_target__target_info__to_dict(data: 'target.TargetInfo', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'target_id': data.target_id,
            'type': data.type,
            'title': data.title,
            'url': data.url,
            'attached': data.attached,
            'opener_id': data.opener_id,
            'can_access_opener': data.can_access_opener,
            'opener_frame_id': data.opener_frame_id,
            'browser_context_id': data.browser_context_id,
            'subtype': data.subtype,
        }
    if casing_strategy == 'camel':
        return {
            'targetId': data.target_id,
            'type': data.type,
            'title': data.title,
            'url': data.url,
            'attached': data.attached,
            'openerId': data.opener_id,
            'canAccessOpener': data.can_access_opener,
            'openerFrameId': data.opener_frame_id,
            'browserContextId': data.browser_context_id,
            'subtype': data.subtype,
        }
    if casing_strategy == 'pascal':
        return {
            'TargetId': data.target_id,
            'Type': data.type,
            'Title': data.title,
            'Url': data.url,
            'Attached': data.attached,
            'OpenerId': data.opener_id,
            'CanAccessOpener': data.can_access_opener,
            'OpenerFrameId': data.opener_frame_id,
            'BrowserContextId': data.browser_context_id,
            'Subtype': data.subtype,
        }


def _map_target__filter_entry__to_dict(data: 'target.FilterEntry', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'exclude': data.exclude,
            'type': data.type,
        }
    if casing_strategy == 'camel':
        return {
            'exclude': data.exclude,
            'type': data.type,
        }
    if casing_strategy == 'pascal':
        return {
            'Exclude': data.exclude,
            'Type': data.type,
        }


def _map_target__remote_location__to_dict(data: 'target.RemoteLocation', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'host': data.host,
            'port': data.port,
        }
    if casing_strategy == 'camel':
        return {
            'host': data.host,
            'port': data.port,
        }
    if casing_strategy == 'pascal':
        return {
            'Host': data.host,
            'Port': data.port,
        }


def _map_tracing__trace_config__to_dict(data: 'tracing.TraceConfig', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'record_mode': data.record_mode,
            'trace_buffer_size_in_kb': data.trace_buffer_size_in_kb,
            'enable_sampling': data.enable_sampling,
            'enable_systrace': data.enable_systrace,
            'enable_argument_filter': data.enable_argument_filter,
            'included_categories': [
                item
                for item in data.included_categories
            ],
            'excluded_categories': [
                item
                for item in data.excluded_categories
            ],
            'synthetic_delays': [
                item
                for item in data.synthetic_delays
            ],
            'memory_dump_config': data.memory_dump_config,
        }
    if casing_strategy == 'camel':
        return {
            'recordMode': data.record_mode,
            'traceBufferSizeInKb': data.trace_buffer_size_in_kb,
            'enableSampling': data.enable_sampling,
            'enableSystrace': data.enable_systrace,
            'enableArgumentFilter': data.enable_argument_filter,
            'includedCategories': [
                item
                for item in data.included_categories
            ],
            'excludedCategories': [
                item
                for item in data.excluded_categories
            ],
            'syntheticDelays': [
                item
                for item in data.synthetic_delays
            ],
            'memoryDumpConfig': data.memory_dump_config,
        }
    if casing_strategy == 'pascal':
        return {
            'RecordMode': data.record_mode,
            'TraceBufferSizeInKb': data.trace_buffer_size_in_kb,
            'EnableSampling': data.enable_sampling,
            'EnableSystrace': data.enable_systrace,
            'EnableArgumentFilter': data.enable_argument_filter,
            'IncludedCategories': [
                item
                for item in data.included_categories
            ],
            'ExcludedCategories': [
                item
                for item in data.excluded_categories
            ],
            'SyntheticDelays': [
                item
                for item in data.synthetic_delays
            ],
            'MemoryDumpConfig': data.memory_dump_config,
        }


def _map_fetch__request_pattern__to_dict(data: 'fetch.RequestPattern', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'url_pattern': data.url_pattern,
            'resource_type': data.resource_type,
            'request_stage': data.request_stage,
        }
    if casing_strategy == 'camel':
        return {
            'urlPattern': data.url_pattern,
            'resourceType': data.resource_type,
            'requestStage': data.request_stage,
        }
    if casing_strategy == 'pascal':
        return {
            'UrlPattern': data.url_pattern,
            'ResourceType': data.resource_type,
            'RequestStage': data.request_stage,
        }


def _map_fetch__header_entry__to_dict(data: 'fetch.HeaderEntry', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
        }


def _map_fetch__auth_challenge__to_dict(data: 'fetch.AuthChallenge', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'source': data.source,
            'origin': data.origin,
            'scheme': data.scheme,
            'realm': data.realm,
        }
    if casing_strategy == 'camel':
        return {
            'source': data.source,
            'origin': data.origin,
            'scheme': data.scheme,
            'realm': data.realm,
        }
    if casing_strategy == 'pascal':
        return {
            'Source': data.source,
            'Origin': data.origin,
            'Scheme': data.scheme,
            'Realm': data.realm,
        }


def _map_fetch__auth_challenge_response__to_dict(data: 'fetch.AuthChallengeResponse', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'response': data.response,
            'username': data.username,
            'password': data.password,
        }
    if casing_strategy == 'camel':
        return {
            'response': data.response,
            'username': data.username,
            'password': data.password,
        }
    if casing_strategy == 'pascal':
        return {
            'Response': data.response,
            'Username': data.username,
            'Password': data.password,
        }


def _map_web_audio__context_realtime_data__to_dict(data: 'web_audio.ContextRealtimeData', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'current_time': data.current_time,
            'render_capacity': data.render_capacity,
            'callback_interval_mean': data.callback_interval_mean,
            'callback_interval_variance': data.callback_interval_variance,
        }
    if casing_strategy == 'camel':
        return {
            'currentTime': data.current_time,
            'renderCapacity': data.render_capacity,
            'callbackIntervalMean': data.callback_interval_mean,
            'callbackIntervalVariance': data.callback_interval_variance,
        }
    if casing_strategy == 'pascal':
        return {
            'CurrentTime': data.current_time,
            'RenderCapacity': data.render_capacity,
            'CallbackIntervalMean': data.callback_interval_mean,
            'CallbackIntervalVariance': data.callback_interval_variance,
        }


def _map_web_audio__base_audio_context__to_dict(data: 'web_audio.BaseAudioContext', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'context_id': data.context_id,
            'context_type': data.context_type,
            'context_state': data.context_state,
            'realtime_data': to_dict(
                data.realtime_data,
                casing_strategy
            ),
            'callback_buffer_size': data.callback_buffer_size,
            'max_output_channel_count': data.max_output_channel_count,
            'sample_rate': data.sample_rate,
        }
    if casing_strategy == 'camel':
        return {
            'contextId': data.context_id,
            'contextType': data.context_type,
            'contextState': data.context_state,
            'realtimeData': to_dict(
                data.realtime_data,
                casing_strategy
            ),
            'callbackBufferSize': data.callback_buffer_size,
            'maxOutputChannelCount': data.max_output_channel_count,
            'sampleRate': data.sample_rate,
        }
    if casing_strategy == 'pascal':
        return {
            'ContextId': data.context_id,
            'ContextType': data.context_type,
            'ContextState': data.context_state,
            'RealtimeData': to_dict(
                data.realtime_data,
                casing_strategy
            ),
            'CallbackBufferSize': data.callback_buffer_size,
            'MaxOutputChannelCount': data.max_output_channel_count,
            'SampleRate': data.sample_rate,
        }


def _map_web_audio__audio_listener__to_dict(data: 'web_audio.AudioListener', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'listener_id': data.listener_id,
            'context_id': data.context_id,
        }
    if casing_strategy == 'camel':
        return {
            'listenerId': data.listener_id,
            'contextId': data.context_id,
        }
    if casing_strategy == 'pascal':
        return {
            'ListenerId': data.listener_id,
            'ContextId': data.context_id,
        }


def _map_web_audio__audio_node__to_dict(data: 'web_audio.AudioNode', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'node_id': data.node_id,
            'context_id': data.context_id,
            'node_type': data.node_type,
            'number_of_inputs': data.number_of_inputs,
            'number_of_outputs': data.number_of_outputs,
            'channel_count': data.channel_count,
            'channel_count_mode': data.channel_count_mode,
            'channel_interpretation': data.channel_interpretation,
        }
    if casing_strategy == 'camel':
        return {
            'nodeId': data.node_id,
            'contextId': data.context_id,
            'nodeType': data.node_type,
            'numberOfInputs': data.number_of_inputs,
            'numberOfOutputs': data.number_of_outputs,
            'channelCount': data.channel_count,
            'channelCountMode': data.channel_count_mode,
            'channelInterpretation': data.channel_interpretation,
        }
    if casing_strategy == 'pascal':
        return {
            'NodeId': data.node_id,
            'ContextId': data.context_id,
            'NodeType': data.node_type,
            'NumberOfInputs': data.number_of_inputs,
            'NumberOfOutputs': data.number_of_outputs,
            'ChannelCount': data.channel_count,
            'ChannelCountMode': data.channel_count_mode,
            'ChannelInterpretation': data.channel_interpretation,
        }


def _map_web_audio__audio_param__to_dict(data: 'web_audio.AudioParam', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'param_id': data.param_id,
            'node_id': data.node_id,
            'context_id': data.context_id,
            'param_type': data.param_type,
            'rate': data.rate,
            'default_value': data.default_value,
            'min_value': data.min_value,
            'max_value': data.max_value,
        }
    if casing_strategy == 'camel':
        return {
            'paramId': data.param_id,
            'nodeId': data.node_id,
            'contextId': data.context_id,
            'paramType': data.param_type,
            'rate': data.rate,
            'defaultValue': data.default_value,
            'minValue': data.min_value,
            'maxValue': data.max_value,
        }
    if casing_strategy == 'pascal':
        return {
            'ParamId': data.param_id,
            'NodeId': data.node_id,
            'ContextId': data.context_id,
            'ParamType': data.param_type,
            'Rate': data.rate,
            'DefaultValue': data.default_value,
            'MinValue': data.min_value,
            'MaxValue': data.max_value,
        }


def _map_web_authn__virtual_authenticator_options__to_dict(data: 'web_authn.VirtualAuthenticatorOptions', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'protocol': data.protocol,
            'ctap2_version': data.ctap2_version,
            'transport': data.transport,
            'has_resident_key': data.has_resident_key,
            'has_user_verification': data.has_user_verification,
            'has_large_blob': data.has_large_blob,
            'has_cred_blob': data.has_cred_blob,
            'has_min_pin_length': data.has_min_pin_length,
            'has_prf': data.has_prf,
            'automatic_presence_simulation': data.automatic_presence_simulation,
            'is_user_verified': data.is_user_verified,
        }
    if casing_strategy == 'camel':
        return {
            'protocol': data.protocol,
            'ctap2Version': data.ctap2_version,
            'transport': data.transport,
            'hasResidentKey': data.has_resident_key,
            'hasUserVerification': data.has_user_verification,
            'hasLargeBlob': data.has_large_blob,
            'hasCredBlob': data.has_cred_blob,
            'hasMinPinLength': data.has_min_pin_length,
            'hasPrf': data.has_prf,
            'automaticPresenceSimulation': data.automatic_presence_simulation,
            'isUserVerified': data.is_user_verified,
        }
    if casing_strategy == 'pascal':
        return {
            'Protocol': data.protocol,
            'Ctap2Version': data.ctap2_version,
            'Transport': data.transport,
            'HasResidentKey': data.has_resident_key,
            'HasUserVerification': data.has_user_verification,
            'HasLargeBlob': data.has_large_blob,
            'HasCredBlob': data.has_cred_blob,
            'HasMinPinLength': data.has_min_pin_length,
            'HasPrf': data.has_prf,
            'AutomaticPresenceSimulation': data.automatic_presence_simulation,
            'IsUserVerified': data.is_user_verified,
        }


def _map_web_authn__credential__to_dict(data: 'web_authn.Credential', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'credential_id': data.credential_id,
            'is_resident_credential': data.is_resident_credential,
            'rp_id': data.rp_id,
            'private_key': data.private_key,
            'user_handle': data.user_handle,
            'sign_count': data.sign_count,
            'large_blob': data.large_blob,
        }
    if casing_strategy == 'camel':
        return {
            'credentialId': data.credential_id,
            'isResidentCredential': data.is_resident_credential,
            'rpId': data.rp_id,
            'privateKey': data.private_key,
            'userHandle': data.user_handle,
            'signCount': data.sign_count,
            'largeBlob': data.large_blob,
        }
    if casing_strategy == 'pascal':
        return {
            'CredentialId': data.credential_id,
            'IsResidentCredential': data.is_resident_credential,
            'RpId': data.rp_id,
            'PrivateKey': data.private_key,
            'UserHandle': data.user_handle,
            'SignCount': data.sign_count,
            'LargeBlob': data.large_blob,
        }


def _map_media__player_message__to_dict(data: 'media.PlayerMessage', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'level': data.level,
            'message': data.message,
        }
    if casing_strategy == 'camel':
        return {
            'level': data.level,
            'message': data.message,
        }
    if casing_strategy == 'pascal':
        return {
            'Level': data.level,
            'Message': data.message,
        }


def _map_media__player_property__to_dict(data: 'media.PlayerProperty', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
        }


def _map_media__player_event__to_dict(data: 'media.PlayerEvent', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'timestamp': data.timestamp,
            'value': data.value,
        }
    if casing_strategy == 'camel':
        return {
            'timestamp': data.timestamp,
            'value': data.value,
        }
    if casing_strategy == 'pascal':
        return {
            'Timestamp': data.timestamp,
            'Value': data.value,
        }


def _map_media__player_error_source_location__to_dict(data: 'media.PlayerErrorSourceLocation', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'file': data.file,
            'line': data.line,
        }
    if casing_strategy == 'camel':
        return {
            'file': data.file,
            'line': data.line,
        }
    if casing_strategy == 'pascal':
        return {
            'File': data.file,
            'Line': data.line,
        }


def _map_media__player_error__to_dict(data: 'media.PlayerError', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'error_type': data.error_type,
            'code': data.code,
            'stack': [
                to_dict(item, casing_strategy)
                for item in data.stack
            ],
            'cause': [
                to_dict(item, casing_strategy)
                for item in data.cause
            ],
            'data': data.data,
        }
    if casing_strategy == 'camel':
        return {
            'errorType': data.error_type,
            'code': data.code,
            'stack': [
                to_dict(item, casing_strategy)
                for item in data.stack
            ],
            'cause': [
                to_dict(item, casing_strategy)
                for item in data.cause
            ],
            'data': data.data,
        }
    if casing_strategy == 'pascal':
        return {
            'ErrorType': data.error_type,
            'Code': data.code,
            'Stack': [
                to_dict(item, casing_strategy)
                for item in data.stack
            ],
            'Cause': [
                to_dict(item, casing_strategy)
                for item in data.cause
            ],
            'Data': data.data,
        }


def _map_device_access__prompt_device__to_dict(data: 'device_access.PromptDevice', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'id': data.id,
            'name': data.name,
        }
    if casing_strategy == 'camel':
        return {
            'id': data.id,
            'name': data.name,
        }
    if casing_strategy == 'pascal':
        return {
            'Id': data.id,
            'Name': data.name,
        }


def _map_preload__rule_set__to_dict(data: 'preload.RuleSet', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'id': data.id,
            'loader_id': data.loader_id,
            'source_text': data.source_text,
            'backend_node_id': data.backend_node_id,
            'url': data.url,
            'request_id': data.request_id,
            'error_type': data.error_type,
            'error_message': data.error_message,
        }
    if casing_strategy == 'camel':
        return {
            'id': data.id,
            'loaderId': data.loader_id,
            'sourceText': data.source_text,
            'backendNodeId': data.backend_node_id,
            'url': data.url,
            'requestId': data.request_id,
            'errorType': data.error_type,
            'errorMessage': data.error_message,
        }
    if casing_strategy == 'pascal':
        return {
            'Id': data.id,
            'LoaderId': data.loader_id,
            'SourceText': data.source_text,
            'BackendNodeId': data.backend_node_id,
            'Url': data.url,
            'RequestId': data.request_id,
            'ErrorType': data.error_type,
            'ErrorMessage': data.error_message,
        }


def _map_preload__preloading_attempt_key__to_dict(data: 'preload.PreloadingAttemptKey', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'loader_id': data.loader_id,
            'action': data.action,
            'url': data.url,
            'target_hint': data.target_hint,
        }
    if casing_strategy == 'camel':
        return {
            'loaderId': data.loader_id,
            'action': data.action,
            'url': data.url,
            'targetHint': data.target_hint,
        }
    if casing_strategy == 'pascal':
        return {
            'LoaderId': data.loader_id,
            'Action': data.action,
            'Url': data.url,
            'TargetHint': data.target_hint,
        }


def _map_preload__preloading_attempt_source__to_dict(data: 'preload.PreloadingAttemptSource', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'key': to_dict(
                data.key,
                casing_strategy
            ),
            'rule_set_ids': [
                item
                for item in data.rule_set_ids
            ],
            'node_ids': [
                item
                for item in data.node_ids
            ],
        }
    if casing_strategy == 'camel':
        return {
            'key': to_dict(
                data.key,
                casing_strategy
            ),
            'ruleSetIds': [
                item
                for item in data.rule_set_ids
            ],
            'nodeIds': [
                item
                for item in data.node_ids
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Key': to_dict(
                data.key,
                casing_strategy
            ),
            'RuleSetIds': [
                item
                for item in data.rule_set_ids
            ],
            'NodeIds': [
                item
                for item in data.node_ids
            ],
        }


def _map_fed_cm__account__to_dict(data: 'fed_cm.Account', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'account_id': data.account_id,
            'email': data.email,
            'name': data.name,
            'given_name': data.given_name,
            'picture_url': data.picture_url,
            'idp_config_url': data.idp_config_url,
            'idp_signin_url': data.idp_signin_url,
            'login_state': data.login_state,
            'terms_of_service_url': data.terms_of_service_url,
            'privacy_policy_url': data.privacy_policy_url,
        }
    if casing_strategy == 'camel':
        return {
            'accountId': data.account_id,
            'email': data.email,
            'name': data.name,
            'givenName': data.given_name,
            'pictureUrl': data.picture_url,
            'idpConfigUrl': data.idp_config_url,
            'idpSigninUrl': data.idp_signin_url,
            'loginState': data.login_state,
            'termsOfServiceUrl': data.terms_of_service_url,
            'privacyPolicyUrl': data.privacy_policy_url,
        }
    if casing_strategy == 'pascal':
        return {
            'AccountId': data.account_id,
            'Email': data.email,
            'Name': data.name,
            'GivenName': data.given_name,
            'PictureUrl': data.picture_url,
            'IdpConfigUrl': data.idp_config_url,
            'IdpSigninUrl': data.idp_signin_url,
            'LoginState': data.login_state,
            'TermsOfServiceUrl': data.terms_of_service_url,
            'PrivacyPolicyUrl': data.privacy_policy_url,
        }


def _map_console__console_message__to_dict(data: 'console.ConsoleMessage', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'source': data.source,
            'level': data.level,
            'text': data.text,
            'url': data.url,
            'line': data.line,
            'column': data.column,
        }
    if casing_strategy == 'camel':
        return {
            'source': data.source,
            'level': data.level,
            'text': data.text,
            'url': data.url,
            'line': data.line,
            'column': data.column,
        }
    if casing_strategy == 'pascal':
        return {
            'Source': data.source,
            'Level': data.level,
            'Text': data.text,
            'Url': data.url,
            'Line': data.line,
            'Column': data.column,
        }


def _map_debugger__location__to_dict(data: 'debugger.Location', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'script_id': data.script_id,
            'line_number': data.line_number,
            'column_number': data.column_number,
        }
    if casing_strategy == 'camel':
        return {
            'scriptId': data.script_id,
            'lineNumber': data.line_number,
            'columnNumber': data.column_number,
        }
    if casing_strategy == 'pascal':
        return {
            'ScriptId': data.script_id,
            'LineNumber': data.line_number,
            'ColumnNumber': data.column_number,
        }


def _map_debugger__script_position__to_dict(data: 'debugger.ScriptPosition', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'line_number': data.line_number,
            'column_number': data.column_number,
        }
    if casing_strategy == 'camel':
        return {
            'lineNumber': data.line_number,
            'columnNumber': data.column_number,
        }
    if casing_strategy == 'pascal':
        return {
            'LineNumber': data.line_number,
            'ColumnNumber': data.column_number,
        }


def _map_debugger__call_frame__to_dict(data: 'debugger.CallFrame', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'call_frame_id': data.call_frame_id,
            'function_name': data.function_name,
            'function_location': to_dict(
                data.function_location,
                casing_strategy
            ),
            'location': to_dict(
                data.location,
                casing_strategy
            ),
            'url': data.url,
            'scope_chain': [
                to_dict(item, casing_strategy)
                for item in data.scope_chain
            ],
            'this': to_dict(
                data.this,
                casing_strategy
            ),
            'return_value': to_dict(
                data.return_value,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'callFrameId': data.call_frame_id,
            'functionName': data.function_name,
            'functionLocation': to_dict(
                data.function_location,
                casing_strategy
            ),
            'location': to_dict(
                data.location,
                casing_strategy
            ),
            'url': data.url,
            'scopeChain': [
                to_dict(item, casing_strategy)
                for item in data.scope_chain
            ],
            'this': to_dict(
                data.this,
                casing_strategy
            ),
            'returnValue': to_dict(
                data.return_value,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'CallFrameId': data.call_frame_id,
            'FunctionName': data.function_name,
            'FunctionLocation': to_dict(
                data.function_location,
                casing_strategy
            ),
            'Location': to_dict(
                data.location,
                casing_strategy
            ),
            'Url': data.url,
            'ScopeChain': [
                to_dict(item, casing_strategy)
                for item in data.scope_chain
            ],
            'This': to_dict(
                data.this,
                casing_strategy
            ),
            'ReturnValue': to_dict(
                data.return_value,
                casing_strategy
            ),
        }


def _map_debugger__scope__to_dict(data: 'debugger.Scope', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'object': to_dict(
                data.object,
                casing_strategy
            ),
            'name': data.name,
            'start_location': to_dict(
                data.start_location,
                casing_strategy
            ),
            'end_location': to_dict(
                data.end_location,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'object': to_dict(
                data.object,
                casing_strategy
            ),
            'name': data.name,
            'startLocation': to_dict(
                data.start_location,
                casing_strategy
            ),
            'endLocation': to_dict(
                data.end_location,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'Object': to_dict(
                data.object,
                casing_strategy
            ),
            'Name': data.name,
            'StartLocation': to_dict(
                data.start_location,
                casing_strategy
            ),
            'EndLocation': to_dict(
                data.end_location,
                casing_strategy
            ),
        }


def _map_debugger__search_match__to_dict(data: 'debugger.SearchMatch', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'line_number': data.line_number,
            'line_content': data.line_content,
        }
    if casing_strategy == 'camel':
        return {
            'lineNumber': data.line_number,
            'lineContent': data.line_content,
        }
    if casing_strategy == 'pascal':
        return {
            'LineNumber': data.line_number,
            'LineContent': data.line_content,
        }


def _map_debugger__break_location__to_dict(data: 'debugger.BreakLocation', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'script_id': data.script_id,
            'line_number': data.line_number,
            'column_number': data.column_number,
            'type': data.type,
        }
    if casing_strategy == 'camel':
        return {
            'scriptId': data.script_id,
            'lineNumber': data.line_number,
            'columnNumber': data.column_number,
            'type': data.type,
        }
    if casing_strategy == 'pascal':
        return {
            'ScriptId': data.script_id,
            'LineNumber': data.line_number,
            'ColumnNumber': data.column_number,
            'Type': data.type,
        }


def _map_heap_profiler__sampling_heap_profile_node__to_dict(data: 'heap_profiler.SamplingHeapProfileNode', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'call_frame': to_dict(
                data.call_frame,
                casing_strategy
            ),
            'self_size': data.self_size,
            'id': data.id,
            'children': [
                to_dict(item, casing_strategy)
                for item in data.children
            ],
        }
    if casing_strategy == 'camel':
        return {
            'callFrame': to_dict(
                data.call_frame,
                casing_strategy
            ),
            'selfSize': data.self_size,
            'id': data.id,
            'children': [
                to_dict(item, casing_strategy)
                for item in data.children
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'CallFrame': to_dict(
                data.call_frame,
                casing_strategy
            ),
            'SelfSize': data.self_size,
            'Id': data.id,
            'Children': [
                to_dict(item, casing_strategy)
                for item in data.children
            ],
        }


def _map_heap_profiler__sampling_heap_profile_sample__to_dict(data: 'heap_profiler.SamplingHeapProfileSample', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'size': data.size,
            'node_id': data.node_id,
            'ordinal': data.ordinal,
        }
    if casing_strategy == 'camel':
        return {
            'size': data.size,
            'nodeId': data.node_id,
            'ordinal': data.ordinal,
        }
    if casing_strategy == 'pascal':
        return {
            'Size': data.size,
            'NodeId': data.node_id,
            'Ordinal': data.ordinal,
        }


def _map_heap_profiler__sampling_heap_profile__to_dict(data: 'heap_profiler.SamplingHeapProfile', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'head': to_dict(
                data.head,
                casing_strategy
            ),
            'samples': [
                to_dict(item, casing_strategy)
                for item in data.samples
            ],
        }
    if casing_strategy == 'camel':
        return {
            'head': to_dict(
                data.head,
                casing_strategy
            ),
            'samples': [
                to_dict(item, casing_strategy)
                for item in data.samples
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Head': to_dict(
                data.head,
                casing_strategy
            ),
            'Samples': [
                to_dict(item, casing_strategy)
                for item in data.samples
            ],
        }


def _map_profiler__profile_node__to_dict(data: 'profiler.ProfileNode', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'id': data.id,
            'call_frame': to_dict(
                data.call_frame,
                casing_strategy
            ),
            'hit_count': data.hit_count,
            'children': [
                item
                for item in data.children
            ],
            'deopt_reason': data.deopt_reason,
            'position_ticks': [
                to_dict(item, casing_strategy)
                for item in data.position_ticks
            ],
        }
    if casing_strategy == 'camel':
        return {
            'id': data.id,
            'callFrame': to_dict(
                data.call_frame,
                casing_strategy
            ),
            'hitCount': data.hit_count,
            'children': [
                item
                for item in data.children
            ],
            'deoptReason': data.deopt_reason,
            'positionTicks': [
                to_dict(item, casing_strategy)
                for item in data.position_ticks
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Id': data.id,
            'CallFrame': to_dict(
                data.call_frame,
                casing_strategy
            ),
            'HitCount': data.hit_count,
            'Children': [
                item
                for item in data.children
            ],
            'DeoptReason': data.deopt_reason,
            'PositionTicks': [
                to_dict(item, casing_strategy)
                for item in data.position_ticks
            ],
        }


def _map_profiler__profile__to_dict(data: 'profiler.Profile', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'nodes': [
                to_dict(item, casing_strategy)
                for item in data.nodes
            ],
            'start_time': data.start_time,
            'end_time': data.end_time,
            'samples': [
                item
                for item in data.samples
            ],
            'time_deltas': [
                item
                for item in data.time_deltas
            ],
        }
    if casing_strategy == 'camel':
        return {
            'nodes': [
                to_dict(item, casing_strategy)
                for item in data.nodes
            ],
            'startTime': data.start_time,
            'endTime': data.end_time,
            'samples': [
                item
                for item in data.samples
            ],
            'timeDeltas': [
                item
                for item in data.time_deltas
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Nodes': [
                to_dict(item, casing_strategy)
                for item in data.nodes
            ],
            'StartTime': data.start_time,
            'EndTime': data.end_time,
            'Samples': [
                item
                for item in data.samples
            ],
            'TimeDeltas': [
                item
                for item in data.time_deltas
            ],
        }


def _map_profiler__position_tick_info__to_dict(data: 'profiler.PositionTickInfo', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'line': data.line,
            'ticks': data.ticks,
        }
    if casing_strategy == 'camel':
        return {
            'line': data.line,
            'ticks': data.ticks,
        }
    if casing_strategy == 'pascal':
        return {
            'Line': data.line,
            'Ticks': data.ticks,
        }


def _map_profiler__coverage_range__to_dict(data: 'profiler.CoverageRange', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'start_offset': data.start_offset,
            'end_offset': data.end_offset,
            'count': data.count,
        }
    if casing_strategy == 'camel':
        return {
            'startOffset': data.start_offset,
            'endOffset': data.end_offset,
            'count': data.count,
        }
    if casing_strategy == 'pascal':
        return {
            'StartOffset': data.start_offset,
            'EndOffset': data.end_offset,
            'Count': data.count,
        }


def _map_profiler__function_coverage__to_dict(data: 'profiler.FunctionCoverage', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'function_name': data.function_name,
            'ranges': [
                to_dict(item, casing_strategy)
                for item in data.ranges
            ],
            'is_block_coverage': data.is_block_coverage,
        }
    if casing_strategy == 'camel':
        return {
            'functionName': data.function_name,
            'ranges': [
                to_dict(item, casing_strategy)
                for item in data.ranges
            ],
            'isBlockCoverage': data.is_block_coverage,
        }
    if casing_strategy == 'pascal':
        return {
            'FunctionName': data.function_name,
            'Ranges': [
                to_dict(item, casing_strategy)
                for item in data.ranges
            ],
            'IsBlockCoverage': data.is_block_coverage,
        }


def _map_profiler__script_coverage__to_dict(data: 'profiler.ScriptCoverage', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'script_id': data.script_id,
            'url': data.url,
            'functions': [
                to_dict(item, casing_strategy)
                for item in data.functions
            ],
        }
    if casing_strategy == 'camel':
        return {
            'scriptId': data.script_id,
            'url': data.url,
            'functions': [
                to_dict(item, casing_strategy)
                for item in data.functions
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'ScriptId': data.script_id,
            'Url': data.url,
            'Functions': [
                to_dict(item, casing_strategy)
                for item in data.functions
            ],
        }


def _map_profiler__type_object__to_dict(data: 'profiler.TypeObject', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
        }


def _map_profiler__type_profile_entry__to_dict(data: 'profiler.TypeProfileEntry', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'offset': data.offset,
            'types': [
                to_dict(item, casing_strategy)
                for item in data.types
            ],
        }
    if casing_strategy == 'camel':
        return {
            'offset': data.offset,
            'types': [
                to_dict(item, casing_strategy)
                for item in data.types
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Offset': data.offset,
            'Types': [
                to_dict(item, casing_strategy)
                for item in data.types
            ],
        }


def _map_profiler__script_type_profile__to_dict(data: 'profiler.ScriptTypeProfile', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'script_id': data.script_id,
            'url': data.url,
            'entries': [
                to_dict(item, casing_strategy)
                for item in data.entries
            ],
        }
    if casing_strategy == 'camel':
        return {
            'scriptId': data.script_id,
            'url': data.url,
            'entries': [
                to_dict(item, casing_strategy)
                for item in data.entries
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'ScriptId': data.script_id,
            'Url': data.url,
            'Entries': [
                to_dict(item, casing_strategy)
                for item in data.entries
            ],
        }


def _map_runtime__remote_object__to_dict(data: 'runtime.RemoteObject', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'subtype': data.subtype,
            'class_name': data.class_name,
            'value': data.value,
            'unserializable_value': data.unserializable_value,
            'description': data.description,
            'object_id': data.object_id,
            'preview': to_dict(
                data.preview,
                casing_strategy
            ),
            'custom_preview': to_dict(
                data.custom_preview,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'subtype': data.subtype,
            'className': data.class_name,
            'value': data.value,
            'unserializableValue': data.unserializable_value,
            'description': data.description,
            'objectId': data.object_id,
            'preview': to_dict(
                data.preview,
                casing_strategy
            ),
            'customPreview': to_dict(
                data.custom_preview,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'Subtype': data.subtype,
            'ClassName': data.class_name,
            'Value': data.value,
            'UnserializableValue': data.unserializable_value,
            'Description': data.description,
            'ObjectId': data.object_id,
            'Preview': to_dict(
                data.preview,
                casing_strategy
            ),
            'CustomPreview': to_dict(
                data.custom_preview,
                casing_strategy
            ),
        }


def _map_runtime__custom_preview__to_dict(data: 'runtime.CustomPreview', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'header': data.header,
            'body_getter_id': data.body_getter_id,
        }
    if casing_strategy == 'camel':
        return {
            'header': data.header,
            'bodyGetterId': data.body_getter_id,
        }
    if casing_strategy == 'pascal':
        return {
            'Header': data.header,
            'BodyGetterId': data.body_getter_id,
        }


def _map_runtime__object_preview__to_dict(data: 'runtime.ObjectPreview', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'subtype': data.subtype,
            'description': data.description,
            'overflow': data.overflow,
            'properties': [
                to_dict(item, casing_strategy)
                for item in data.properties
            ],
            'entries': [
                to_dict(item, casing_strategy)
                for item in data.entries
            ],
        }
    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'subtype': data.subtype,
            'description': data.description,
            'overflow': data.overflow,
            'properties': [
                to_dict(item, casing_strategy)
                for item in data.properties
            ],
            'entries': [
                to_dict(item, casing_strategy)
                for item in data.entries
            ],
        }
    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'Subtype': data.subtype,
            'Description': data.description,
            'Overflow': data.overflow,
            'Properties': [
                to_dict(item, casing_strategy)
                for item in data.properties
            ],
            'Entries': [
                to_dict(item, casing_strategy)
                for item in data.entries
            ],
        }


def _map_runtime__property_preview__to_dict(data: 'runtime.PropertyPreview', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'type': data.type,
            'value': data.value,
            'value_preview': to_dict(
                data.value_preview,
                casing_strategy
            ),
            'subtype': data.subtype,
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'type': data.type,
            'value': data.value,
            'valuePreview': to_dict(
                data.value_preview,
                casing_strategy
            ),
            'subtype': data.subtype,
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Type': data.type,
            'Value': data.value,
            'ValuePreview': to_dict(
                data.value_preview,
                casing_strategy
            ),
            'Subtype': data.subtype,
        }


def _map_runtime__entry_preview__to_dict(data: 'runtime.EntryPreview', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'key': to_dict(
                data.key,
                casing_strategy
            ),
            'value': to_dict(
                data.value,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'key': to_dict(
                data.key,
                casing_strategy
            ),
            'value': to_dict(
                data.value,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'Key': to_dict(
                data.key,
                casing_strategy
            ),
            'Value': to_dict(
                data.value,
                casing_strategy
            ),
        }


def _map_runtime__property_descriptor__to_dict(data: 'runtime.PropertyDescriptor', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': to_dict(
                data.value,
                casing_strategy
            ),
            'writable': data.writable,
            'get': to_dict(
                data.get,
                casing_strategy
            ),
            'set': to_dict(
                data.set,
                casing_strategy
            ),
            'configurable': data.configurable,
            'enumerable': data.enumerable,
            'was_thrown': data.was_thrown,
            'is_own': data.is_own,
            'symbol': to_dict(
                data.symbol,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': to_dict(
                data.value,
                casing_strategy
            ),
            'writable': data.writable,
            'get': to_dict(
                data.get,
                casing_strategy
            ),
            'set': to_dict(
                data.set,
                casing_strategy
            ),
            'configurable': data.configurable,
            'enumerable': data.enumerable,
            'wasThrown': data.was_thrown,
            'isOwn': data.is_own,
            'symbol': to_dict(
                data.symbol,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': to_dict(
                data.value,
                casing_strategy
            ),
            'Writable': data.writable,
            'Get': to_dict(
                data.get,
                casing_strategy
            ),
            'Set': to_dict(
                data.set,
                casing_strategy
            ),
            'Configurable': data.configurable,
            'Enumerable': data.enumerable,
            'WasThrown': data.was_thrown,
            'IsOwn': data.is_own,
            'Symbol': to_dict(
                data.symbol,
                casing_strategy
            ),
        }


def _map_runtime__internal_property_descriptor__to_dict(data: 'runtime.InternalPropertyDescriptor', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': to_dict(
                data.value,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': to_dict(
                data.value,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': to_dict(
                data.value,
                casing_strategy
            ),
        }


def _map_runtime__private_property_descriptor__to_dict(data: 'runtime.PrivatePropertyDescriptor', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': to_dict(
                data.value,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': to_dict(
                data.value,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': to_dict(
                data.value,
                casing_strategy
            ),
        }


def _map_runtime__call_argument__to_dict(data: 'runtime.CallArgument', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'value': data.value,
            'unserializable_value': data.unserializable_value,
            'object_id': data.object_id,
        }
    if casing_strategy == 'camel':
        return {
            'value': data.value,
            'unserializableValue': data.unserializable_value,
            'objectId': data.object_id,
        }
    if casing_strategy == 'pascal':
        return {
            'Value': data.value,
            'UnserializableValue': data.unserializable_value,
            'ObjectId': data.object_id,
        }


def _map_runtime__execution_context_description__to_dict(data: 'runtime.ExecutionContextDescription', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'id': data.id,
            'origin': data.origin,
            'name': data.name,
            'aux_data': data.aux_data,
        }
    if casing_strategy == 'camel':
        return {
            'id': data.id,
            'origin': data.origin,
            'name': data.name,
            'auxData': data.aux_data,
        }
    if casing_strategy == 'pascal':
        return {
            'Id': data.id,
            'Origin': data.origin,
            'Name': data.name,
            'AuxData': data.aux_data,
        }


def _map_runtime__exception_details__to_dict(data: 'runtime.ExceptionDetails', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'exception_id': data.exception_id,
            'text': data.text,
            'line_number': data.line_number,
            'column_number': data.column_number,
            'script_id': data.script_id,
            'url': data.url,
            'stack_trace': to_dict(
                data.stack_trace,
                casing_strategy
            ),
            'exception': to_dict(
                data.exception,
                casing_strategy
            ),
            'execution_context_id': data.execution_context_id,
        }
    if casing_strategy == 'camel':
        return {
            'exceptionId': data.exception_id,
            'text': data.text,
            'lineNumber': data.line_number,
            'columnNumber': data.column_number,
            'scriptId': data.script_id,
            'url': data.url,
            'stackTrace': to_dict(
                data.stack_trace,
                casing_strategy
            ),
            'exception': to_dict(
                data.exception,
                casing_strategy
            ),
            'executionContextId': data.execution_context_id,
        }
    if casing_strategy == 'pascal':
        return {
            'ExceptionId': data.exception_id,
            'Text': data.text,
            'LineNumber': data.line_number,
            'ColumnNumber': data.column_number,
            'ScriptId': data.script_id,
            'Url': data.url,
            'StackTrace': to_dict(
                data.stack_trace,
                casing_strategy
            ),
            'Exception': to_dict(
                data.exception,
                casing_strategy
            ),
            'ExecutionContextId': data.execution_context_id,
        }


def _map_runtime__call_frame__to_dict(data: 'runtime.CallFrame', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'function_name': data.function_name,
            'script_id': data.script_id,
            'url': data.url,
            'line_number': data.line_number,
            'column_number': data.column_number,
        }
    if casing_strategy == 'camel':
        return {
            'functionName': data.function_name,
            'scriptId': data.script_id,
            'url': data.url,
            'lineNumber': data.line_number,
            'columnNumber': data.column_number,
        }
    if casing_strategy == 'pascal':
        return {
            'FunctionName': data.function_name,
            'ScriptId': data.script_id,
            'Url': data.url,
            'LineNumber': data.line_number,
            'ColumnNumber': data.column_number,
        }


def _map_runtime__stack_trace__to_dict(data: 'runtime.StackTrace', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'description': data.description,
            'call_frames': [
                to_dict(item, casing_strategy)
                for item in data.call_frames
            ],
            'parent': to_dict(
                data.parent,
                casing_strategy
            ),
            'parent_id': to_dict(
                data.parent_id,
                casing_strategy
            ),
        }
    if casing_strategy == 'camel':
        return {
            'description': data.description,
            'callFrames': [
                to_dict(item, casing_strategy)
                for item in data.call_frames
            ],
            'parent': to_dict(
                data.parent,
                casing_strategy
            ),
            'parentId': to_dict(
                data.parent_id,
                casing_strategy
            ),
        }
    if casing_strategy == 'pascal':
        return {
            'Description': data.description,
            'CallFrames': [
                to_dict(item, casing_strategy)
                for item in data.call_frames
            ],
            'Parent': to_dict(
                data.parent,
                casing_strategy
            ),
            'ParentId': to_dict(
                data.parent_id,
                casing_strategy
            ),
        }


def _map_runtime__stack_trace_id__to_dict(data: 'runtime.StackTraceId', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'id': data.id,
            'debugger_id': data.debugger_id,
        }
    if casing_strategy == 'camel':
        return {
            'id': data.id,
            'debuggerId': data.debugger_id,
        }
    if casing_strategy == 'pascal':
        return {
            'Id': data.id,
            'DebuggerId': data.debugger_id,
        }


def _map_schema__domain__to_dict(data: 'schema.Domain', casing_strategy: 'CasingStrategyT' = 'snake') -> dict:
    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'version': data.version,
        }
    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'version': data.version,
        }
    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Version': data.version,
        }


def _map_accessibility__ax_node_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'accessibility.AXNodeId':
    pass


def _map_accessibility__ax_value_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'accessibility.AXValueType':
    pass


def _map_accessibility__ax_value_source_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'accessibility.AXValueSourceType':
    pass


def _map_accessibility__ax_value_native_source_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'accessibility.AXValueNativeSourceType':
    pass


def _map_accessibility__ax_value_source__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'accessibility.AXValueSource':
    pass


def _map_accessibility__ax_related_node__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'accessibility.AXRelatedNode':
    pass


def _map_accessibility__ax_property__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'accessibility.AXProperty':
    pass


def _map_accessibility__ax_value__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'accessibility.AXValue':
    pass


def _map_accessibility__ax_property_name__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'accessibility.AXPropertyName':
    pass


def _map_accessibility__ax_node__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'accessibility.AXNode':
    pass


def _map_animation__animation__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'animation.Animation':
    pass


def _map_animation__animation_effect__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'animation.AnimationEffect':
    pass


def _map_animation__keyframes_rule__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'animation.KeyframesRule':
    pass


def _map_animation__keyframe_style__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'animation.KeyframeStyle':
    pass


def _map_audits__affected_cookie__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.AffectedCookie':
    pass


def _map_audits__affected_request__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.AffectedRequest':
    pass


def _map_audits__affected_frame__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.AffectedFrame':
    pass


def _map_audits__cookie_exclusion_reason__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.CookieExclusionReason':
    pass


def _map_audits__cookie_warning_reason__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.CookieWarningReason':
    pass


def _map_audits__cookie_operation__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.CookieOperation':
    pass


def _map_audits__cookie_issue_details__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.CookieIssueDetails':
    pass


def _map_audits__mixed_content_resolution_status__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.MixedContentResolutionStatus':
    pass


def _map_audits__mixed_content_resource_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.MixedContentResourceType':
    pass


def _map_audits__mixed_content_issue_details__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.MixedContentIssueDetails':
    pass


def _map_audits__blocked_by_response_reason__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.BlockedByResponseReason':
    pass


def _map_audits__blocked_by_response_issue_details__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.BlockedByResponseIssueDetails':
    pass


def _map_audits__heavy_ad_resolution_status__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.HeavyAdResolutionStatus':
    pass


def _map_audits__heavy_ad_reason__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.HeavyAdReason':
    pass


def _map_audits__heavy_ad_issue_details__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.HeavyAdIssueDetails':
    pass


def _map_audits__content_security_policy_violation_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.ContentSecurityPolicyViolationType':
    pass


def _map_audits__source_code_location__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.SourceCodeLocation':
    pass


def _map_audits__content_security_policy_issue_details__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.ContentSecurityPolicyIssueDetails':
    pass


def _map_audits__shared_array_buffer_issue_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.SharedArrayBufferIssueType':
    pass


def _map_audits__shared_array_buffer_issue_details__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.SharedArrayBufferIssueDetails':
    pass


def _map_audits__low_text_contrast_issue_details__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.LowTextContrastIssueDetails':
    pass


def _map_audits__cors_issue_details__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.CorsIssueDetails':
    pass


def _map_audits__attribution_reporting_issue_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.AttributionReportingIssueType':
    pass


def _map_audits__attribution_reporting_issue_details__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.AttributionReportingIssueDetails':
    pass


def _map_audits__quirks_mode_issue_details__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.QuirksModeIssueDetails':
    pass


def _map_audits__navigator_user_agent_issue_details__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.NavigatorUserAgentIssueDetails':
    pass


def _map_audits__generic_issue_error_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.GenericIssueErrorType':
    pass


def _map_audits__generic_issue_details__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.GenericIssueDetails':
    pass


def _map_audits__deprecation_issue_details__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.DeprecationIssueDetails':
    pass


def _map_audits__bounce_tracking_issue_details__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.BounceTrackingIssueDetails':
    pass


def _map_audits__client_hint_issue_reason__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.ClientHintIssueReason':
    pass


def _map_audits__federated_auth_request_issue_details__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.FederatedAuthRequestIssueDetails':
    pass


def _map_audits__federated_auth_request_issue_reason__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.FederatedAuthRequestIssueReason':
    pass


def _map_audits__federated_auth_user_info_request_issue_details__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.FederatedAuthUserInfoRequestIssueDetails':
    pass


def _map_audits__federated_auth_user_info_request_issue_reason__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.FederatedAuthUserInfoRequestIssueReason':
    pass


def _map_audits__client_hint_issue_details__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.ClientHintIssueDetails':
    pass


def _map_audits__failed_request_info__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.FailedRequestInfo':
    pass


def _map_audits__style_sheet_loading_issue_reason__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.StyleSheetLoadingIssueReason':
    pass


def _map_audits__stylesheet_loading_issue_details__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.StylesheetLoadingIssueDetails':
    pass


def _map_audits__inspector_issue_code__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.InspectorIssueCode':
    pass


def _map_audits__inspector_issue_details__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.InspectorIssueDetails':
    pass


def _map_audits__issue_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.IssueId':
    pass


def _map_audits__inspector_issue__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'audits.InspectorIssue':
    pass


def _map_autofill__credit_card__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'autofill.CreditCard':
    pass


def _map_autofill__address_field__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'autofill.AddressField':
    pass


def _map_autofill__address_fields__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'autofill.AddressFields':
    pass


def _map_autofill__address__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'autofill.Address':
    pass


def _map_autofill__address_ui__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'autofill.AddressUI':
    pass


def _map_autofill__filling_strategy__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'autofill.FillingStrategy':
    pass


def _map_autofill__filled_field__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'autofill.FilledField':
    pass


def _map_background_service__service_name__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'background_service.ServiceName':
    pass


def _map_background_service__event_metadata__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'background_service.EventMetadata':
    pass


def _map_background_service__background_service_event__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'background_service.BackgroundServiceEvent':
    pass


def _map_browser__browser_context_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'browser.BrowserContextID':
    pass


def _map_browser__window_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'browser.WindowID':
    pass


def _map_browser__window_state__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'browser.WindowState':
    pass


def _map_browser__bounds__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'browser.Bounds':
    pass


def _map_browser__permission_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'browser.PermissionType':
    pass


def _map_browser__permission_setting__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'browser.PermissionSetting':
    pass


def _map_browser__permission_descriptor__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'browser.PermissionDescriptor':
    pass


def _map_browser__browser_command_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'browser.BrowserCommandId':
    pass


def _map_browser__bucket__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'browser.Bucket':
    pass


def _map_browser__histogram__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'browser.Histogram':
    pass


def _map_css__style_sheet_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.StyleSheetId':
    pass


def _map_css__style_sheet_origin__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.StyleSheetOrigin':
    pass


def _map_css__pseudo_element_matches__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.PseudoElementMatches':
    pass


def _map_css__inherited_style_entry__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.InheritedStyleEntry':
    pass


def _map_css__inherited_pseudo_element_matches__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.InheritedPseudoElementMatches':
    pass


def _map_css__rule_match__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.RuleMatch':
    pass


def _map_css__value__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.Value':
    pass


def _map_css__specificity__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.Specificity':
    pass


def _map_css__selector_list__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.SelectorList':
    pass


def _map_css__css_style_sheet_header__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.CSSStyleSheetHeader':
    pass


def _map_css__css_rule__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.CSSRule':
    pass


def _map_css__css_rule_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.CSSRuleType':
    pass


def _map_css__rule_usage__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.RuleUsage':
    pass


def _map_css__source_range__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.SourceRange':
    pass


def _map_css__shorthand_entry__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.ShorthandEntry':
    pass


def _map_css__css_computed_style_property__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.CSSComputedStyleProperty':
    pass


def _map_css__css_style__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.CSSStyle':
    pass


def _map_css__css_property__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.CSSProperty':
    pass


def _map_css__css_media__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.CSSMedia':
    pass


def _map_css__media_query__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.MediaQuery':
    pass


def _map_css__media_query_expression__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.MediaQueryExpression':
    pass


def _map_css__css_container_query__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.CSSContainerQuery':
    pass


def _map_css__css_supports__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.CSSSupports':
    pass


def _map_css__css_scope__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.CSSScope':
    pass


def _map_css__css_layer__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.CSSLayer':
    pass


def _map_css__css_layer_data__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.CSSLayerData':
    pass


def _map_css__platform_font_usage__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.PlatformFontUsage':
    pass


def _map_css__font_variation_axis__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.FontVariationAxis':
    pass


def _map_css__font_face__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.FontFace':
    pass


def _map_css__css_try_rule__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.CSSTryRule':
    pass


def _map_css__css_position_fallback_rule__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.CSSPositionFallbackRule':
    pass


def _map_css__css_keyframes_rule__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.CSSKeyframesRule':
    pass


def _map_css__css_property_registration__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.CSSPropertyRegistration':
    pass


def _map_css__css_property_rule__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.CSSPropertyRule':
    pass


def _map_css__css_keyframe_rule__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.CSSKeyframeRule':
    pass


def _map_css__style_declaration_edit__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'css.StyleDeclarationEdit':
    pass


def _map_cache_storage__cache_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'cache_storage.CacheId':
    pass


def _map_cache_storage__cached_response_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'cache_storage.CachedResponseType':
    pass


def _map_cache_storage__data_entry__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'cache_storage.DataEntry':
    pass


def _map_cache_storage__cache__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'cache_storage.Cache':
    pass


def _map_cache_storage__header__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'cache_storage.Header':
    pass


def _map_cache_storage__cached_response__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'cache_storage.CachedResponse':
    pass


def _map_cast__sink__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'cast.Sink':
    pass


def _map_dom__node_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom.NodeId':
    pass


def _map_dom__backend_node_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom.BackendNodeId':
    pass


def _map_dom__backend_node__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom.BackendNode':
    pass


def _map_dom__pseudo_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom.PseudoType':
    pass


def _map_dom__shadow_root_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom.ShadowRootType':
    pass


def _map_dom__compatibility_mode__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom.CompatibilityMode':
    pass


def _map_dom__physical_axes__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom.PhysicalAxes':
    pass


def _map_dom__logical_axes__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom.LogicalAxes':
    pass


def _map_dom__node__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom.Node':
    pass


def _map_dom__rgba__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom.RGBA':
    pass


def _map_dom__quad__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom.Quad':
    pass


def _map_dom__box_model__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom.BoxModel':
    pass


def _map_dom__shape_outside_info__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom.ShapeOutsideInfo':
    pass


def _map_dom__rect__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom.Rect':
    pass


def _map_dom__css_computed_style_property__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom.CSSComputedStyleProperty':
    pass


def _map_dom_debugger__dom_breakpoint_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom_debugger.DOMBreakpointType':
    pass


def _map_dom_debugger__csp_violation_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom_debugger.CSPViolationType':
    pass


def _map_dom_debugger__event_listener__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom_debugger.EventListener':
    pass


def _map_dom_snapshot__dom_node__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom_snapshot.DOMNode':
    pass


def _map_dom_snapshot__inline_text_box__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom_snapshot.InlineTextBox':
    pass


def _map_dom_snapshot__layout_tree_node__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom_snapshot.LayoutTreeNode':
    pass


def _map_dom_snapshot__computed_style__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom_snapshot.ComputedStyle':
    pass


def _map_dom_snapshot__name_value__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom_snapshot.NameValue':
    pass


def _map_dom_snapshot__string_index__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom_snapshot.StringIndex':
    pass


def _map_dom_snapshot__array_of_strings__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom_snapshot.ArrayOfStrings':
    pass


def _map_dom_snapshot__rare_string_data__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom_snapshot.RareStringData':
    pass


def _map_dom_snapshot__rare_boolean_data__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom_snapshot.RareBooleanData':
    pass


def _map_dom_snapshot__rare_integer_data__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom_snapshot.RareIntegerData':
    pass


def _map_dom_snapshot__rectangle__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom_snapshot.Rectangle':
    pass


def _map_dom_snapshot__document_snapshot__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom_snapshot.DocumentSnapshot':
    pass


def _map_dom_snapshot__node_tree_snapshot__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom_snapshot.NodeTreeSnapshot':
    pass


def _map_dom_snapshot__layout_tree_snapshot__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom_snapshot.LayoutTreeSnapshot':
    pass


def _map_dom_snapshot__text_box_snapshot__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom_snapshot.TextBoxSnapshot':
    pass


def _map_dom_storage__serialized_storage_key__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom_storage.SerializedStorageKey':
    pass


def _map_dom_storage__storage_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom_storage.StorageId':
    pass


def _map_dom_storage__item__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'dom_storage.Item':
    pass


def _map_database__database_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'database.DatabaseId':
    pass


def _map_database__database__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'database.Database':
    pass


def _map_database__error__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'database.Error':
    pass


def _map_emulation__screen_orientation__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'emulation.ScreenOrientation':
    pass


def _map_emulation__display_feature__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'emulation.DisplayFeature':
    pass


def _map_emulation__media_feature__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'emulation.MediaFeature':
    pass


def _map_emulation__virtual_time_policy__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'emulation.VirtualTimePolicy':
    pass


def _map_emulation__user_agent_brand_version__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'emulation.UserAgentBrandVersion':
    pass


def _map_emulation__user_agent_metadata__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'emulation.UserAgentMetadata':
    pass


def _map_emulation__disabled_image_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'emulation.DisabledImageType':
    pass


def _map_headless_experimental__screenshot_params__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'headless_experimental.ScreenshotParams':
    pass


def _map_io__stream_handle__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'io.StreamHandle':
    pass


def _map_indexed_db__database_with_object_stores__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'indexed_db.DatabaseWithObjectStores':
    pass


def _map_indexed_db__object_store__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'indexed_db.ObjectStore':
    pass


def _map_indexed_db__object_store_index__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'indexed_db.ObjectStoreIndex':
    pass


def _map_indexed_db__key__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'indexed_db.Key':
    pass


def _map_indexed_db__key_range__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'indexed_db.KeyRange':
    pass


def _map_indexed_db__data_entry__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'indexed_db.DataEntry':
    pass


def _map_indexed_db__key_path__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'indexed_db.KeyPath':
    pass


def _map_input__touch_point__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'input_.TouchPoint':
    pass


def _map_input__gesture_source_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'input_.GestureSourceType':
    pass


def _map_input__mouse_button__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'input_.MouseButton':
    pass


def _map_input__time_since_epoch__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'input_.TimeSinceEpoch':
    pass


def _map_input__drag_data_item__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'input_.DragDataItem':
    pass


def _map_input__drag_data__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'input_.DragData':
    pass


def _map_layer_tree__layer_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'layer_tree.LayerId':
    pass


def _map_layer_tree__snapshot_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'layer_tree.SnapshotId':
    pass


def _map_layer_tree__scroll_rect__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'layer_tree.ScrollRect':
    pass


def _map_layer_tree__sticky_position_constraint__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'layer_tree.StickyPositionConstraint':
    pass


def _map_layer_tree__picture_tile__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'layer_tree.PictureTile':
    pass


def _map_layer_tree__layer__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'layer_tree.Layer':
    pass


def _map_layer_tree__paint_profile__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'layer_tree.PaintProfile':
    pass


def _map_log__log_entry__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'log.LogEntry':
    pass


def _map_log__violation_setting__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'log.ViolationSetting':
    pass


def _map_memory__pressure_level__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'memory.PressureLevel':
    pass


def _map_memory__sampling_profile_node__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'memory.SamplingProfileNode':
    pass


def _map_memory__sampling_profile__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'memory.SamplingProfile':
    pass


def _map_memory__module__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'memory.Module':
    pass


def _map_network__resource_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.ResourceType':
    pass


def _map_network__loader_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.LoaderId':
    pass


def _map_network__request_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.RequestId':
    pass


def _map_network__interception_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.InterceptionId':
    pass


def _map_network__error_reason__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.ErrorReason':
    pass


def _map_network__time_since_epoch__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.TimeSinceEpoch':
    pass


def _map_network__monotonic_time__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.MonotonicTime':
    pass


def _map_network__headers__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.Headers':
    pass


def _map_network__connection_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.ConnectionType':
    pass


def _map_network__cookie_same_site__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.CookieSameSite':
    pass


def _map_network__cookie_priority__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.CookiePriority':
    pass


def _map_network__cookie_source_scheme__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.CookieSourceScheme':
    pass


def _map_network__resource_timing__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.ResourceTiming':
    pass


def _map_network__resource_priority__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.ResourcePriority':
    pass


def _map_network__post_data_entry__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.PostDataEntry':
    pass


def _map_network__request__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.Request':
    pass


def _map_network__signed_certificate_timestamp__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.SignedCertificateTimestamp':
    pass


def _map_network__security_details__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.SecurityDetails':
    pass


def _map_network__certificate_transparency_compliance__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.CertificateTransparencyCompliance':
    pass


def _map_network__blocked_reason__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.BlockedReason':
    pass


def _map_network__cors_error__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.CorsError':
    pass


def _map_network__cors_error_status__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.CorsErrorStatus':
    pass


def _map_network__service_worker_response_source__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.ServiceWorkerResponseSource':
    pass


def _map_network__trust_token_params__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.TrustTokenParams':
    pass


def _map_network__trust_token_operation_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.TrustTokenOperationType':
    pass


def _map_network__alternate_protocol_usage__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.AlternateProtocolUsage':
    pass


def _map_network__response__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.Response':
    pass


def _map_network__web_socket_request__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.WebSocketRequest':
    pass


def _map_network__web_socket_response__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.WebSocketResponse':
    pass


def _map_network__web_socket_frame__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.WebSocketFrame':
    pass


def _map_network__cached_resource__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.CachedResource':
    pass


def _map_network__initiator__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.Initiator':
    pass


def _map_network__cookie__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.Cookie':
    pass


def _map_network__set_cookie_blocked_reason__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.SetCookieBlockedReason':
    pass


def _map_network__cookie_blocked_reason__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.CookieBlockedReason':
    pass


def _map_network__blocked_set_cookie_with_reason__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.BlockedSetCookieWithReason':
    pass


def _map_network__blocked_cookie_with_reason__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.BlockedCookieWithReason':
    pass


def _map_network__cookie_param__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.CookieParam':
    pass


def _map_network__auth_challenge__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.AuthChallenge':
    pass


def _map_network__auth_challenge_response__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.AuthChallengeResponse':
    pass


def _map_network__interception_stage__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.InterceptionStage':
    pass


def _map_network__request_pattern__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.RequestPattern':
    pass


def _map_network__signed_exchange_signature__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.SignedExchangeSignature':
    pass


def _map_network__signed_exchange_header__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.SignedExchangeHeader':
    pass


def _map_network__signed_exchange_error_field__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.SignedExchangeErrorField':
    pass


def _map_network__signed_exchange_error__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.SignedExchangeError':
    pass


def _map_network__signed_exchange_info__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.SignedExchangeInfo':
    pass


def _map_network__content_encoding__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.ContentEncoding':
    pass


def _map_network__private_network_request_policy__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.PrivateNetworkRequestPolicy':
    pass


def _map_network__ip_address_space__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.IPAddressSpace':
    pass


def _map_network__connect_timing__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.ConnectTiming':
    pass


def _map_network__client_security_state__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.ClientSecurityState':
    pass


def _map_network__cross_origin_opener_policy_value__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.CrossOriginOpenerPolicyValue':
    pass


def _map_network__cross_origin_opener_policy_status__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.CrossOriginOpenerPolicyStatus':
    pass


def _map_network__cross_origin_embedder_policy_value__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.CrossOriginEmbedderPolicyValue':
    pass


def _map_network__cross_origin_embedder_policy_status__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.CrossOriginEmbedderPolicyStatus':
    pass


def _map_network__content_security_policy_source__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.ContentSecurityPolicySource':
    pass


def _map_network__content_security_policy_status__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.ContentSecurityPolicyStatus':
    pass


def _map_network__security_isolation_status__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.SecurityIsolationStatus':
    pass


def _map_network__report_status__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.ReportStatus':
    pass


def _map_network__report_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.ReportId':
    pass


def _map_network__reporting_api_report__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.ReportingApiReport':
    pass


def _map_network__reporting_api_endpoint__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.ReportingApiEndpoint':
    pass


def _map_network__load_network_resource_page_result__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.LoadNetworkResourcePageResult':
    pass


def _map_network__load_network_resource_options__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'network.LoadNetworkResourceOptions':
    pass


def _map_overlay__source_order_config__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'overlay.SourceOrderConfig':
    pass


def _map_overlay__grid_highlight_config__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'overlay.GridHighlightConfig':
    pass


def _map_overlay__flex_container_highlight_config__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'overlay.FlexContainerHighlightConfig':
    pass


def _map_overlay__flex_item_highlight_config__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'overlay.FlexItemHighlightConfig':
    pass


def _map_overlay__line_style__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'overlay.LineStyle':
    pass


def _map_overlay__box_style__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'overlay.BoxStyle':
    pass


def _map_overlay__contrast_algorithm__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'overlay.ContrastAlgorithm':
    pass


def _map_overlay__highlight_config__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'overlay.HighlightConfig':
    pass


def _map_overlay__color_format__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'overlay.ColorFormat':
    pass


def _map_overlay__grid_node_highlight_config__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'overlay.GridNodeHighlightConfig':
    pass


def _map_overlay__flex_node_highlight_config__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'overlay.FlexNodeHighlightConfig':
    pass


def _map_overlay__scroll_snap_container_highlight_config__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'overlay.ScrollSnapContainerHighlightConfig':
    pass


def _map_overlay__scroll_snap_highlight_config__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'overlay.ScrollSnapHighlightConfig':
    pass


def _map_overlay__hinge_config__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'overlay.HingeConfig':
    pass


def _map_overlay__container_query_highlight_config__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'overlay.ContainerQueryHighlightConfig':
    pass


def _map_overlay__container_query_container_highlight_config__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'overlay.ContainerQueryContainerHighlightConfig':
    pass


def _map_overlay__isolated_element_highlight_config__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'overlay.IsolatedElementHighlightConfig':
    pass


def _map_overlay__isolation_mode_highlight_config__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'overlay.IsolationModeHighlightConfig':
    pass


def _map_overlay__inspect_mode__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'overlay.InspectMode':
    pass


def _map_page__frame_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.FrameId':
    pass


def _map_page__ad_frame_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.AdFrameType':
    pass


def _map_page__ad_frame_explanation__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.AdFrameExplanation':
    pass


def _map_page__ad_frame_status__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.AdFrameStatus':
    pass


def _map_page__ad_script_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.AdScriptId':
    pass


def _map_page__secure_context_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.SecureContextType':
    pass


def _map_page__cross_origin_isolated_context_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.CrossOriginIsolatedContextType':
    pass


def _map_page__gated_api_features__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.GatedAPIFeatures':
    pass


def _map_page__permissions_policy_feature__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.PermissionsPolicyFeature':
    pass


def _map_page__permissions_policy_block_reason__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.PermissionsPolicyBlockReason':
    pass


def _map_page__permissions_policy_block_locator__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.PermissionsPolicyBlockLocator':
    pass


def _map_page__permissions_policy_feature_state__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.PermissionsPolicyFeatureState':
    pass


def _map_page__origin_trial_token_status__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.OriginTrialTokenStatus':
    pass


def _map_page__origin_trial_status__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.OriginTrialStatus':
    pass


def _map_page__origin_trial_usage_restriction__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.OriginTrialUsageRestriction':
    pass


def _map_page__origin_trial_token__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.OriginTrialToken':
    pass


def _map_page__origin_trial_token_with_status__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.OriginTrialTokenWithStatus':
    pass


def _map_page__origin_trial__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.OriginTrial':
    pass


def _map_page__frame__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.Frame':
    pass


def _map_page__frame_resource__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.FrameResource':
    pass


def _map_page__frame_resource_tree__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.FrameResourceTree':
    pass


def _map_page__frame_tree__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.FrameTree':
    pass


def _map_page__script_identifier__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.ScriptIdentifier':
    pass


def _map_page__transition_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.TransitionType':
    pass


def _map_page__navigation_entry__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.NavigationEntry':
    pass


def _map_page__screencast_frame_metadata__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.ScreencastFrameMetadata':
    pass


def _map_page__dialog_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.DialogType':
    pass


def _map_page__app_manifest_error__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.AppManifestError':
    pass


def _map_page__app_manifest_parsed_properties__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.AppManifestParsedProperties':
    pass


def _map_page__layout_viewport__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.LayoutViewport':
    pass


def _map_page__visual_viewport__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.VisualViewport':
    pass


def _map_page__viewport__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.Viewport':
    pass


def _map_page__font_families__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.FontFamilies':
    pass


def _map_page__script_font_families__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.ScriptFontFamilies':
    pass


def _map_page__font_sizes__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.FontSizes':
    pass


def _map_page__client_navigation_reason__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.ClientNavigationReason':
    pass


def _map_page__client_navigation_disposition__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.ClientNavigationDisposition':
    pass


def _map_page__installability_error_argument__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.InstallabilityErrorArgument':
    pass


def _map_page__installability_error__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.InstallabilityError':
    pass


def _map_page__referrer_policy__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.ReferrerPolicy':
    pass


def _map_page__compilation_cache_params__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.CompilationCacheParams':
    pass


def _map_page__auto_response_mode__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.AutoResponseMode':
    pass


def _map_page__navigation_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.NavigationType':
    pass


def _map_page__back_forward_cache_not_restored_reason__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.BackForwardCacheNotRestoredReason':
    pass


def _map_page__back_forward_cache_not_restored_reason_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.BackForwardCacheNotRestoredReasonType':
    pass


def _map_page__back_forward_cache_not_restored_explanation__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.BackForwardCacheNotRestoredExplanation':
    pass


def _map_page__back_forward_cache_not_restored_explanation_tree__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'page.BackForwardCacheNotRestoredExplanationTree':
    pass


def _map_performance__metric__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'performance.Metric':
    pass


def _map_performance_timeline__largest_contentful_paint__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'performance_timeline.LargestContentfulPaint':
    pass


def _map_performance_timeline__layout_shift_attribution__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'performance_timeline.LayoutShiftAttribution':
    pass


def _map_performance_timeline__layout_shift__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'performance_timeline.LayoutShift':
    pass


def _map_performance_timeline__timeline_event__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'performance_timeline.TimelineEvent':
    pass


def _map_security__certificate_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'security.CertificateId':
    pass


def _map_security__mixed_content_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'security.MixedContentType':
    pass


def _map_security__security_state__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'security.SecurityState':
    pass


def _map_security__certificate_security_state__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'security.CertificateSecurityState':
    pass


def _map_security__safety_tip_status__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'security.SafetyTipStatus':
    pass


def _map_security__safety_tip_info__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'security.SafetyTipInfo':
    pass


def _map_security__visible_security_state__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'security.VisibleSecurityState':
    pass


def _map_security__security_state_explanation__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'security.SecurityStateExplanation':
    pass


def _map_security__insecure_content_status__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'security.InsecureContentStatus':
    pass


def _map_security__certificate_error_action__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'security.CertificateErrorAction':
    pass


def _map_service_worker__registration_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'service_worker.RegistrationID':
    pass


def _map_service_worker__service_worker_registration__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'service_worker.ServiceWorkerRegistration':
    pass


def _map_service_worker__service_worker_version_running_status__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'service_worker.ServiceWorkerVersionRunningStatus':
    pass


def _map_service_worker__service_worker_version_status__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'service_worker.ServiceWorkerVersionStatus':
    pass


def _map_service_worker__service_worker_version__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'service_worker.ServiceWorkerVersion':
    pass


def _map_service_worker__service_worker_error_message__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'service_worker.ServiceWorkerErrorMessage':
    pass


def _map_storage__serialized_storage_key__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.SerializedStorageKey':
    pass


def _map_storage__storage_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.StorageType':
    pass


def _map_storage__usage_for_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.UsageForType':
    pass


def _map_storage__trust_tokens__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.TrustTokens':
    pass


def _map_storage__interest_group_access_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.InterestGroupAccessType':
    pass


def _map_storage__interest_group_ad__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.InterestGroupAd':
    pass


def _map_storage__interest_group_details__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.InterestGroupDetails':
    pass


def _map_storage__shared_storage_access_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.SharedStorageAccessType':
    pass


def _map_storage__shared_storage_entry__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.SharedStorageEntry':
    pass


def _map_storage__shared_storage_metadata__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.SharedStorageMetadata':
    pass


def _map_storage__shared_storage_reporting_metadata__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.SharedStorageReportingMetadata':
    pass


def _map_storage__shared_storage_url_with_metadata__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.SharedStorageUrlWithMetadata':
    pass


def _map_storage__shared_storage_access_params__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.SharedStorageAccessParams':
    pass


def _map_storage__storage_buckets_durability__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.StorageBucketsDurability':
    pass


def _map_storage__storage_bucket__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.StorageBucket':
    pass


def _map_storage__storage_bucket_info__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.StorageBucketInfo':
    pass


def _map_storage__attribution_reporting_source_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.AttributionReportingSourceType':
    pass


def _map_storage__unsigned_int64_as_base10__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.UnsignedInt64AsBase10':
    pass


def _map_storage__unsigned_int128_as_base16__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.UnsignedInt128AsBase16':
    pass


def _map_storage__signed_int64_as_base10__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.SignedInt64AsBase10':
    pass


def _map_storage__attribution_reporting_filter_data_entry__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.AttributionReportingFilterDataEntry':
    pass


def _map_storage__attribution_reporting_aggregation_keys_entry__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.AttributionReportingAggregationKeysEntry':
    pass


def _map_storage__attribution_reporting_event_report_windows__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.AttributionReportingEventReportWindows':
    pass


def _map_storage__attribution_reporting_source_registration__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.AttributionReportingSourceRegistration':
    pass


def _map_storage__attribution_reporting_source_registration_result__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'storage.AttributionReportingSourceRegistrationResult':
    pass


def _map_system_info__gpu_device__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'system_info.GPUDevice':
    pass


def _map_system_info__size__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'system_info.Size':
    pass


def _map_system_info__video_decode_accelerator_capability__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'system_info.VideoDecodeAcceleratorCapability':
    pass


def _map_system_info__video_encode_accelerator_capability__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'system_info.VideoEncodeAcceleratorCapability':
    pass


def _map_system_info__subsampling_format__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'system_info.SubsamplingFormat':
    pass


def _map_system_info__image_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'system_info.ImageType':
    pass


def _map_system_info__image_decode_accelerator_capability__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'system_info.ImageDecodeAcceleratorCapability':
    pass


def _map_system_info__gpu_info__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'system_info.GPUInfo':
    pass


def _map_system_info__process_info__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'system_info.ProcessInfo':
    pass


def _map_target__target_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'target.TargetID':
    pass


def _map_target__session_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'target.SessionID':
    pass


def _map_target__target_info__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'target.TargetInfo':
    pass


def _map_target__filter_entry__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'target.FilterEntry':
    pass


def _map_target__target_filter__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'target.TargetFilter':
    pass


def _map_target__remote_location__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'target.RemoteLocation':
    pass


def _map_tracing__memory_dump_config__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'tracing.MemoryDumpConfig':
    pass


def _map_tracing__trace_config__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'tracing.TraceConfig':
    pass


def _map_tracing__stream_format__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'tracing.StreamFormat':
    pass


def _map_tracing__stream_compression__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'tracing.StreamCompression':
    pass


def _map_tracing__memory_dump_level_of_detail__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'tracing.MemoryDumpLevelOfDetail':
    pass


def _map_tracing__tracing_backend__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'tracing.TracingBackend':
    pass


def _map_fetch__request_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'fetch.RequestId':
    pass


def _map_fetch__request_stage__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'fetch.RequestStage':
    pass


def _map_fetch__request_pattern__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'fetch.RequestPattern':
    pass


def _map_fetch__header_entry__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'fetch.HeaderEntry':
    pass


def _map_fetch__auth_challenge__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'fetch.AuthChallenge':
    pass


def _map_fetch__auth_challenge_response__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'fetch.AuthChallengeResponse':
    pass


def _map_web_audio__graph_object_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'web_audio.GraphObjectId':
    pass


def _map_web_audio__context_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'web_audio.ContextType':
    pass


def _map_web_audio__context_state__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'web_audio.ContextState':
    pass


def _map_web_audio__node_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'web_audio.NodeType':
    pass


def _map_web_audio__channel_count_mode__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'web_audio.ChannelCountMode':
    pass


def _map_web_audio__channel_interpretation__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'web_audio.ChannelInterpretation':
    pass


def _map_web_audio__param_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'web_audio.ParamType':
    pass


def _map_web_audio__automation_rate__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'web_audio.AutomationRate':
    pass


def _map_web_audio__context_realtime_data__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'web_audio.ContextRealtimeData':
    pass


def _map_web_audio__base_audio_context__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'web_audio.BaseAudioContext':
    pass


def _map_web_audio__audio_listener__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'web_audio.AudioListener':
    pass


def _map_web_audio__audio_node__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'web_audio.AudioNode':
    pass


def _map_web_audio__audio_param__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'web_audio.AudioParam':
    pass


def _map_web_authn__authenticator_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'web_authn.AuthenticatorId':
    pass


def _map_web_authn__authenticator_protocol__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'web_authn.AuthenticatorProtocol':
    pass


def _map_web_authn__ctap2_version__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'web_authn.Ctap2Version':
    pass


def _map_web_authn__authenticator_transport__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'web_authn.AuthenticatorTransport':
    pass


def _map_web_authn__virtual_authenticator_options__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'web_authn.VirtualAuthenticatorOptions':
    pass


def _map_web_authn__credential__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'web_authn.Credential':
    pass


def _map_media__player_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'media.PlayerId':
    pass


def _map_media__timestamp__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'media.Timestamp':
    pass


def _map_media__player_message__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'media.PlayerMessage':
    pass


def _map_media__player_property__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'media.PlayerProperty':
    pass


def _map_media__player_event__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'media.PlayerEvent':
    pass


def _map_media__player_error_source_location__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'media.PlayerErrorSourceLocation':
    pass


def _map_media__player_error__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'media.PlayerError':
    pass


def _map_device_access__request_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'device_access.RequestId':
    pass


def _map_device_access__device_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'device_access.DeviceId':
    pass


def _map_device_access__prompt_device__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'device_access.PromptDevice':
    pass


def _map_preload__rule_set_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'preload.RuleSetId':
    pass


def _map_preload__rule_set__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'preload.RuleSet':
    pass


def _map_preload__rule_set_error_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'preload.RuleSetErrorType':
    pass


def _map_preload__speculation_action__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'preload.SpeculationAction':
    pass


def _map_preload__speculation_target_hint__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'preload.SpeculationTargetHint':
    pass


def _map_preload__preloading_attempt_key__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'preload.PreloadingAttemptKey':
    pass


def _map_preload__preloading_attempt_source__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'preload.PreloadingAttemptSource':
    pass


def _map_preload__prerender_final_status__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'preload.PrerenderFinalStatus':
    pass


def _map_preload__preloading_status__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'preload.PreloadingStatus':
    pass


def _map_preload__prefetch_status__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'preload.PrefetchStatus':
    pass


def _map_fed_cm__login_state__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'fed_cm.LoginState':
    pass


def _map_fed_cm__dialog_type__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'fed_cm.DialogType':
    pass


def _map_fed_cm__account__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'fed_cm.Account':
    pass


def _map_console__console_message__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'console.ConsoleMessage':
    pass


def _map_debugger__breakpoint_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'debugger.BreakpointId':
    pass


def _map_debugger__call_frame_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'debugger.CallFrameId':
    pass


def _map_debugger__location__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'debugger.Location':
    pass


def _map_debugger__script_position__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'debugger.ScriptPosition':
    pass


def _map_debugger__call_frame__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'debugger.CallFrame':
    pass


def _map_debugger__scope__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'debugger.Scope':
    pass


def _map_debugger__search_match__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'debugger.SearchMatch':
    pass


def _map_debugger__break_location__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'debugger.BreakLocation':
    pass


def _map_heap_profiler__heap_snapshot_object_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'heap_profiler.HeapSnapshotObjectId':
    pass


def _map_heap_profiler__sampling_heap_profile_node__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'heap_profiler.SamplingHeapProfileNode':
    pass


def _map_heap_profiler__sampling_heap_profile_sample__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'heap_profiler.SamplingHeapProfileSample':
    pass


def _map_heap_profiler__sampling_heap_profile__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'heap_profiler.SamplingHeapProfile':
    pass


def _map_profiler__profile_node__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'profiler.ProfileNode':
    pass


def _map_profiler__profile__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'profiler.Profile':
    pass


def _map_profiler__position_tick_info__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'profiler.PositionTickInfo':
    pass


def _map_profiler__coverage_range__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'profiler.CoverageRange':
    pass


def _map_profiler__function_coverage__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'profiler.FunctionCoverage':
    pass


def _map_profiler__script_coverage__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'profiler.ScriptCoverage':
    pass


def _map_profiler__type_object__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'profiler.TypeObject':
    pass


def _map_profiler__type_profile_entry__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'profiler.TypeProfileEntry':
    pass


def _map_profiler__script_type_profile__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'profiler.ScriptTypeProfile':
    pass


def _map_runtime__script_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'runtime.ScriptId':
    pass


def _map_runtime__remote_object_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'runtime.RemoteObjectId':
    pass


def _map_runtime__unserializable_value__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'runtime.UnserializableValue':
    pass


def _map_runtime__remote_object__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'runtime.RemoteObject':
    pass


def _map_runtime__custom_preview__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'runtime.CustomPreview':
    pass


def _map_runtime__object_preview__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'runtime.ObjectPreview':
    pass


def _map_runtime__property_preview__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'runtime.PropertyPreview':
    pass


def _map_runtime__entry_preview__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'runtime.EntryPreview':
    pass


def _map_runtime__property_descriptor__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'runtime.PropertyDescriptor':
    pass


def _map_runtime__internal_property_descriptor__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'runtime.InternalPropertyDescriptor':
    pass


def _map_runtime__private_property_descriptor__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'runtime.PrivatePropertyDescriptor':
    pass


def _map_runtime__call_argument__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'runtime.CallArgument':
    pass


def _map_runtime__execution_context_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'runtime.ExecutionContextId':
    pass


def _map_runtime__execution_context_description__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'runtime.ExecutionContextDescription':
    pass


def _map_runtime__exception_details__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'runtime.ExceptionDetails':
    pass


def _map_runtime__timestamp__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'runtime.Timestamp':
    pass


def _map_runtime__time_delta__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'runtime.TimeDelta':
    pass


def _map_runtime__call_frame__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'runtime.CallFrame':
    pass


def _map_runtime__stack_trace__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'runtime.StackTrace':
    pass


def _map_runtime__unique_debugger_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'runtime.UniqueDebuggerId':
    pass


def _map_runtime__stack_trace_id__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'runtime.StackTraceId':
    pass


def _map_schema__domain__from_dict(data: dict, casing_strategy: 'CasingStrategyT' = 'snake') -> 'schema.Domain':
    pass


def to_dict(data, casing_strategy: CasingStrategyT) -> dict:
    pass
    lookup = {
        accessibility.AXValueSource: (
            _map_accessibility__ax_value_source__to_dict
        ),
        accessibility.AXRelatedNode: (
            _map_accessibility__ax_related_node__to_dict
        ),
        accessibility.AXProperty: (
            _map_accessibility__ax_property__to_dict
        ),
        accessibility.AXValue: (
            _map_accessibility__ax_value__to_dict
        ),
        accessibility.AXNode: (
            _map_accessibility__ax_node__to_dict
        ),
        animation.Animation: (
            _map_animation__animation__to_dict
        ),
        animation.AnimationEffect: (
            _map_animation__animation_effect__to_dict
        ),
        animation.KeyframesRule: (
            _map_animation__keyframes_rule__to_dict
        ),
        animation.KeyframeStyle: (
            _map_animation__keyframe_style__to_dict
        ),
        audits.AffectedCookie: (
            _map_audits__affected_cookie__to_dict
        ),
        audits.AffectedRequest: (
            _map_audits__affected_request__to_dict
        ),
        audits.AffectedFrame: (
            _map_audits__affected_frame__to_dict
        ),
        audits.CookieIssueDetails: (
            _map_audits__cookie_issue_details__to_dict
        ),
        audits.MixedContentIssueDetails: (
            _map_audits__mixed_content_issue_details__to_dict
        ),
        audits.BlockedByResponseIssueDetails: (
            _map_audits__blocked_by_response_issue_details__to_dict
        ),
        audits.HeavyAdIssueDetails: (
            _map_audits__heavy_ad_issue_details__to_dict
        ),
        audits.SourceCodeLocation: (
            _map_audits__source_code_location__to_dict
        ),
        audits.ContentSecurityPolicyIssueDetails: (
            _map_audits__content_security_policy_issue_details__to_dict
        ),
        audits.SharedArrayBufferIssueDetails: (
            _map_audits__shared_array_buffer_issue_details__to_dict
        ),
        audits.LowTextContrastIssueDetails: (
            _map_audits__low_text_contrast_issue_details__to_dict
        ),
        audits.CorsIssueDetails: (
            _map_audits__cors_issue_details__to_dict
        ),
        audits.AttributionReportingIssueDetails: (
            _map_audits__attribution_reporting_issue_details__to_dict
        ),
        audits.QuirksModeIssueDetails: (
            _map_audits__quirks_mode_issue_details__to_dict
        ),
        audits.NavigatorUserAgentIssueDetails: (
            _map_audits__navigator_user_agent_issue_details__to_dict
        ),
        audits.GenericIssueDetails: (
            _map_audits__generic_issue_details__to_dict
        ),
        audits.DeprecationIssueDetails: (
            _map_audits__deprecation_issue_details__to_dict
        ),
        audits.BounceTrackingIssueDetails: (
            _map_audits__bounce_tracking_issue_details__to_dict
        ),
        audits.FederatedAuthRequestIssueDetails: (
            _map_audits__federated_auth_request_issue_details__to_dict
        ),
        audits.FederatedAuthUserInfoRequestIssueDetails: (
            _map_audits__federated_auth_user_info_request_issue_details__to_dict
        ),
        audits.ClientHintIssueDetails: (
            _map_audits__client_hint_issue_details__to_dict
        ),
        audits.FailedRequestInfo: (
            _map_audits__failed_request_info__to_dict
        ),
        audits.StylesheetLoadingIssueDetails: (
            _map_audits__stylesheet_loading_issue_details__to_dict
        ),
        audits.InspectorIssueDetails: (
            _map_audits__inspector_issue_details__to_dict
        ),
        audits.InspectorIssue: (
            _map_audits__inspector_issue__to_dict
        ),
        autofill.CreditCard: (
            _map_autofill__credit_card__to_dict
        ),
        autofill.AddressField: (
            _map_autofill__address_field__to_dict
        ),
        autofill.AddressFields: (
            _map_autofill__address_fields__to_dict
        ),
        autofill.Address: (
            _map_autofill__address__to_dict
        ),
        autofill.AddressUI: (
            _map_autofill__address_ui__to_dict
        ),
        autofill.FilledField: (
            _map_autofill__filled_field__to_dict
        ),
        background_service.EventMetadata: (
            _map_background_service__event_metadata__to_dict
        ),
        background_service.BackgroundServiceEvent: (
            _map_background_service__background_service_event__to_dict
        ),
        browser.Bounds: (
            _map_browser__bounds__to_dict
        ),
        browser.PermissionDescriptor: (
            _map_browser__permission_descriptor__to_dict
        ),
        browser.Bucket: (
            _map_browser__bucket__to_dict
        ),
        browser.Histogram: (
            _map_browser__histogram__to_dict
        ),
        css.PseudoElementMatches: (
            _map_css__pseudo_element_matches__to_dict
        ),
        css.InheritedStyleEntry: (
            _map_css__inherited_style_entry__to_dict
        ),
        css.InheritedPseudoElementMatches: (
            _map_css__inherited_pseudo_element_matches__to_dict
        ),
        css.RuleMatch: (
            _map_css__rule_match__to_dict
        ),
        css.Value: (
            _map_css__value__to_dict
        ),
        css.Specificity: (
            _map_css__specificity__to_dict
        ),
        css.SelectorList: (
            _map_css__selector_list__to_dict
        ),
        css.CSSStyleSheetHeader: (
            _map_css__css_style_sheet_header__to_dict
        ),
        css.CSSRule: (
            _map_css__css_rule__to_dict
        ),
        css.RuleUsage: (
            _map_css__rule_usage__to_dict
        ),
        css.SourceRange: (
            _map_css__source_range__to_dict
        ),
        css.ShorthandEntry: (
            _map_css__shorthand_entry__to_dict
        ),
        css.CSSComputedStyleProperty: (
            _map_css__css_computed_style_property__to_dict
        ),
        css.CSSStyle: (
            _map_css__css_style__to_dict
        ),
        css.CSSProperty: (
            _map_css__css_property__to_dict
        ),
        css.CSSMedia: (
            _map_css__css_media__to_dict
        ),
        css.MediaQuery: (
            _map_css__media_query__to_dict
        ),
        css.MediaQueryExpression: (
            _map_css__media_query_expression__to_dict
        ),
        css.CSSContainerQuery: (
            _map_css__css_container_query__to_dict
        ),
        css.CSSSupports: (
            _map_css__css_supports__to_dict
        ),
        css.CSSScope: (
            _map_css__css_scope__to_dict
        ),
        css.CSSLayer: (
            _map_css__css_layer__to_dict
        ),
        css.CSSLayerData: (
            _map_css__css_layer_data__to_dict
        ),
        css.PlatformFontUsage: (
            _map_css__platform_font_usage__to_dict
        ),
        css.FontVariationAxis: (
            _map_css__font_variation_axis__to_dict
        ),
        css.FontFace: (
            _map_css__font_face__to_dict
        ),
        css.CSSTryRule: (
            _map_css__css_try_rule__to_dict
        ),
        css.CSSPositionFallbackRule: (
            _map_css__css_position_fallback_rule__to_dict
        ),
        css.CSSKeyframesRule: (
            _map_css__css_keyframes_rule__to_dict
        ),
        css.CSSPropertyRegistration: (
            _map_css__css_property_registration__to_dict
        ),
        css.CSSPropertyRule: (
            _map_css__css_property_rule__to_dict
        ),
        css.CSSKeyframeRule: (
            _map_css__css_keyframe_rule__to_dict
        ),
        css.StyleDeclarationEdit: (
            _map_css__style_declaration_edit__to_dict
        ),
        cache_storage.DataEntry: (
            _map_cache_storage__data_entry__to_dict
        ),
        cache_storage.Cache: (
            _map_cache_storage__cache__to_dict
        ),
        cache_storage.Header: (
            _map_cache_storage__header__to_dict
        ),
        cache_storage.CachedResponse: (
            _map_cache_storage__cached_response__to_dict
        ),
        cast.Sink: (
            _map_cast__sink__to_dict
        ),
        dom.BackendNode: (
            _map_dom__backend_node__to_dict
        ),
        dom.Node: (
            _map_dom__node__to_dict
        ),
        dom.RGBA: (
            _map_dom__rgba__to_dict
        ),
        dom.BoxModel: (
            _map_dom__box_model__to_dict
        ),
        dom.ShapeOutsideInfo: (
            _map_dom__shape_outside_info__to_dict
        ),
        dom.Rect: (
            _map_dom__rect__to_dict
        ),
        dom.CSSComputedStyleProperty: (
            _map_dom__css_computed_style_property__to_dict
        ),
        dom_debugger.EventListener: (
            _map_dom_debugger__event_listener__to_dict
        ),
        dom_snapshot.DOMNode: (
            _map_dom_snapshot__dom_node__to_dict
        ),
        dom_snapshot.InlineTextBox: (
            _map_dom_snapshot__inline_text_box__to_dict
        ),
        dom_snapshot.LayoutTreeNode: (
            _map_dom_snapshot__layout_tree_node__to_dict
        ),
        dom_snapshot.ComputedStyle: (
            _map_dom_snapshot__computed_style__to_dict
        ),
        dom_snapshot.NameValue: (
            _map_dom_snapshot__name_value__to_dict
        ),
        dom_snapshot.RareStringData: (
            _map_dom_snapshot__rare_string_data__to_dict
        ),
        dom_snapshot.RareBooleanData: (
            _map_dom_snapshot__rare_boolean_data__to_dict
        ),
        dom_snapshot.RareIntegerData: (
            _map_dom_snapshot__rare_integer_data__to_dict
        ),
        dom_snapshot.DocumentSnapshot: (
            _map_dom_snapshot__document_snapshot__to_dict
        ),
        dom_snapshot.NodeTreeSnapshot: (
            _map_dom_snapshot__node_tree_snapshot__to_dict
        ),
        dom_snapshot.LayoutTreeSnapshot: (
            _map_dom_snapshot__layout_tree_snapshot__to_dict
        ),
        dom_snapshot.TextBoxSnapshot: (
            _map_dom_snapshot__text_box_snapshot__to_dict
        ),
        dom_storage.StorageId: (
            _map_dom_storage__storage_id__to_dict
        ),
        database.Database: (
            _map_database__database__to_dict
        ),
        database.Error: (
            _map_database__error__to_dict
        ),
        emulation.ScreenOrientation: (
            _map_emulation__screen_orientation__to_dict
        ),
        emulation.DisplayFeature: (
            _map_emulation__display_feature__to_dict
        ),
        emulation.MediaFeature: (
            _map_emulation__media_feature__to_dict
        ),
        emulation.UserAgentBrandVersion: (
            _map_emulation__user_agent_brand_version__to_dict
        ),
        emulation.UserAgentMetadata: (
            _map_emulation__user_agent_metadata__to_dict
        ),
        headless_experimental.ScreenshotParams: (
            _map_headless_experimental__screenshot_params__to_dict
        ),
        indexed_db.DatabaseWithObjectStores: (
            _map_indexed_db__database_with_object_stores__to_dict
        ),
        indexed_db.ObjectStore: (
            _map_indexed_db__object_store__to_dict
        ),
        indexed_db.ObjectStoreIndex: (
            _map_indexed_db__object_store_index__to_dict
        ),
        indexed_db.Key: (
            _map_indexed_db__key__to_dict
        ),
        indexed_db.KeyRange: (
            _map_indexed_db__key_range__to_dict
        ),
        indexed_db.DataEntry: (
            _map_indexed_db__data_entry__to_dict
        ),
        indexed_db.KeyPath: (
            _map_indexed_db__key_path__to_dict
        ),
        input_.TouchPoint: (
            _map_input__touch_point__to_dict
        ),
        input_.DragDataItem: (
            _map_input__drag_data_item__to_dict
        ),
        input_.DragData: (
            _map_input__drag_data__to_dict
        ),
        layer_tree.ScrollRect: (
            _map_layer_tree__scroll_rect__to_dict
        ),
        layer_tree.StickyPositionConstraint: (
            _map_layer_tree__sticky_position_constraint__to_dict
        ),
        layer_tree.PictureTile: (
            _map_layer_tree__picture_tile__to_dict
        ),
        layer_tree.Layer: (
            _map_layer_tree__layer__to_dict
        ),
        log.LogEntry: (
            _map_log__log_entry__to_dict
        ),
        log.ViolationSetting: (
            _map_log__violation_setting__to_dict
        ),
        memory.SamplingProfileNode: (
            _map_memory__sampling_profile_node__to_dict
        ),
        memory.SamplingProfile: (
            _map_memory__sampling_profile__to_dict
        ),
        memory.Module: (
            _map_memory__module__to_dict
        ),
        network.ResourceTiming: (
            _map_network__resource_timing__to_dict
        ),
        network.PostDataEntry: (
            _map_network__post_data_entry__to_dict
        ),
        network.Request: (
            _map_network__request__to_dict
        ),
        network.SignedCertificateTimestamp: (
            _map_network__signed_certificate_timestamp__to_dict
        ),
        network.SecurityDetails: (
            _map_network__security_details__to_dict
        ),
        network.CorsErrorStatus: (
            _map_network__cors_error_status__to_dict
        ),
        network.TrustTokenParams: (
            _map_network__trust_token_params__to_dict
        ),
        network.Response: (
            _map_network__response__to_dict
        ),
        network.WebSocketRequest: (
            _map_network__web_socket_request__to_dict
        ),
        network.WebSocketResponse: (
            _map_network__web_socket_response__to_dict
        ),
        network.WebSocketFrame: (
            _map_network__web_socket_frame__to_dict
        ),
        network.CachedResource: (
            _map_network__cached_resource__to_dict
        ),
        network.Initiator: (
            _map_network__initiator__to_dict
        ),
        network.Cookie: (
            _map_network__cookie__to_dict
        ),
        network.BlockedSetCookieWithReason: (
            _map_network__blocked_set_cookie_with_reason__to_dict
        ),
        network.BlockedCookieWithReason: (
            _map_network__blocked_cookie_with_reason__to_dict
        ),
        network.CookieParam: (
            _map_network__cookie_param__to_dict
        ),
        network.AuthChallenge: (
            _map_network__auth_challenge__to_dict
        ),
        network.AuthChallengeResponse: (
            _map_network__auth_challenge_response__to_dict
        ),
        network.RequestPattern: (
            _map_network__request_pattern__to_dict
        ),
        network.SignedExchangeSignature: (
            _map_network__signed_exchange_signature__to_dict
        ),
        network.SignedExchangeHeader: (
            _map_network__signed_exchange_header__to_dict
        ),
        network.SignedExchangeError: (
            _map_network__signed_exchange_error__to_dict
        ),
        network.SignedExchangeInfo: (
            _map_network__signed_exchange_info__to_dict
        ),
        network.ConnectTiming: (
            _map_network__connect_timing__to_dict
        ),
        network.ClientSecurityState: (
            _map_network__client_security_state__to_dict
        ),
        network.CrossOriginOpenerPolicyStatus: (
            _map_network__cross_origin_opener_policy_status__to_dict
        ),
        network.CrossOriginEmbedderPolicyStatus: (
            _map_network__cross_origin_embedder_policy_status__to_dict
        ),
        network.ContentSecurityPolicyStatus: (
            _map_network__content_security_policy_status__to_dict
        ),
        network.SecurityIsolationStatus: (
            _map_network__security_isolation_status__to_dict
        ),
        network.ReportingApiReport: (
            _map_network__reporting_api_report__to_dict
        ),
        network.ReportingApiEndpoint: (
            _map_network__reporting_api_endpoint__to_dict
        ),
        network.LoadNetworkResourcePageResult: (
            _map_network__load_network_resource_page_result__to_dict
        ),
        network.LoadNetworkResourceOptions: (
            _map_network__load_network_resource_options__to_dict
        ),
        overlay.SourceOrderConfig: (
            _map_overlay__source_order_config__to_dict
        ),
        overlay.GridHighlightConfig: (
            _map_overlay__grid_highlight_config__to_dict
        ),
        overlay.FlexContainerHighlightConfig: (
            _map_overlay__flex_container_highlight_config__to_dict
        ),
        overlay.FlexItemHighlightConfig: (
            _map_overlay__flex_item_highlight_config__to_dict
        ),
        overlay.LineStyle: (
            _map_overlay__line_style__to_dict
        ),
        overlay.BoxStyle: (
            _map_overlay__box_style__to_dict
        ),
        overlay.HighlightConfig: (
            _map_overlay__highlight_config__to_dict
        ),
        overlay.GridNodeHighlightConfig: (
            _map_overlay__grid_node_highlight_config__to_dict
        ),
        overlay.FlexNodeHighlightConfig: (
            _map_overlay__flex_node_highlight_config__to_dict
        ),
        overlay.ScrollSnapContainerHighlightConfig: (
            _map_overlay__scroll_snap_container_highlight_config__to_dict
        ),
        overlay.ScrollSnapHighlightConfig: (
            _map_overlay__scroll_snap_highlight_config__to_dict
        ),
        overlay.HingeConfig: (
            _map_overlay__hinge_config__to_dict
        ),
        overlay.ContainerQueryHighlightConfig: (
            _map_overlay__container_query_highlight_config__to_dict
        ),
        overlay.ContainerQueryContainerHighlightConfig: (
            _map_overlay__container_query_container_highlight_config__to_dict
        ),
        overlay.IsolatedElementHighlightConfig: (
            _map_overlay__isolated_element_highlight_config__to_dict
        ),
        overlay.IsolationModeHighlightConfig: (
            _map_overlay__isolation_mode_highlight_config__to_dict
        ),
        page.AdFrameStatus: (
            _map_page__ad_frame_status__to_dict
        ),
        page.AdScriptId: (
            _map_page__ad_script_id__to_dict
        ),
        page.PermissionsPolicyBlockLocator: (
            _map_page__permissions_policy_block_locator__to_dict
        ),
        page.PermissionsPolicyFeatureState: (
            _map_page__permissions_policy_feature_state__to_dict
        ),
        page.OriginTrialToken: (
            _map_page__origin_trial_token__to_dict
        ),
        page.OriginTrialTokenWithStatus: (
            _map_page__origin_trial_token_with_status__to_dict
        ),
        page.OriginTrial: (
            _map_page__origin_trial__to_dict
        ),
        page.Frame: (
            _map_page__frame__to_dict
        ),
        page.FrameResource: (
            _map_page__frame_resource__to_dict
        ),
        page.FrameResourceTree: (
            _map_page__frame_resource_tree__to_dict
        ),
        page.FrameTree: (
            _map_page__frame_tree__to_dict
        ),
        page.NavigationEntry: (
            _map_page__navigation_entry__to_dict
        ),
        page.ScreencastFrameMetadata: (
            _map_page__screencast_frame_metadata__to_dict
        ),
        page.AppManifestError: (
            _map_page__app_manifest_error__to_dict
        ),
        page.AppManifestParsedProperties: (
            _map_page__app_manifest_parsed_properties__to_dict
        ),
        page.LayoutViewport: (
            _map_page__layout_viewport__to_dict
        ),
        page.VisualViewport: (
            _map_page__visual_viewport__to_dict
        ),
        page.Viewport: (
            _map_page__viewport__to_dict
        ),
        page.FontFamilies: (
            _map_page__font_families__to_dict
        ),
        page.ScriptFontFamilies: (
            _map_page__script_font_families__to_dict
        ),
        page.FontSizes: (
            _map_page__font_sizes__to_dict
        ),
        page.InstallabilityErrorArgument: (
            _map_page__installability_error_argument__to_dict
        ),
        page.InstallabilityError: (
            _map_page__installability_error__to_dict
        ),
        page.CompilationCacheParams: (
            _map_page__compilation_cache_params__to_dict
        ),
        page.BackForwardCacheNotRestoredExplanation: (
            _map_page__back_forward_cache_not_restored_explanation__to_dict
        ),
        page.BackForwardCacheNotRestoredExplanationTree: (
            _map_page__back_forward_cache_not_restored_explanation_tree__to_dict
        ),
        performance.Metric: (
            _map_performance__metric__to_dict
        ),
        performance_timeline.LargestContentfulPaint: (
            _map_performance_timeline__largest_contentful_paint__to_dict
        ),
        performance_timeline.LayoutShiftAttribution: (
            _map_performance_timeline__layout_shift_attribution__to_dict
        ),
        performance_timeline.LayoutShift: (
            _map_performance_timeline__layout_shift__to_dict
        ),
        performance_timeline.TimelineEvent: (
            _map_performance_timeline__timeline_event__to_dict
        ),
        security.CertificateSecurityState: (
            _map_security__certificate_security_state__to_dict
        ),
        security.SafetyTipInfo: (
            _map_security__safety_tip_info__to_dict
        ),
        security.VisibleSecurityState: (
            _map_security__visible_security_state__to_dict
        ),
        security.SecurityStateExplanation: (
            _map_security__security_state_explanation__to_dict
        ),
        security.InsecureContentStatus: (
            _map_security__insecure_content_status__to_dict
        ),
        service_worker.ServiceWorkerRegistration: (
            _map_service_worker__service_worker_registration__to_dict
        ),
        service_worker.ServiceWorkerVersion: (
            _map_service_worker__service_worker_version__to_dict
        ),
        service_worker.ServiceWorkerErrorMessage: (
            _map_service_worker__service_worker_error_message__to_dict
        ),
        storage.UsageForType: (
            _map_storage__usage_for_type__to_dict
        ),
        storage.TrustTokens: (
            _map_storage__trust_tokens__to_dict
        ),
        storage.InterestGroupAd: (
            _map_storage__interest_group_ad__to_dict
        ),
        storage.InterestGroupDetails: (
            _map_storage__interest_group_details__to_dict
        ),
        storage.SharedStorageEntry: (
            _map_storage__shared_storage_entry__to_dict
        ),
        storage.SharedStorageMetadata: (
            _map_storage__shared_storage_metadata__to_dict
        ),
        storage.SharedStorageReportingMetadata: (
            _map_storage__shared_storage_reporting_metadata__to_dict
        ),
        storage.SharedStorageUrlWithMetadata: (
            _map_storage__shared_storage_url_with_metadata__to_dict
        ),
        storage.SharedStorageAccessParams: (
            _map_storage__shared_storage_access_params__to_dict
        ),
        storage.StorageBucket: (
            _map_storage__storage_bucket__to_dict
        ),
        storage.StorageBucketInfo: (
            _map_storage__storage_bucket_info__to_dict
        ),
        storage.AttributionReportingFilterDataEntry: (
            _map_storage__attribution_reporting_filter_data_entry__to_dict
        ),
        storage.AttributionReportingAggregationKeysEntry: (
            _map_storage__attribution_reporting_aggregation_keys_entry__to_dict
        ),
        storage.AttributionReportingEventReportWindows: (
            _map_storage__attribution_reporting_event_report_windows__to_dict
        ),
        storage.AttributionReportingSourceRegistration: (
            _map_storage__attribution_reporting_source_registration__to_dict
        ),
        system_info.GPUDevice: (
            _map_system_info__gpu_device__to_dict
        ),
        system_info.Size: (
            _map_system_info__size__to_dict
        ),
        system_info.VideoDecodeAcceleratorCapability: (
            _map_system_info__video_decode_accelerator_capability__to_dict
        ),
        system_info.VideoEncodeAcceleratorCapability: (
            _map_system_info__video_encode_accelerator_capability__to_dict
        ),
        system_info.ImageDecodeAcceleratorCapability: (
            _map_system_info__image_decode_accelerator_capability__to_dict
        ),
        system_info.GPUInfo: (
            _map_system_info__gpu_info__to_dict
        ),
        system_info.ProcessInfo: (
            _map_system_info__process_info__to_dict
        ),
        target.TargetInfo: (
            _map_target__target_info__to_dict
        ),
        target.FilterEntry: (
            _map_target__filter_entry__to_dict
        ),
        target.RemoteLocation: (
            _map_target__remote_location__to_dict
        ),
        tracing.TraceConfig: (
            _map_tracing__trace_config__to_dict
        ),
        fetch.RequestPattern: (
            _map_fetch__request_pattern__to_dict
        ),
        fetch.HeaderEntry: (
            _map_fetch__header_entry__to_dict
        ),
        fetch.AuthChallenge: (
            _map_fetch__auth_challenge__to_dict
        ),
        fetch.AuthChallengeResponse: (
            _map_fetch__auth_challenge_response__to_dict
        ),
        web_audio.ContextRealtimeData: (
            _map_web_audio__context_realtime_data__to_dict
        ),
        web_audio.BaseAudioContext: (
            _map_web_audio__base_audio_context__to_dict
        ),
        web_audio.AudioListener: (
            _map_web_audio__audio_listener__to_dict
        ),
        web_audio.AudioNode: (
            _map_web_audio__audio_node__to_dict
        ),
        web_audio.AudioParam: (
            _map_web_audio__audio_param__to_dict
        ),
        web_authn.VirtualAuthenticatorOptions: (
            _map_web_authn__virtual_authenticator_options__to_dict
        ),
        web_authn.Credential: (
            _map_web_authn__credential__to_dict
        ),
        media.PlayerMessage: (
            _map_media__player_message__to_dict
        ),
        media.PlayerProperty: (
            _map_media__player_property__to_dict
        ),
        media.PlayerEvent: (
            _map_media__player_event__to_dict
        ),
        media.PlayerErrorSourceLocation: (
            _map_media__player_error_source_location__to_dict
        ),
        media.PlayerError: (
            _map_media__player_error__to_dict
        ),
        device_access.PromptDevice: (
            _map_device_access__prompt_device__to_dict
        ),
        preload.RuleSet: (
            _map_preload__rule_set__to_dict
        ),
        preload.PreloadingAttemptKey: (
            _map_preload__preloading_attempt_key__to_dict
        ),
        preload.PreloadingAttemptSource: (
            _map_preload__preloading_attempt_source__to_dict
        ),
        fed_cm.Account: (
            _map_fed_cm__account__to_dict
        ),
        console.ConsoleMessage: (
            _map_console__console_message__to_dict
        ),
        debugger.Location: (
            _map_debugger__location__to_dict
        ),
        debugger.ScriptPosition: (
            _map_debugger__script_position__to_dict
        ),
        debugger.CallFrame: (
            _map_debugger__call_frame__to_dict
        ),
        debugger.Scope: (
            _map_debugger__scope__to_dict
        ),
        debugger.SearchMatch: (
            _map_debugger__search_match__to_dict
        ),
        debugger.BreakLocation: (
            _map_debugger__break_location__to_dict
        ),
        heap_profiler.SamplingHeapProfileNode: (
            _map_heap_profiler__sampling_heap_profile_node__to_dict
        ),
        heap_profiler.SamplingHeapProfileSample: (
            _map_heap_profiler__sampling_heap_profile_sample__to_dict
        ),
        heap_profiler.SamplingHeapProfile: (
            _map_heap_profiler__sampling_heap_profile__to_dict
        ),
        profiler.ProfileNode: (
            _map_profiler__profile_node__to_dict
        ),
        profiler.Profile: (
            _map_profiler__profile__to_dict
        ),
        profiler.PositionTickInfo: (
            _map_profiler__position_tick_info__to_dict
        ),
        profiler.CoverageRange: (
            _map_profiler__coverage_range__to_dict
        ),
        profiler.FunctionCoverage: (
            _map_profiler__function_coverage__to_dict
        ),
        profiler.ScriptCoverage: (
            _map_profiler__script_coverage__to_dict
        ),
        profiler.TypeObject: (
            _map_profiler__type_object__to_dict
        ),
        profiler.TypeProfileEntry: (
            _map_profiler__type_profile_entry__to_dict
        ),
        profiler.ScriptTypeProfile: (
            _map_profiler__script_type_profile__to_dict
        ),
        runtime.RemoteObject: (
            _map_runtime__remote_object__to_dict
        ),
        runtime.CustomPreview: (
            _map_runtime__custom_preview__to_dict
        ),
        runtime.ObjectPreview: (
            _map_runtime__object_preview__to_dict
        ),
        runtime.PropertyPreview: (
            _map_runtime__property_preview__to_dict
        ),
        runtime.EntryPreview: (
            _map_runtime__entry_preview__to_dict
        ),
        runtime.PropertyDescriptor: (
            _map_runtime__property_descriptor__to_dict
        ),
        runtime.InternalPropertyDescriptor: (
            _map_runtime__internal_property_descriptor__to_dict
        ),
        runtime.PrivatePropertyDescriptor: (
            _map_runtime__private_property_descriptor__to_dict
        ),
        runtime.CallArgument: (
            _map_runtime__call_argument__to_dict
        ),
        runtime.ExecutionContextDescription: (
            _map_runtime__execution_context_description__to_dict
        ),
        runtime.ExceptionDetails: (
            _map_runtime__exception_details__to_dict
        ),
        runtime.CallFrame: (
            _map_runtime__call_frame__to_dict
        ),
        runtime.StackTrace: (
            _map_runtime__stack_trace__to_dict
        ),
        runtime.StackTraceId: (
            _map_runtime__stack_trace_id__to_dict
        ),
        schema.Domain: (
            _map_schema__domain__to_dict
        ),
    }
    return lookup[type(data)](
        data,
        casing_strategy
    )


def from_dict(dataclass_type: type[_T], data: dict, casing_strategy: CasingStrategyT) -> _T:
    lookup = {
        accessibility.AXValueSource: (
            _map_accessibility__ax_value_source__from_dict
        ),
        accessibility.AXRelatedNode: (
            _map_accessibility__ax_related_node__from_dict
        ),
        accessibility.AXProperty: (
            _map_accessibility__ax_property__from_dict
        ),
        accessibility.AXValue: (
            _map_accessibility__ax_value__from_dict
        ),
        accessibility.AXNode: (
            _map_accessibility__ax_node__from_dict
        ),
        animation.Animation: (
            _map_animation__animation__from_dict
        ),
        animation.AnimationEffect: (
            _map_animation__animation_effect__from_dict
        ),
        animation.KeyframesRule: (
            _map_animation__keyframes_rule__from_dict
        ),
        animation.KeyframeStyle: (
            _map_animation__keyframe_style__from_dict
        ),
        audits.AffectedCookie: (
            _map_audits__affected_cookie__from_dict
        ),
        audits.AffectedRequest: (
            _map_audits__affected_request__from_dict
        ),
        audits.AffectedFrame: (
            _map_audits__affected_frame__from_dict
        ),
        audits.CookieIssueDetails: (
            _map_audits__cookie_issue_details__from_dict
        ),
        audits.MixedContentIssueDetails: (
            _map_audits__mixed_content_issue_details__from_dict
        ),
        audits.BlockedByResponseIssueDetails: (
            _map_audits__blocked_by_response_issue_details__from_dict
        ),
        audits.HeavyAdIssueDetails: (
            _map_audits__heavy_ad_issue_details__from_dict
        ),
        audits.SourceCodeLocation: (
            _map_audits__source_code_location__from_dict
        ),
        audits.ContentSecurityPolicyIssueDetails: (
            _map_audits__content_security_policy_issue_details__from_dict
        ),
        audits.SharedArrayBufferIssueDetails: (
            _map_audits__shared_array_buffer_issue_details__from_dict
        ),
        audits.LowTextContrastIssueDetails: (
            _map_audits__low_text_contrast_issue_details__from_dict
        ),
        audits.CorsIssueDetails: (
            _map_audits__cors_issue_details__from_dict
        ),
        audits.AttributionReportingIssueDetails: (
            _map_audits__attribution_reporting_issue_details__from_dict
        ),
        audits.QuirksModeIssueDetails: (
            _map_audits__quirks_mode_issue_details__from_dict
        ),
        audits.NavigatorUserAgentIssueDetails: (
            _map_audits__navigator_user_agent_issue_details__from_dict
        ),
        audits.GenericIssueDetails: (
            _map_audits__generic_issue_details__from_dict
        ),
        audits.DeprecationIssueDetails: (
            _map_audits__deprecation_issue_details__from_dict
        ),
        audits.BounceTrackingIssueDetails: (
            _map_audits__bounce_tracking_issue_details__from_dict
        ),
        audits.FederatedAuthRequestIssueDetails: (
            _map_audits__federated_auth_request_issue_details__from_dict
        ),
        audits.FederatedAuthUserInfoRequestIssueDetails: (
            _map_audits__federated_auth_user_info_request_issue_details__from_dict
        ),
        audits.ClientHintIssueDetails: (
            _map_audits__client_hint_issue_details__from_dict
        ),
        audits.FailedRequestInfo: (
            _map_audits__failed_request_info__from_dict
        ),
        audits.StylesheetLoadingIssueDetails: (
            _map_audits__stylesheet_loading_issue_details__from_dict
        ),
        audits.InspectorIssueDetails: (
            _map_audits__inspector_issue_details__from_dict
        ),
        audits.InspectorIssue: (
            _map_audits__inspector_issue__from_dict
        ),
        autofill.CreditCard: (
            _map_autofill__credit_card__from_dict
        ),
        autofill.AddressField: (
            _map_autofill__address_field__from_dict
        ),
        autofill.AddressFields: (
            _map_autofill__address_fields__from_dict
        ),
        autofill.Address: (
            _map_autofill__address__from_dict
        ),
        autofill.AddressUI: (
            _map_autofill__address_ui__from_dict
        ),
        autofill.FilledField: (
            _map_autofill__filled_field__from_dict
        ),
        background_service.EventMetadata: (
            _map_background_service__event_metadata__from_dict
        ),
        background_service.BackgroundServiceEvent: (
            _map_background_service__background_service_event__from_dict
        ),
        browser.Bounds: (
            _map_browser__bounds__from_dict
        ),
        browser.PermissionDescriptor: (
            _map_browser__permission_descriptor__from_dict
        ),
        browser.Bucket: (
            _map_browser__bucket__from_dict
        ),
        browser.Histogram: (
            _map_browser__histogram__from_dict
        ),
        css.PseudoElementMatches: (
            _map_css__pseudo_element_matches__from_dict
        ),
        css.InheritedStyleEntry: (
            _map_css__inherited_style_entry__from_dict
        ),
        css.InheritedPseudoElementMatches: (
            _map_css__inherited_pseudo_element_matches__from_dict
        ),
        css.RuleMatch: (
            _map_css__rule_match__from_dict
        ),
        css.Value: (
            _map_css__value__from_dict
        ),
        css.Specificity: (
            _map_css__specificity__from_dict
        ),
        css.SelectorList: (
            _map_css__selector_list__from_dict
        ),
        css.CSSStyleSheetHeader: (
            _map_css__css_style_sheet_header__from_dict
        ),
        css.CSSRule: (
            _map_css__css_rule__from_dict
        ),
        css.RuleUsage: (
            _map_css__rule_usage__from_dict
        ),
        css.SourceRange: (
            _map_css__source_range__from_dict
        ),
        css.ShorthandEntry: (
            _map_css__shorthand_entry__from_dict
        ),
        css.CSSComputedStyleProperty: (
            _map_css__css_computed_style_property__from_dict
        ),
        css.CSSStyle: (
            _map_css__css_style__from_dict
        ),
        css.CSSProperty: (
            _map_css__css_property__from_dict
        ),
        css.CSSMedia: (
            _map_css__css_media__from_dict
        ),
        css.MediaQuery: (
            _map_css__media_query__from_dict
        ),
        css.MediaQueryExpression: (
            _map_css__media_query_expression__from_dict
        ),
        css.CSSContainerQuery: (
            _map_css__css_container_query__from_dict
        ),
        css.CSSSupports: (
            _map_css__css_supports__from_dict
        ),
        css.CSSScope: (
            _map_css__css_scope__from_dict
        ),
        css.CSSLayer: (
            _map_css__css_layer__from_dict
        ),
        css.CSSLayerData: (
            _map_css__css_layer_data__from_dict
        ),
        css.PlatformFontUsage: (
            _map_css__platform_font_usage__from_dict
        ),
        css.FontVariationAxis: (
            _map_css__font_variation_axis__from_dict
        ),
        css.FontFace: (
            _map_css__font_face__from_dict
        ),
        css.CSSTryRule: (
            _map_css__css_try_rule__from_dict
        ),
        css.CSSPositionFallbackRule: (
            _map_css__css_position_fallback_rule__from_dict
        ),
        css.CSSKeyframesRule: (
            _map_css__css_keyframes_rule__from_dict
        ),
        css.CSSPropertyRegistration: (
            _map_css__css_property_registration__from_dict
        ),
        css.CSSPropertyRule: (
            _map_css__css_property_rule__from_dict
        ),
        css.CSSKeyframeRule: (
            _map_css__css_keyframe_rule__from_dict
        ),
        css.StyleDeclarationEdit: (
            _map_css__style_declaration_edit__from_dict
        ),
        cache_storage.DataEntry: (
            _map_cache_storage__data_entry__from_dict
        ),
        cache_storage.Cache: (
            _map_cache_storage__cache__from_dict
        ),
        cache_storage.Header: (
            _map_cache_storage__header__from_dict
        ),
        cache_storage.CachedResponse: (
            _map_cache_storage__cached_response__from_dict
        ),
        cast.Sink: (
            _map_cast__sink__from_dict
        ),
        dom.BackendNode: (
            _map_dom__backend_node__from_dict
        ),
        dom.Node: (
            _map_dom__node__from_dict
        ),
        dom.RGBA: (
            _map_dom__rgba__from_dict
        ),
        dom.BoxModel: (
            _map_dom__box_model__from_dict
        ),
        dom.ShapeOutsideInfo: (
            _map_dom__shape_outside_info__from_dict
        ),
        dom.Rect: (
            _map_dom__rect__from_dict
        ),
        dom.CSSComputedStyleProperty: (
            _map_dom__css_computed_style_property__from_dict
        ),
        dom_debugger.EventListener: (
            _map_dom_debugger__event_listener__from_dict
        ),
        dom_snapshot.DOMNode: (
            _map_dom_snapshot__dom_node__from_dict
        ),
        dom_snapshot.InlineTextBox: (
            _map_dom_snapshot__inline_text_box__from_dict
        ),
        dom_snapshot.LayoutTreeNode: (
            _map_dom_snapshot__layout_tree_node__from_dict
        ),
        dom_snapshot.ComputedStyle: (
            _map_dom_snapshot__computed_style__from_dict
        ),
        dom_snapshot.NameValue: (
            _map_dom_snapshot__name_value__from_dict
        ),
        dom_snapshot.RareStringData: (
            _map_dom_snapshot__rare_string_data__from_dict
        ),
        dom_snapshot.RareBooleanData: (
            _map_dom_snapshot__rare_boolean_data__from_dict
        ),
        dom_snapshot.RareIntegerData: (
            _map_dom_snapshot__rare_integer_data__from_dict
        ),
        dom_snapshot.DocumentSnapshot: (
            _map_dom_snapshot__document_snapshot__from_dict
        ),
        dom_snapshot.NodeTreeSnapshot: (
            _map_dom_snapshot__node_tree_snapshot__from_dict
        ),
        dom_snapshot.LayoutTreeSnapshot: (
            _map_dom_snapshot__layout_tree_snapshot__from_dict
        ),
        dom_snapshot.TextBoxSnapshot: (
            _map_dom_snapshot__text_box_snapshot__from_dict
        ),
        dom_storage.StorageId: (
            _map_dom_storage__storage_id__from_dict
        ),
        database.Database: (
            _map_database__database__from_dict
        ),
        database.Error: (
            _map_database__error__from_dict
        ),
        emulation.ScreenOrientation: (
            _map_emulation__screen_orientation__from_dict
        ),
        emulation.DisplayFeature: (
            _map_emulation__display_feature__from_dict
        ),
        emulation.MediaFeature: (
            _map_emulation__media_feature__from_dict
        ),
        emulation.UserAgentBrandVersion: (
            _map_emulation__user_agent_brand_version__from_dict
        ),
        emulation.UserAgentMetadata: (
            _map_emulation__user_agent_metadata__from_dict
        ),
        headless_experimental.ScreenshotParams: (
            _map_headless_experimental__screenshot_params__from_dict
        ),
        indexed_db.DatabaseWithObjectStores: (
            _map_indexed_db__database_with_object_stores__from_dict
        ),
        indexed_db.ObjectStore: (
            _map_indexed_db__object_store__from_dict
        ),
        indexed_db.ObjectStoreIndex: (
            _map_indexed_db__object_store_index__from_dict
        ),
        indexed_db.Key: (
            _map_indexed_db__key__from_dict
        ),
        indexed_db.KeyRange: (
            _map_indexed_db__key_range__from_dict
        ),
        indexed_db.DataEntry: (
            _map_indexed_db__data_entry__from_dict
        ),
        indexed_db.KeyPath: (
            _map_indexed_db__key_path__from_dict
        ),
        input_.TouchPoint: (
            _map_input__touch_point__from_dict
        ),
        input_.DragDataItem: (
            _map_input__drag_data_item__from_dict
        ),
        input_.DragData: (
            _map_input__drag_data__from_dict
        ),
        layer_tree.ScrollRect: (
            _map_layer_tree__scroll_rect__from_dict
        ),
        layer_tree.StickyPositionConstraint: (
            _map_layer_tree__sticky_position_constraint__from_dict
        ),
        layer_tree.PictureTile: (
            _map_layer_tree__picture_tile__from_dict
        ),
        layer_tree.Layer: (
            _map_layer_tree__layer__from_dict
        ),
        log.LogEntry: (
            _map_log__log_entry__from_dict
        ),
        log.ViolationSetting: (
            _map_log__violation_setting__from_dict
        ),
        memory.SamplingProfileNode: (
            _map_memory__sampling_profile_node__from_dict
        ),
        memory.SamplingProfile: (
            _map_memory__sampling_profile__from_dict
        ),
        memory.Module: (
            _map_memory__module__from_dict
        ),
        network.ResourceTiming: (
            _map_network__resource_timing__from_dict
        ),
        network.PostDataEntry: (
            _map_network__post_data_entry__from_dict
        ),
        network.Request: (
            _map_network__request__from_dict
        ),
        network.SignedCertificateTimestamp: (
            _map_network__signed_certificate_timestamp__from_dict
        ),
        network.SecurityDetails: (
            _map_network__security_details__from_dict
        ),
        network.CorsErrorStatus: (
            _map_network__cors_error_status__from_dict
        ),
        network.TrustTokenParams: (
            _map_network__trust_token_params__from_dict
        ),
        network.Response: (
            _map_network__response__from_dict
        ),
        network.WebSocketRequest: (
            _map_network__web_socket_request__from_dict
        ),
        network.WebSocketResponse: (
            _map_network__web_socket_response__from_dict
        ),
        network.WebSocketFrame: (
            _map_network__web_socket_frame__from_dict
        ),
        network.CachedResource: (
            _map_network__cached_resource__from_dict
        ),
        network.Initiator: (
            _map_network__initiator__from_dict
        ),
        network.Cookie: (
            _map_network__cookie__from_dict
        ),
        network.BlockedSetCookieWithReason: (
            _map_network__blocked_set_cookie_with_reason__from_dict
        ),
        network.BlockedCookieWithReason: (
            _map_network__blocked_cookie_with_reason__from_dict
        ),
        network.CookieParam: (
            _map_network__cookie_param__from_dict
        ),
        network.AuthChallenge: (
            _map_network__auth_challenge__from_dict
        ),
        network.AuthChallengeResponse: (
            _map_network__auth_challenge_response__from_dict
        ),
        network.RequestPattern: (
            _map_network__request_pattern__from_dict
        ),
        network.SignedExchangeSignature: (
            _map_network__signed_exchange_signature__from_dict
        ),
        network.SignedExchangeHeader: (
            _map_network__signed_exchange_header__from_dict
        ),
        network.SignedExchangeError: (
            _map_network__signed_exchange_error__from_dict
        ),
        network.SignedExchangeInfo: (
            _map_network__signed_exchange_info__from_dict
        ),
        network.ConnectTiming: (
            _map_network__connect_timing__from_dict
        ),
        network.ClientSecurityState: (
            _map_network__client_security_state__from_dict
        ),
        network.CrossOriginOpenerPolicyStatus: (
            _map_network__cross_origin_opener_policy_status__from_dict
        ),
        network.CrossOriginEmbedderPolicyStatus: (
            _map_network__cross_origin_embedder_policy_status__from_dict
        ),
        network.ContentSecurityPolicyStatus: (
            _map_network__content_security_policy_status__from_dict
        ),
        network.SecurityIsolationStatus: (
            _map_network__security_isolation_status__from_dict
        ),
        network.ReportingApiReport: (
            _map_network__reporting_api_report__from_dict
        ),
        network.ReportingApiEndpoint: (
            _map_network__reporting_api_endpoint__from_dict
        ),
        network.LoadNetworkResourcePageResult: (
            _map_network__load_network_resource_page_result__from_dict
        ),
        network.LoadNetworkResourceOptions: (
            _map_network__load_network_resource_options__from_dict
        ),
        overlay.SourceOrderConfig: (
            _map_overlay__source_order_config__from_dict
        ),
        overlay.GridHighlightConfig: (
            _map_overlay__grid_highlight_config__from_dict
        ),
        overlay.FlexContainerHighlightConfig: (
            _map_overlay__flex_container_highlight_config__from_dict
        ),
        overlay.FlexItemHighlightConfig: (
            _map_overlay__flex_item_highlight_config__from_dict
        ),
        overlay.LineStyle: (
            _map_overlay__line_style__from_dict
        ),
        overlay.BoxStyle: (
            _map_overlay__box_style__from_dict
        ),
        overlay.HighlightConfig: (
            _map_overlay__highlight_config__from_dict
        ),
        overlay.GridNodeHighlightConfig: (
            _map_overlay__grid_node_highlight_config__from_dict
        ),
        overlay.FlexNodeHighlightConfig: (
            _map_overlay__flex_node_highlight_config__from_dict
        ),
        overlay.ScrollSnapContainerHighlightConfig: (
            _map_overlay__scroll_snap_container_highlight_config__from_dict
        ),
        overlay.ScrollSnapHighlightConfig: (
            _map_overlay__scroll_snap_highlight_config__from_dict
        ),
        overlay.HingeConfig: (
            _map_overlay__hinge_config__from_dict
        ),
        overlay.ContainerQueryHighlightConfig: (
            _map_overlay__container_query_highlight_config__from_dict
        ),
        overlay.ContainerQueryContainerHighlightConfig: (
            _map_overlay__container_query_container_highlight_config__from_dict
        ),
        overlay.IsolatedElementHighlightConfig: (
            _map_overlay__isolated_element_highlight_config__from_dict
        ),
        overlay.IsolationModeHighlightConfig: (
            _map_overlay__isolation_mode_highlight_config__from_dict
        ),
        page.AdFrameStatus: (
            _map_page__ad_frame_status__from_dict
        ),
        page.AdScriptId: (
            _map_page__ad_script_id__from_dict
        ),
        page.PermissionsPolicyBlockLocator: (
            _map_page__permissions_policy_block_locator__from_dict
        ),
        page.PermissionsPolicyFeatureState: (
            _map_page__permissions_policy_feature_state__from_dict
        ),
        page.OriginTrialToken: (
            _map_page__origin_trial_token__from_dict
        ),
        page.OriginTrialTokenWithStatus: (
            _map_page__origin_trial_token_with_status__from_dict
        ),
        page.OriginTrial: (
            _map_page__origin_trial__from_dict
        ),
        page.Frame: (
            _map_page__frame__from_dict
        ),
        page.FrameResource: (
            _map_page__frame_resource__from_dict
        ),
        page.FrameResourceTree: (
            _map_page__frame_resource_tree__from_dict
        ),
        page.FrameTree: (
            _map_page__frame_tree__from_dict
        ),
        page.NavigationEntry: (
            _map_page__navigation_entry__from_dict
        ),
        page.ScreencastFrameMetadata: (
            _map_page__screencast_frame_metadata__from_dict
        ),
        page.AppManifestError: (
            _map_page__app_manifest_error__from_dict
        ),
        page.AppManifestParsedProperties: (
            _map_page__app_manifest_parsed_properties__from_dict
        ),
        page.LayoutViewport: (
            _map_page__layout_viewport__from_dict
        ),
        page.VisualViewport: (
            _map_page__visual_viewport__from_dict
        ),
        page.Viewport: (
            _map_page__viewport__from_dict
        ),
        page.FontFamilies: (
            _map_page__font_families__from_dict
        ),
        page.ScriptFontFamilies: (
            _map_page__script_font_families__from_dict
        ),
        page.FontSizes: (
            _map_page__font_sizes__from_dict
        ),
        page.InstallabilityErrorArgument: (
            _map_page__installability_error_argument__from_dict
        ),
        page.InstallabilityError: (
            _map_page__installability_error__from_dict
        ),
        page.CompilationCacheParams: (
            _map_page__compilation_cache_params__from_dict
        ),
        page.BackForwardCacheNotRestoredExplanation: (
            _map_page__back_forward_cache_not_restored_explanation__from_dict
        ),
        page.BackForwardCacheNotRestoredExplanationTree: (
            _map_page__back_forward_cache_not_restored_explanation_tree__from_dict
        ),
        performance.Metric: (
            _map_performance__metric__from_dict
        ),
        performance_timeline.LargestContentfulPaint: (
            _map_performance_timeline__largest_contentful_paint__from_dict
        ),
        performance_timeline.LayoutShiftAttribution: (
            _map_performance_timeline__layout_shift_attribution__from_dict
        ),
        performance_timeline.LayoutShift: (
            _map_performance_timeline__layout_shift__from_dict
        ),
        performance_timeline.TimelineEvent: (
            _map_performance_timeline__timeline_event__from_dict
        ),
        security.CertificateSecurityState: (
            _map_security__certificate_security_state__from_dict
        ),
        security.SafetyTipInfo: (
            _map_security__safety_tip_info__from_dict
        ),
        security.VisibleSecurityState: (
            _map_security__visible_security_state__from_dict
        ),
        security.SecurityStateExplanation: (
            _map_security__security_state_explanation__from_dict
        ),
        security.InsecureContentStatus: (
            _map_security__insecure_content_status__from_dict
        ),
        service_worker.ServiceWorkerRegistration: (
            _map_service_worker__service_worker_registration__from_dict
        ),
        service_worker.ServiceWorkerVersion: (
            _map_service_worker__service_worker_version__from_dict
        ),
        service_worker.ServiceWorkerErrorMessage: (
            _map_service_worker__service_worker_error_message__from_dict
        ),
        storage.UsageForType: (
            _map_storage__usage_for_type__from_dict
        ),
        storage.TrustTokens: (
            _map_storage__trust_tokens__from_dict
        ),
        storage.InterestGroupAd: (
            _map_storage__interest_group_ad__from_dict
        ),
        storage.InterestGroupDetails: (
            _map_storage__interest_group_details__from_dict
        ),
        storage.SharedStorageEntry: (
            _map_storage__shared_storage_entry__from_dict
        ),
        storage.SharedStorageMetadata: (
            _map_storage__shared_storage_metadata__from_dict
        ),
        storage.SharedStorageReportingMetadata: (
            _map_storage__shared_storage_reporting_metadata__from_dict
        ),
        storage.SharedStorageUrlWithMetadata: (
            _map_storage__shared_storage_url_with_metadata__from_dict
        ),
        storage.SharedStorageAccessParams: (
            _map_storage__shared_storage_access_params__from_dict
        ),
        storage.StorageBucket: (
            _map_storage__storage_bucket__from_dict
        ),
        storage.StorageBucketInfo: (
            _map_storage__storage_bucket_info__from_dict
        ),
        storage.AttributionReportingFilterDataEntry: (
            _map_storage__attribution_reporting_filter_data_entry__from_dict
        ),
        storage.AttributionReportingAggregationKeysEntry: (
            _map_storage__attribution_reporting_aggregation_keys_entry__from_dict
        ),
        storage.AttributionReportingEventReportWindows: (
            _map_storage__attribution_reporting_event_report_windows__from_dict
        ),
        storage.AttributionReportingSourceRegistration: (
            _map_storage__attribution_reporting_source_registration__from_dict
        ),
        system_info.GPUDevice: (
            _map_system_info__gpu_device__from_dict
        ),
        system_info.Size: (
            _map_system_info__size__from_dict
        ),
        system_info.VideoDecodeAcceleratorCapability: (
            _map_system_info__video_decode_accelerator_capability__from_dict
        ),
        system_info.VideoEncodeAcceleratorCapability: (
            _map_system_info__video_encode_accelerator_capability__from_dict
        ),
        system_info.ImageDecodeAcceleratorCapability: (
            _map_system_info__image_decode_accelerator_capability__from_dict
        ),
        system_info.GPUInfo: (
            _map_system_info__gpu_info__from_dict
        ),
        system_info.ProcessInfo: (
            _map_system_info__process_info__from_dict
        ),
        target.TargetInfo: (
            _map_target__target_info__from_dict
        ),
        target.FilterEntry: (
            _map_target__filter_entry__from_dict
        ),
        target.RemoteLocation: (
            _map_target__remote_location__from_dict
        ),
        tracing.TraceConfig: (
            _map_tracing__trace_config__from_dict
        ),
        fetch.RequestPattern: (
            _map_fetch__request_pattern__from_dict
        ),
        fetch.HeaderEntry: (
            _map_fetch__header_entry__from_dict
        ),
        fetch.AuthChallenge: (
            _map_fetch__auth_challenge__from_dict
        ),
        fetch.AuthChallengeResponse: (
            _map_fetch__auth_challenge_response__from_dict
        ),
        web_audio.ContextRealtimeData: (
            _map_web_audio__context_realtime_data__from_dict
        ),
        web_audio.BaseAudioContext: (
            _map_web_audio__base_audio_context__from_dict
        ),
        web_audio.AudioListener: (
            _map_web_audio__audio_listener__from_dict
        ),
        web_audio.AudioNode: (
            _map_web_audio__audio_node__from_dict
        ),
        web_audio.AudioParam: (
            _map_web_audio__audio_param__from_dict
        ),
        web_authn.VirtualAuthenticatorOptions: (
            _map_web_authn__virtual_authenticator_options__from_dict
        ),
        web_authn.Credential: (
            _map_web_authn__credential__from_dict
        ),
        media.PlayerMessage: (
            _map_media__player_message__from_dict
        ),
        media.PlayerProperty: (
            _map_media__player_property__from_dict
        ),
        media.PlayerEvent: (
            _map_media__player_event__from_dict
        ),
        media.PlayerErrorSourceLocation: (
            _map_media__player_error_source_location__from_dict
        ),
        media.PlayerError: (
            _map_media__player_error__from_dict
        ),
        device_access.PromptDevice: (
            _map_device_access__prompt_device__from_dict
        ),
        preload.RuleSet: (
            _map_preload__rule_set__from_dict
        ),
        preload.PreloadingAttemptKey: (
            _map_preload__preloading_attempt_key__from_dict
        ),
        preload.PreloadingAttemptSource: (
            _map_preload__preloading_attempt_source__from_dict
        ),
        fed_cm.Account: (
            _map_fed_cm__account__from_dict
        ),
        console.ConsoleMessage: (
            _map_console__console_message__from_dict
        ),
        debugger.Location: (
            _map_debugger__location__from_dict
        ),
        debugger.ScriptPosition: (
            _map_debugger__script_position__from_dict
        ),
        debugger.CallFrame: (
            _map_debugger__call_frame__from_dict
        ),
        debugger.Scope: (
            _map_debugger__scope__from_dict
        ),
        debugger.SearchMatch: (
            _map_debugger__search_match__from_dict
        ),
        debugger.BreakLocation: (
            _map_debugger__break_location__from_dict
        ),
        heap_profiler.SamplingHeapProfileNode: (
            _map_heap_profiler__sampling_heap_profile_node__from_dict
        ),
        heap_profiler.SamplingHeapProfileSample: (
            _map_heap_profiler__sampling_heap_profile_sample__from_dict
        ),
        heap_profiler.SamplingHeapProfile: (
            _map_heap_profiler__sampling_heap_profile__from_dict
        ),
        profiler.ProfileNode: (
            _map_profiler__profile_node__from_dict
        ),
        profiler.Profile: (
            _map_profiler__profile__from_dict
        ),
        profiler.PositionTickInfo: (
            _map_profiler__position_tick_info__from_dict
        ),
        profiler.CoverageRange: (
            _map_profiler__coverage_range__from_dict
        ),
        profiler.FunctionCoverage: (
            _map_profiler__function_coverage__from_dict
        ),
        profiler.ScriptCoverage: (
            _map_profiler__script_coverage__from_dict
        ),
        profiler.TypeObject: (
            _map_profiler__type_object__from_dict
        ),
        profiler.TypeProfileEntry: (
            _map_profiler__type_profile_entry__from_dict
        ),
        profiler.ScriptTypeProfile: (
            _map_profiler__script_type_profile__from_dict
        ),
        runtime.RemoteObject: (
            _map_runtime__remote_object__from_dict
        ),
        runtime.CustomPreview: (
            _map_runtime__custom_preview__from_dict
        ),
        runtime.ObjectPreview: (
            _map_runtime__object_preview__from_dict
        ),
        runtime.PropertyPreview: (
            _map_runtime__property_preview__from_dict
        ),
        runtime.EntryPreview: (
            _map_runtime__entry_preview__from_dict
        ),
        runtime.PropertyDescriptor: (
            _map_runtime__property_descriptor__from_dict
        ),
        runtime.InternalPropertyDescriptor: (
            _map_runtime__internal_property_descriptor__from_dict
        ),
        runtime.PrivatePropertyDescriptor: (
            _map_runtime__private_property_descriptor__from_dict
        ),
        runtime.CallArgument: (
            _map_runtime__call_argument__from_dict
        ),
        runtime.ExecutionContextDescription: (
            _map_runtime__execution_context_description__from_dict
        ),
        runtime.ExceptionDetails: (
            _map_runtime__exception_details__from_dict
        ),
        runtime.CallFrame: (
            _map_runtime__call_frame__from_dict
        ),
        runtime.StackTrace: (
            _map_runtime__stack_trace__from_dict
        ),
        runtime.StackTraceId: (
            _map_runtime__stack_trace_id__from_dict
        ),
        schema.Domain: (
            _map_schema__domain__from_dict
        ),
    }
    return lookup[dataclass_type](
        data,
        casing_strategy
    )
