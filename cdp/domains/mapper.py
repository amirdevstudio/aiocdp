# DO NOT EDIT THIS FILE
#
# This file is generated by the generator. To make changes, edit the generator
# and run it again.

from typing import (
    TypeVar
)
from cdp.domains.utils import (
    CasingStrategyT
)
from cdp.domains.accessibility import (
    types as accessibility
)
from cdp.domains.animation import (
    types as animation
)
from cdp.domains.audits import (
    types as audits
)
from cdp.domains.autofill import (
    types as autofill
)
from cdp.domains.background_service import (
    types as background_service
)
from cdp.domains.browser import (
    types as browser
)
from cdp.domains.css import (
    types as css
)
from cdp.domains.cache_storage import (
    types as cache_storage
)
from cdp.domains.cast import (
    types as cast
)
from cdp.domains.dom import (
    types as dom
)
from cdp.domains.dom_debugger import (
    types as dom_debugger
)
from cdp.domains.event_breakpoints import (
    types as event_breakpoints
)
from cdp.domains.dom_snapshot import (
    types as dom_snapshot
)
from cdp.domains.dom_storage import (
    types as dom_storage
)
from cdp.domains.database import (
    types as database
)
from cdp.domains.device_orientation import (
    types as device_orientation
)
from cdp.domains.emulation import (
    types as emulation
)
from cdp.domains.headless_experimental import (
    types as headless_experimental
)
from cdp.domains.io import (
    types as io
)
from cdp.domains.indexed_db import (
    types as indexed_db
)
from cdp.domains.input import (
    types as input_
)
from cdp.domains.inspector import (
    types as inspector
)
from cdp.domains.layer_tree import (
    types as layer_tree
)
from cdp.domains.log import (
    types as log
)
from cdp.domains.memory import (
    types as memory
)
from cdp.domains.network import (
    types as network
)
from cdp.domains.overlay import (
    types as overlay
)
from cdp.domains.page import (
    types as page
)
from cdp.domains.performance import (
    types as performance
)
from cdp.domains.performance_timeline import (
    types as performance_timeline
)
from cdp.domains.security import (
    types as security
)
from cdp.domains.service_worker import (
    types as service_worker
)
from cdp.domains.storage import (
    types as storage
)
from cdp.domains.system_info import (
    types as system_info
)
from cdp.domains.target import (
    types as target
)
from cdp.domains.tethering import (
    types as tethering
)
from cdp.domains.tracing import (
    types as tracing
)
from cdp.domains.fetch import (
    types as fetch
)
from cdp.domains.web_audio import (
    types as web_audio
)
from cdp.domains.web_authn import (
    types as web_authn
)
from cdp.domains.media import (
    types as media
)
from cdp.domains.device_access import (
    types as device_access
)
from cdp.domains.preload import (
    types as preload
)
from cdp.domains.fed_cm import (
    types as fed_cm
)
from cdp.domains.console import (
    types as console
)
from cdp.domains.debugger import (
    types as debugger
)
from cdp.domains.heap_profiler import (
    types as heap_profiler
)
from cdp.domains.profiler import (
    types as profiler
)
from cdp.domains.runtime import (
    types as runtime
)
from cdp.domains.schema import (
    types as schema
)

_T = TypeVar('_T')

def _accessibility__ax_value_source__to_dict(
        data: 'accessibility.AXValueSource',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'value': to_dict(
                data.value,
                casing_strategy
            ),
            'attribute': data.attribute,
            'attribute_value': to_dict(
                data.attribute_value,
                casing_strategy
            ),
            'superseded': data.superseded,
            'native_source': data.native_source,
            'native_source_value': to_dict(
                data.native_source_value,
                casing_strategy
            ),
            'invalid': data.invalid,
            'invalid_reason': data.invalid_reason,
        }

    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'value': to_dict(
                data.value,
                casing_strategy
            ),
            'attribute': data.attribute,
            'attributeValue': to_dict(
                data.attribute_value,
                casing_strategy
            ),
            'superseded': data.superseded,
            'nativeSource': data.native_source,
            'nativeSourceValue': to_dict(
                data.native_source_value,
                casing_strategy
            ),
            'invalid': data.invalid,
            'invalidReason': data.invalid_reason,
        }

    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'Value': to_dict(
                data.value,
                casing_strategy
            ),
            'Attribute': data.attribute,
            'AttributeValue': to_dict(
                data.attribute_value,
                casing_strategy
            ),
            'Superseded': data.superseded,
            'NativeSource': data.native_source,
            'NativeSourceValue': to_dict(
                data.native_source_value,
                casing_strategy
            ),
            'Invalid': data.invalid,
            'InvalidReason': data.invalid_reason,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _accessibility__ax_related_node__to_dict(
        data: 'accessibility.AXRelatedNode',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'backend_dom_node_id': data.backend_dom_node_id,
            'idref': data.idref,
            'text': data.text,
        }

    if casing_strategy == 'camel':
        return {
            'backendDOMNodeId': data.backend_dom_node_id,
            'idref': data.idref,
            'text': data.text,
        }

    if casing_strategy == 'pascal':
        return {
            'BackendDOMNodeId': data.backend_dom_node_id,
            'Idref': data.idref,
            'Text': data.text,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _accessibility__ax_property__to_dict(
        data: 'accessibility.AXProperty',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': to_dict(
                data.value,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': to_dict(
                data.value,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': to_dict(
                data.value,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _accessibility__ax_value__to_dict(
        data: 'accessibility.AXValue',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'value': data.value,
            'related_nodes': [
                to_dict(item, casing_strategy)
                for item in data.related_nodes
            ],
            'sources': [
                to_dict(item, casing_strategy)
                for item in data.sources
            ],
        }

    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'value': data.value,
            'relatedNodes': [
                to_dict(item, casing_strategy)
                for item in data.related_nodes
            ],
            'sources': [
                to_dict(item, casing_strategy)
                for item in data.sources
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'Value': data.value,
            'RelatedNodes': [
                to_dict(item, casing_strategy)
                for item in data.related_nodes
            ],
            'Sources': [
                to_dict(item, casing_strategy)
                for item in data.sources
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _accessibility__ax_node__to_dict(
        data: 'accessibility.AXNode',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'node_id': data.node_id,
            'ignored': data.ignored,
            'ignored_reasons': [
                to_dict(item, casing_strategy)
                for item in data.ignored_reasons
            ],
            'role': to_dict(
                data.role,
                casing_strategy
            ),
            'chrome_role': to_dict(
                data.chrome_role,
                casing_strategy
            ),
            'name': to_dict(
                data.name,
                casing_strategy
            ),
            'description': to_dict(
                data.description,
                casing_strategy
            ),
            'value': to_dict(
                data.value,
                casing_strategy
            ),
            'properties': [
                to_dict(item, casing_strategy)
                for item in data.properties
            ],
            'parent_id': data.parent_id,
            'child_ids': data.child_ids,
            'backend_dom_node_id': data.backend_dom_node_id,
            'frame_id': data.frame_id,
        }

    if casing_strategy == 'camel':
        return {
            'nodeId': data.node_id,
            'ignored': data.ignored,
            'ignoredReasons': [
                to_dict(item, casing_strategy)
                for item in data.ignored_reasons
            ],
            'role': to_dict(
                data.role,
                casing_strategy
            ),
            'chromeRole': to_dict(
                data.chrome_role,
                casing_strategy
            ),
            'name': to_dict(
                data.name,
                casing_strategy
            ),
            'description': to_dict(
                data.description,
                casing_strategy
            ),
            'value': to_dict(
                data.value,
                casing_strategy
            ),
            'properties': [
                to_dict(item, casing_strategy)
                for item in data.properties
            ],
            'parentId': data.parent_id,
            'childIds': data.child_ids,
            'backendDOMNodeId': data.backend_dom_node_id,
            'frameId': data.frame_id,
        }

    if casing_strategy == 'pascal':
        return {
            'NodeId': data.node_id,
            'Ignored': data.ignored,
            'IgnoredReasons': [
                to_dict(item, casing_strategy)
                for item in data.ignored_reasons
            ],
            'Role': to_dict(
                data.role,
                casing_strategy
            ),
            'ChromeRole': to_dict(
                data.chrome_role,
                casing_strategy
            ),
            'Name': to_dict(
                data.name,
                casing_strategy
            ),
            'Description': to_dict(
                data.description,
                casing_strategy
            ),
            'Value': to_dict(
                data.value,
                casing_strategy
            ),
            'Properties': [
                to_dict(item, casing_strategy)
                for item in data.properties
            ],
            'ParentId': data.parent_id,
            'ChildIds': data.child_ids,
            'BackendDOMNodeId': data.backend_dom_node_id,
            'FrameId': data.frame_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _animation__animation__to_dict(
        data: 'animation.Animation',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'id': data.id,
            'name': data.name,
            'paused_state': data.paused_state,
            'play_state': data.play_state,
            'playback_rate': data.playback_rate,
            'start_time': data.start_time,
            'current_time': data.current_time,
            'type': data.type,
            'source': to_dict(
                data.source,
                casing_strategy
            ),
            'css_id': data.css_id,
        }

    if casing_strategy == 'camel':
        return {
            'id': data.id,
            'name': data.name,
            'pausedState': data.paused_state,
            'playState': data.play_state,
            'playbackRate': data.playback_rate,
            'startTime': data.start_time,
            'currentTime': data.current_time,
            'type': data.type,
            'source': to_dict(
                data.source,
                casing_strategy
            ),
            'cssId': data.css_id,
        }

    if casing_strategy == 'pascal':
        return {
            'Id': data.id,
            'Name': data.name,
            'PausedState': data.paused_state,
            'PlayState': data.play_state,
            'PlaybackRate': data.playback_rate,
            'StartTime': data.start_time,
            'CurrentTime': data.current_time,
            'Type': data.type,
            'Source': to_dict(
                data.source,
                casing_strategy
            ),
            'CssId': data.css_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _animation__animation_effect__to_dict(
        data: 'animation.AnimationEffect',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'delay': data.delay,
            'end_delay': data.end_delay,
            'iteration_start': data.iteration_start,
            'iterations': data.iterations,
            'duration': data.duration,
            'direction': data.direction,
            'fill': data.fill,
            'backend_node_id': data.backend_node_id,
            'keyframes_rule': to_dict(
                data.keyframes_rule,
                casing_strategy
            ),
            'easing': data.easing,
        }

    if casing_strategy == 'camel':
        return {
            'delay': data.delay,
            'endDelay': data.end_delay,
            'iterationStart': data.iteration_start,
            'iterations': data.iterations,
            'duration': data.duration,
            'direction': data.direction,
            'fill': data.fill,
            'backendNodeId': data.backend_node_id,
            'keyframesRule': to_dict(
                data.keyframes_rule,
                casing_strategy
            ),
            'easing': data.easing,
        }

    if casing_strategy == 'pascal':
        return {
            'Delay': data.delay,
            'EndDelay': data.end_delay,
            'IterationStart': data.iteration_start,
            'Iterations': data.iterations,
            'Duration': data.duration,
            'Direction': data.direction,
            'Fill': data.fill,
            'BackendNodeId': data.backend_node_id,
            'KeyframesRule': to_dict(
                data.keyframes_rule,
                casing_strategy
            ),
            'Easing': data.easing,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _animation__keyframes_rule__to_dict(
        data: 'animation.KeyframesRule',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'keyframes': [
                to_dict(item, casing_strategy)
                for item in data.keyframes
            ],
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'keyframes': [
                to_dict(item, casing_strategy)
                for item in data.keyframes
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Keyframes': [
                to_dict(item, casing_strategy)
                for item in data.keyframes
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _animation__keyframe_style__to_dict(
        data: 'animation.KeyframeStyle',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'offset': data.offset,
            'easing': data.easing,
        }

    if casing_strategy == 'camel':
        return {
            'offset': data.offset,
            'easing': data.easing,
        }

    if casing_strategy == 'pascal':
        return {
            'Offset': data.offset,
            'Easing': data.easing,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__affected_cookie__to_dict(
        data: 'audits.AffectedCookie',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'path': data.path,
            'domain': data.domain,
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'path': data.path,
            'domain': data.domain,
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Path': data.path,
            'Domain': data.domain,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__affected_request__to_dict(
        data: 'audits.AffectedRequest',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'request_id': data.request_id,
            'url': data.url,
        }

    if casing_strategy == 'camel':
        return {
            'requestId': data.request_id,
            'url': data.url,
        }

    if casing_strategy == 'pascal':
        return {
            'RequestId': data.request_id,
            'Url': data.url,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__affected_frame__to_dict(
        data: 'audits.AffectedFrame',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'frame_id': data.frame_id,
        }

    if casing_strategy == 'camel':
        return {
            'frameId': data.frame_id,
        }

    if casing_strategy == 'pascal':
        return {
            'FrameId': data.frame_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__cookie_issue_details__to_dict(
        data: 'audits.CookieIssueDetails',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'cookie': to_dict(
                data.cookie,
                casing_strategy
            ),
            'raw_cookie_line': data.raw_cookie_line,
            'cookie_warning_reasons': data.cookie_warning_reasons,
            'cookie_exclusion_reasons': data.cookie_exclusion_reasons,
            'operation': data.operation,
            'site_for_cookies': data.site_for_cookies,
            'cookie_url': data.cookie_url,
            'request': to_dict(
                data.request,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'cookie': to_dict(
                data.cookie,
                casing_strategy
            ),
            'rawCookieLine': data.raw_cookie_line,
            'cookieWarningReasons': data.cookie_warning_reasons,
            'cookieExclusionReasons': data.cookie_exclusion_reasons,
            'operation': data.operation,
            'siteForCookies': data.site_for_cookies,
            'cookieUrl': data.cookie_url,
            'request': to_dict(
                data.request,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'Cookie': to_dict(
                data.cookie,
                casing_strategy
            ),
            'RawCookieLine': data.raw_cookie_line,
            'CookieWarningReasons': data.cookie_warning_reasons,
            'CookieExclusionReasons': data.cookie_exclusion_reasons,
            'Operation': data.operation,
            'SiteForCookies': data.site_for_cookies,
            'CookieUrl': data.cookie_url,
            'Request': to_dict(
                data.request,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__mixed_content_issue_details__to_dict(
        data: 'audits.MixedContentIssueDetails',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'resource_type': data.resource_type,
            'resolution_status': data.resolution_status,
            'insecure_url': data.insecure_url,
            'main_resource_url': data.main_resource_url,
            'request': to_dict(
                data.request,
                casing_strategy
            ),
            'frame': to_dict(
                data.frame,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'resourceType': data.resource_type,
            'resolutionStatus': data.resolution_status,
            'insecureURL': data.insecure_url,
            'mainResourceURL': data.main_resource_url,
            'request': to_dict(
                data.request,
                casing_strategy
            ),
            'frame': to_dict(
                data.frame,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'ResourceType': data.resource_type,
            'ResolutionStatus': data.resolution_status,
            'InsecureURL': data.insecure_url,
            'MainResourceURL': data.main_resource_url,
            'Request': to_dict(
                data.request,
                casing_strategy
            ),
            'Frame': to_dict(
                data.frame,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__blocked_by_response_issue_details__to_dict(
        data: 'audits.BlockedByResponseIssueDetails',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'request': to_dict(
                data.request,
                casing_strategy
            ),
            'parent_frame': to_dict(
                data.parent_frame,
                casing_strategy
            ),
            'blocked_frame': to_dict(
                data.blocked_frame,
                casing_strategy
            ),
            'reason': data.reason,
        }

    if casing_strategy == 'camel':
        return {
            'request': to_dict(
                data.request,
                casing_strategy
            ),
            'parentFrame': to_dict(
                data.parent_frame,
                casing_strategy
            ),
            'blockedFrame': to_dict(
                data.blocked_frame,
                casing_strategy
            ),
            'reason': data.reason,
        }

    if casing_strategy == 'pascal':
        return {
            'Request': to_dict(
                data.request,
                casing_strategy
            ),
            'ParentFrame': to_dict(
                data.parent_frame,
                casing_strategy
            ),
            'BlockedFrame': to_dict(
                data.blocked_frame,
                casing_strategy
            ),
            'Reason': data.reason,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__heavy_ad_issue_details__to_dict(
        data: 'audits.HeavyAdIssueDetails',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'resolution': data.resolution,
            'reason': data.reason,
            'frame': to_dict(
                data.frame,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'resolution': data.resolution,
            'reason': data.reason,
            'frame': to_dict(
                data.frame,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'Resolution': data.resolution,
            'Reason': data.reason,
            'Frame': to_dict(
                data.frame,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__source_code_location__to_dict(
        data: 'audits.SourceCodeLocation',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'script_id': data.script_id,
            'url': data.url,
            'line_number': data.line_number,
            'column_number': data.column_number,
        }

    if casing_strategy == 'camel':
        return {
            'scriptId': data.script_id,
            'url': data.url,
            'lineNumber': data.line_number,
            'columnNumber': data.column_number,
        }

    if casing_strategy == 'pascal':
        return {
            'ScriptId': data.script_id,
            'Url': data.url,
            'LineNumber': data.line_number,
            'ColumnNumber': data.column_number,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__content_security_policy_issue_details__to_dict(
        data: 'audits.ContentSecurityPolicyIssueDetails',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'blocked_url': data.blocked_url,
            'violated_directive': data.violated_directive,
            'is_report_only': data.is_report_only,
            'content_security_policy_violation_type': data.content_security_policy_violation_type,
            'frame_ancestor': to_dict(
                data.frame_ancestor,
                casing_strategy
            ),
            'source_code_location': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'violating_node_id': data.violating_node_id,
        }

    if casing_strategy == 'camel':
        return {
            'blockedURL': data.blocked_url,
            'violatedDirective': data.violated_directive,
            'isReportOnly': data.is_report_only,
            'contentSecurityPolicyViolationType': data.content_security_policy_violation_type,
            'frameAncestor': to_dict(
                data.frame_ancestor,
                casing_strategy
            ),
            'sourceCodeLocation': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'violatingNodeId': data.violating_node_id,
        }

    if casing_strategy == 'pascal':
        return {
            'BlockedURL': data.blocked_url,
            'ViolatedDirective': data.violated_directive,
            'IsReportOnly': data.is_report_only,
            'ContentSecurityPolicyViolationType': data.content_security_policy_violation_type,
            'FrameAncestor': to_dict(
                data.frame_ancestor,
                casing_strategy
            ),
            'SourceCodeLocation': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'ViolatingNodeId': data.violating_node_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__shared_array_buffer_issue_details__to_dict(
        data: 'audits.SharedArrayBufferIssueDetails',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'source_code_location': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'is_warning': data.is_warning,
            'type': data.type,
        }

    if casing_strategy == 'camel':
        return {
            'sourceCodeLocation': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'isWarning': data.is_warning,
            'type': data.type,
        }

    if casing_strategy == 'pascal':
        return {
            'SourceCodeLocation': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'IsWarning': data.is_warning,
            'Type': data.type,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__low_text_contrast_issue_details__to_dict(
        data: 'audits.LowTextContrastIssueDetails',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'violating_node_id': data.violating_node_id,
            'violating_node_selector': data.violating_node_selector,
            'contrast_ratio': data.contrast_ratio,
            'threshold_aa': data.threshold_aa,
            'threshold_aaa': data.threshold_aaa,
            'font_size': data.font_size,
            'font_weight': data.font_weight,
        }

    if casing_strategy == 'camel':
        return {
            'violatingNodeId': data.violating_node_id,
            'violatingNodeSelector': data.violating_node_selector,
            'contrastRatio': data.contrast_ratio,
            'thresholdAA': data.threshold_aa,
            'thresholdAAA': data.threshold_aaa,
            'fontSize': data.font_size,
            'fontWeight': data.font_weight,
        }

    if casing_strategy == 'pascal':
        return {
            'ViolatingNodeId': data.violating_node_id,
            'ViolatingNodeSelector': data.violating_node_selector,
            'ContrastRatio': data.contrast_ratio,
            'ThresholdAA': data.threshold_aa,
            'ThresholdAAA': data.threshold_aaa,
            'FontSize': data.font_size,
            'FontWeight': data.font_weight,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__cors_issue_details__to_dict(
        data: 'audits.CorsIssueDetails',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'cors_error_status': to_dict(
                data.cors_error_status,
                casing_strategy
            ),
            'is_warning': data.is_warning,
            'request': to_dict(
                data.request,
                casing_strategy
            ),
            'location': to_dict(
                data.location,
                casing_strategy
            ),
            'initiator_origin': data.initiator_origin,
            'resource_ip_address_space': data.resource_ip_address_space,
            'client_security_state': to_dict(
                data.client_security_state,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'corsErrorStatus': to_dict(
                data.cors_error_status,
                casing_strategy
            ),
            'isWarning': data.is_warning,
            'request': to_dict(
                data.request,
                casing_strategy
            ),
            'location': to_dict(
                data.location,
                casing_strategy
            ),
            'initiatorOrigin': data.initiator_origin,
            'resourceIPAddressSpace': data.resource_ip_address_space,
            'clientSecurityState': to_dict(
                data.client_security_state,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'CorsErrorStatus': to_dict(
                data.cors_error_status,
                casing_strategy
            ),
            'IsWarning': data.is_warning,
            'Request': to_dict(
                data.request,
                casing_strategy
            ),
            'Location': to_dict(
                data.location,
                casing_strategy
            ),
            'InitiatorOrigin': data.initiator_origin,
            'ResourceIPAddressSpace': data.resource_ip_address_space,
            'ClientSecurityState': to_dict(
                data.client_security_state,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__attribution_reporting_issue_details__to_dict(
        data: 'audits.AttributionReportingIssueDetails',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'violation_type': data.violation_type,
            'request': to_dict(
                data.request,
                casing_strategy
            ),
            'violating_node_id': data.violating_node_id,
            'invalid_parameter': data.invalid_parameter,
        }

    if casing_strategy == 'camel':
        return {
            'violationType': data.violation_type,
            'request': to_dict(
                data.request,
                casing_strategy
            ),
            'violatingNodeId': data.violating_node_id,
            'invalidParameter': data.invalid_parameter,
        }

    if casing_strategy == 'pascal':
        return {
            'ViolationType': data.violation_type,
            'Request': to_dict(
                data.request,
                casing_strategy
            ),
            'ViolatingNodeId': data.violating_node_id,
            'InvalidParameter': data.invalid_parameter,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__quirks_mode_issue_details__to_dict(
        data: 'audits.QuirksModeIssueDetails',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'is_limited_quirks_mode': data.is_limited_quirks_mode,
            'document_node_id': data.document_node_id,
            'url': data.url,
            'frame_id': data.frame_id,
            'loader_id': data.loader_id,
        }

    if casing_strategy == 'camel':
        return {
            'isLimitedQuirksMode': data.is_limited_quirks_mode,
            'documentNodeId': data.document_node_id,
            'url': data.url,
            'frameId': data.frame_id,
            'loaderId': data.loader_id,
        }

    if casing_strategy == 'pascal':
        return {
            'IsLimitedQuirksMode': data.is_limited_quirks_mode,
            'DocumentNodeId': data.document_node_id,
            'Url': data.url,
            'FrameId': data.frame_id,
            'LoaderId': data.loader_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__navigator_user_agent_issue_details__to_dict(
        data: 'audits.NavigatorUserAgentIssueDetails',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'url': data.url,
            'location': to_dict(
                data.location,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'url': data.url,
            'location': to_dict(
                data.location,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'Url': data.url,
            'Location': to_dict(
                data.location,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__generic_issue_details__to_dict(
        data: 'audits.GenericIssueDetails',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'error_type': data.error_type,
            'frame_id': data.frame_id,
            'violating_node_id': data.violating_node_id,
            'violating_node_attribute': data.violating_node_attribute,
            'request': to_dict(
                data.request,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'errorType': data.error_type,
            'frameId': data.frame_id,
            'violatingNodeId': data.violating_node_id,
            'violatingNodeAttribute': data.violating_node_attribute,
            'request': to_dict(
                data.request,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'ErrorType': data.error_type,
            'FrameId': data.frame_id,
            'ViolatingNodeId': data.violating_node_id,
            'ViolatingNodeAttribute': data.violating_node_attribute,
            'Request': to_dict(
                data.request,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__deprecation_issue_details__to_dict(
        data: 'audits.DeprecationIssueDetails',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'affected_frame': to_dict(
                data.affected_frame,
                casing_strategy
            ),
            'source_code_location': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'type': data.type,
        }

    if casing_strategy == 'camel':
        return {
            'affectedFrame': to_dict(
                data.affected_frame,
                casing_strategy
            ),
            'sourceCodeLocation': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'type': data.type,
        }

    if casing_strategy == 'pascal':
        return {
            'AffectedFrame': to_dict(
                data.affected_frame,
                casing_strategy
            ),
            'SourceCodeLocation': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'Type': data.type,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__bounce_tracking_issue_details__to_dict(
        data: 'audits.BounceTrackingIssueDetails',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'tracking_sites': data.tracking_sites,
        }

    if casing_strategy == 'camel':
        return {
            'trackingSites': data.tracking_sites,
        }

    if casing_strategy == 'pascal':
        return {
            'TrackingSites': data.tracking_sites,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__federated_auth_request_issue_details__to_dict(
        data: 'audits.FederatedAuthRequestIssueDetails',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'federated_auth_request_issue_reason': data.federated_auth_request_issue_reason,
        }

    if casing_strategy == 'camel':
        return {
            'federatedAuthRequestIssueReason': data.federated_auth_request_issue_reason,
        }

    if casing_strategy == 'pascal':
        return {
            'FederatedAuthRequestIssueReason': data.federated_auth_request_issue_reason,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__federated_auth_user_info_request_issue_details__to_dict(
        data: 'audits.FederatedAuthUserInfoRequestIssueDetails',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'federated_auth_user_info_request_issue_reason': data.federated_auth_user_info_request_issue_reason,
        }

    if casing_strategy == 'camel':
        return {
            'federatedAuthUserInfoRequestIssueReason': data.federated_auth_user_info_request_issue_reason,
        }

    if casing_strategy == 'pascal':
        return {
            'FederatedAuthUserInfoRequestIssueReason': data.federated_auth_user_info_request_issue_reason,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__client_hint_issue_details__to_dict(
        data: 'audits.ClientHintIssueDetails',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'source_code_location': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'client_hint_issue_reason': data.client_hint_issue_reason,
        }

    if casing_strategy == 'camel':
        return {
            'sourceCodeLocation': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'clientHintIssueReason': data.client_hint_issue_reason,
        }

    if casing_strategy == 'pascal':
        return {
            'SourceCodeLocation': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'ClientHintIssueReason': data.client_hint_issue_reason,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__failed_request_info__to_dict(
        data: 'audits.FailedRequestInfo',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'url': data.url,
            'failure_message': data.failure_message,
            'request_id': data.request_id,
        }

    if casing_strategy == 'camel':
        return {
            'url': data.url,
            'failureMessage': data.failure_message,
            'requestId': data.request_id,
        }

    if casing_strategy == 'pascal':
        return {
            'Url': data.url,
            'FailureMessage': data.failure_message,
            'RequestId': data.request_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__stylesheet_loading_issue_details__to_dict(
        data: 'audits.StylesheetLoadingIssueDetails',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'source_code_location': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'style_sheet_loading_issue_reason': data.style_sheet_loading_issue_reason,
            'failed_request_info': to_dict(
                data.failed_request_info,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'sourceCodeLocation': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'styleSheetLoadingIssueReason': data.style_sheet_loading_issue_reason,
            'failedRequestInfo': to_dict(
                data.failed_request_info,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'SourceCodeLocation': to_dict(
                data.source_code_location,
                casing_strategy
            ),
            'StyleSheetLoadingIssueReason': data.style_sheet_loading_issue_reason,
            'FailedRequestInfo': to_dict(
                data.failed_request_info,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__inspector_issue_details__to_dict(
        data: 'audits.InspectorIssueDetails',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'cookie_issue_details': to_dict(
                data.cookie_issue_details,
                casing_strategy
            ),
            'mixed_content_issue_details': to_dict(
                data.mixed_content_issue_details,
                casing_strategy
            ),
            'blocked_by_response_issue_details': to_dict(
                data.blocked_by_response_issue_details,
                casing_strategy
            ),
            'heavy_ad_issue_details': to_dict(
                data.heavy_ad_issue_details,
                casing_strategy
            ),
            'content_security_policy_issue_details': to_dict(
                data.content_security_policy_issue_details,
                casing_strategy
            ),
            'shared_array_buffer_issue_details': to_dict(
                data.shared_array_buffer_issue_details,
                casing_strategy
            ),
            'low_text_contrast_issue_details': to_dict(
                data.low_text_contrast_issue_details,
                casing_strategy
            ),
            'cors_issue_details': to_dict(
                data.cors_issue_details,
                casing_strategy
            ),
            'attribution_reporting_issue_details': to_dict(
                data.attribution_reporting_issue_details,
                casing_strategy
            ),
            'quirks_mode_issue_details': to_dict(
                data.quirks_mode_issue_details,
                casing_strategy
            ),
            'navigator_user_agent_issue_details': to_dict(
                data.navigator_user_agent_issue_details,
                casing_strategy
            ),
            'generic_issue_details': to_dict(
                data.generic_issue_details,
                casing_strategy
            ),
            'deprecation_issue_details': to_dict(
                data.deprecation_issue_details,
                casing_strategy
            ),
            'client_hint_issue_details': to_dict(
                data.client_hint_issue_details,
                casing_strategy
            ),
            'federated_auth_request_issue_details': to_dict(
                data.federated_auth_request_issue_details,
                casing_strategy
            ),
            'bounce_tracking_issue_details': to_dict(
                data.bounce_tracking_issue_details,
                casing_strategy
            ),
            'stylesheet_loading_issue_details': to_dict(
                data.stylesheet_loading_issue_details,
                casing_strategy
            ),
            'federated_auth_user_info_request_issue_details': to_dict(
                data.federated_auth_user_info_request_issue_details,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'cookieIssueDetails': to_dict(
                data.cookie_issue_details,
                casing_strategy
            ),
            'mixedContentIssueDetails': to_dict(
                data.mixed_content_issue_details,
                casing_strategy
            ),
            'blockedByResponseIssueDetails': to_dict(
                data.blocked_by_response_issue_details,
                casing_strategy
            ),
            'heavyAdIssueDetails': to_dict(
                data.heavy_ad_issue_details,
                casing_strategy
            ),
            'contentSecurityPolicyIssueDetails': to_dict(
                data.content_security_policy_issue_details,
                casing_strategy
            ),
            'sharedArrayBufferIssueDetails': to_dict(
                data.shared_array_buffer_issue_details,
                casing_strategy
            ),
            'lowTextContrastIssueDetails': to_dict(
                data.low_text_contrast_issue_details,
                casing_strategy
            ),
            'corsIssueDetails': to_dict(
                data.cors_issue_details,
                casing_strategy
            ),
            'attributionReportingIssueDetails': to_dict(
                data.attribution_reporting_issue_details,
                casing_strategy
            ),
            'quirksModeIssueDetails': to_dict(
                data.quirks_mode_issue_details,
                casing_strategy
            ),
            'navigatorUserAgentIssueDetails': to_dict(
                data.navigator_user_agent_issue_details,
                casing_strategy
            ),
            'genericIssueDetails': to_dict(
                data.generic_issue_details,
                casing_strategy
            ),
            'deprecationIssueDetails': to_dict(
                data.deprecation_issue_details,
                casing_strategy
            ),
            'clientHintIssueDetails': to_dict(
                data.client_hint_issue_details,
                casing_strategy
            ),
            'federatedAuthRequestIssueDetails': to_dict(
                data.federated_auth_request_issue_details,
                casing_strategy
            ),
            'bounceTrackingIssueDetails': to_dict(
                data.bounce_tracking_issue_details,
                casing_strategy
            ),
            'stylesheetLoadingIssueDetails': to_dict(
                data.stylesheet_loading_issue_details,
                casing_strategy
            ),
            'federatedAuthUserInfoRequestIssueDetails': to_dict(
                data.federated_auth_user_info_request_issue_details,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'CookieIssueDetails': to_dict(
                data.cookie_issue_details,
                casing_strategy
            ),
            'MixedContentIssueDetails': to_dict(
                data.mixed_content_issue_details,
                casing_strategy
            ),
            'BlockedByResponseIssueDetails': to_dict(
                data.blocked_by_response_issue_details,
                casing_strategy
            ),
            'HeavyAdIssueDetails': to_dict(
                data.heavy_ad_issue_details,
                casing_strategy
            ),
            'ContentSecurityPolicyIssueDetails': to_dict(
                data.content_security_policy_issue_details,
                casing_strategy
            ),
            'SharedArrayBufferIssueDetails': to_dict(
                data.shared_array_buffer_issue_details,
                casing_strategy
            ),
            'LowTextContrastIssueDetails': to_dict(
                data.low_text_contrast_issue_details,
                casing_strategy
            ),
            'CorsIssueDetails': to_dict(
                data.cors_issue_details,
                casing_strategy
            ),
            'AttributionReportingIssueDetails': to_dict(
                data.attribution_reporting_issue_details,
                casing_strategy
            ),
            'QuirksModeIssueDetails': to_dict(
                data.quirks_mode_issue_details,
                casing_strategy
            ),
            'NavigatorUserAgentIssueDetails': to_dict(
                data.navigator_user_agent_issue_details,
                casing_strategy
            ),
            'GenericIssueDetails': to_dict(
                data.generic_issue_details,
                casing_strategy
            ),
            'DeprecationIssueDetails': to_dict(
                data.deprecation_issue_details,
                casing_strategy
            ),
            'ClientHintIssueDetails': to_dict(
                data.client_hint_issue_details,
                casing_strategy
            ),
            'FederatedAuthRequestIssueDetails': to_dict(
                data.federated_auth_request_issue_details,
                casing_strategy
            ),
            'BounceTrackingIssueDetails': to_dict(
                data.bounce_tracking_issue_details,
                casing_strategy
            ),
            'StylesheetLoadingIssueDetails': to_dict(
                data.stylesheet_loading_issue_details,
                casing_strategy
            ),
            'FederatedAuthUserInfoRequestIssueDetails': to_dict(
                data.federated_auth_user_info_request_issue_details,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__inspector_issue__to_dict(
        data: 'audits.InspectorIssue',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'code': data.code,
            'details': to_dict(
                data.details,
                casing_strategy
            ),
            'issue_id': data.issue_id,
        }

    if casing_strategy == 'camel':
        return {
            'code': data.code,
            'details': to_dict(
                data.details,
                casing_strategy
            ),
            'issueId': data.issue_id,
        }

    if casing_strategy == 'pascal':
        return {
            'Code': data.code,
            'Details': to_dict(
                data.details,
                casing_strategy
            ),
            'IssueId': data.issue_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _autofill__credit_card__to_dict(
        data: 'autofill.CreditCard',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'number': data.number,
            'name': data.name,
            'expiry_month': data.expiry_month,
            'expiry_year': data.expiry_year,
            'cvc': data.cvc,
        }

    if casing_strategy == 'camel':
        return {
            'number': data.number,
            'name': data.name,
            'expiryMonth': data.expiry_month,
            'expiryYear': data.expiry_year,
            'cvc': data.cvc,
        }

    if casing_strategy == 'pascal':
        return {
            'Number': data.number,
            'Name': data.name,
            'ExpiryMonth': data.expiry_month,
            'ExpiryYear': data.expiry_year,
            'Cvc': data.cvc,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _autofill__address_field__to_dict(
        data: 'autofill.AddressField',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _autofill__address_fields__to_dict(
        data: 'autofill.AddressFields',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'fields': [
                to_dict(item, casing_strategy)
                for item in data.fields
            ],
        }

    if casing_strategy == 'camel':
        return {
            'fields': [
                to_dict(item, casing_strategy)
                for item in data.fields
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Fields': [
                to_dict(item, casing_strategy)
                for item in data.fields
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _autofill__address__to_dict(
        data: 'autofill.Address',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'fields': [
                to_dict(item, casing_strategy)
                for item in data.fields
            ],
        }

    if casing_strategy == 'camel':
        return {
            'fields': [
                to_dict(item, casing_strategy)
                for item in data.fields
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Fields': [
                to_dict(item, casing_strategy)
                for item in data.fields
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _autofill__address_ui__to_dict(
        data: 'autofill.AddressUI',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'address_fields': [
                to_dict(item, casing_strategy)
                for item in data.address_fields
            ],
        }

    if casing_strategy == 'camel':
        return {
            'addressFields': [
                to_dict(item, casing_strategy)
                for item in data.address_fields
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'AddressFields': [
                to_dict(item, casing_strategy)
                for item in data.address_fields
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _autofill__filled_field__to_dict(
        data: 'autofill.FilledField',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'html_type': data.html_type,
            'id': data.id,
            'name': data.name,
            'value': data.value,
            'autofill_type': data.autofill_type,
            'filling_strategy': data.filling_strategy,
        }

    if casing_strategy == 'camel':
        return {
            'htmlType': data.html_type,
            'id': data.id,
            'name': data.name,
            'value': data.value,
            'autofillType': data.autofill_type,
            'fillingStrategy': data.filling_strategy,
        }

    if casing_strategy == 'pascal':
        return {
            'HtmlType': data.html_type,
            'Id': data.id,
            'Name': data.name,
            'Value': data.value,
            'AutofillType': data.autofill_type,
            'FillingStrategy': data.filling_strategy,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _background_service__event_metadata__to_dict(
        data: 'background_service.EventMetadata',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'key': data.key,
            'value': data.value,
        }

    if casing_strategy == 'camel':
        return {
            'key': data.key,
            'value': data.value,
        }

    if casing_strategy == 'pascal':
        return {
            'Key': data.key,
            'Value': data.value,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _background_service__background_service_event__to_dict(
        data: 'background_service.BackgroundServiceEvent',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'timestamp': data.timestamp,
            'origin': data.origin,
            'service_worker_registration_id': data.service_worker_registration_id,
            'service': data.service,
            'event_name': data.event_name,
            'instance_id': data.instance_id,
            'event_metadata': [
                to_dict(item, casing_strategy)
                for item in data.event_metadata
            ],
            'storage_key': data.storage_key,
        }

    if casing_strategy == 'camel':
        return {
            'timestamp': data.timestamp,
            'origin': data.origin,
            'serviceWorkerRegistrationId': data.service_worker_registration_id,
            'service': data.service,
            'eventName': data.event_name,
            'instanceId': data.instance_id,
            'eventMetadata': [
                to_dict(item, casing_strategy)
                for item in data.event_metadata
            ],
            'storageKey': data.storage_key,
        }

    if casing_strategy == 'pascal':
        return {
            'Timestamp': data.timestamp,
            'Origin': data.origin,
            'ServiceWorkerRegistrationId': data.service_worker_registration_id,
            'Service': data.service,
            'EventName': data.event_name,
            'InstanceId': data.instance_id,
            'EventMetadata': [
                to_dict(item, casing_strategy)
                for item in data.event_metadata
            ],
            'StorageKey': data.storage_key,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _browser__bounds__to_dict(
        data: 'browser.Bounds',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'left': data.left,
            'top': data.top,
            'width': data.width,
            'height': data.height,
            'window_state': data.window_state,
        }

    if casing_strategy == 'camel':
        return {
            'left': data.left,
            'top': data.top,
            'width': data.width,
            'height': data.height,
            'windowState': data.window_state,
        }

    if casing_strategy == 'pascal':
        return {
            'Left': data.left,
            'Top': data.top,
            'Width': data.width,
            'Height': data.height,
            'WindowState': data.window_state,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _browser__permission_descriptor__to_dict(
        data: 'browser.PermissionDescriptor',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'sysex': data.sysex,
            'user_visible_only': data.user_visible_only,
            'allow_without_sanitization': data.allow_without_sanitization,
            'pan_tilt_zoom': data.pan_tilt_zoom,
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'sysex': data.sysex,
            'userVisibleOnly': data.user_visible_only,
            'allowWithoutSanitization': data.allow_without_sanitization,
            'panTiltZoom': data.pan_tilt_zoom,
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Sysex': data.sysex,
            'UserVisibleOnly': data.user_visible_only,
            'AllowWithoutSanitization': data.allow_without_sanitization,
            'PanTiltZoom': data.pan_tilt_zoom,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _browser__bucket__to_dict(
        data: 'browser.Bucket',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'low': data.low,
            'high': data.high,
            'count': data.count,
        }

    if casing_strategy == 'camel':
        return {
            'low': data.low,
            'high': data.high,
            'count': data.count,
        }

    if casing_strategy == 'pascal':
        return {
            'Low': data.low,
            'High': data.high,
            'Count': data.count,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _browser__histogram__to_dict(
        data: 'browser.Histogram',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'sum': data.sum,
            'count': data.count,
            'buckets': [
                to_dict(item, casing_strategy)
                for item in data.buckets
            ],
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'sum': data.sum,
            'count': data.count,
            'buckets': [
                to_dict(item, casing_strategy)
                for item in data.buckets
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Sum': data.sum,
            'Count': data.count,
            'Buckets': [
                to_dict(item, casing_strategy)
                for item in data.buckets
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__pseudo_element_matches__to_dict(
        data: 'css.PseudoElementMatches',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'pseudo_type': data.pseudo_type,
            'pseudo_identifier': data.pseudo_identifier,
            'matches': [
                to_dict(item, casing_strategy)
                for item in data.matches
            ],
        }

    if casing_strategy == 'camel':
        return {
            'pseudoType': data.pseudo_type,
            'pseudoIdentifier': data.pseudo_identifier,
            'matches': [
                to_dict(item, casing_strategy)
                for item in data.matches
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'PseudoType': data.pseudo_type,
            'PseudoIdentifier': data.pseudo_identifier,
            'Matches': [
                to_dict(item, casing_strategy)
                for item in data.matches
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__inherited_style_entry__to_dict(
        data: 'css.InheritedStyleEntry',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'inline_style': to_dict(
                data.inline_style,
                casing_strategy
            ),
            'matched_css_rules': [
                to_dict(item, casing_strategy)
                for item in data.matched_css_rules
            ],
        }

    if casing_strategy == 'camel':
        return {
            'inlineStyle': to_dict(
                data.inline_style,
                casing_strategy
            ),
            'matchedCSSRules': [
                to_dict(item, casing_strategy)
                for item in data.matched_css_rules
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'InlineStyle': to_dict(
                data.inline_style,
                casing_strategy
            ),
            'MatchedCSSRules': [
                to_dict(item, casing_strategy)
                for item in data.matched_css_rules
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__inherited_pseudo_element_matches__to_dict(
        data: 'css.InheritedPseudoElementMatches',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'pseudo_elements': [
                to_dict(item, casing_strategy)
                for item in data.pseudo_elements
            ],
        }

    if casing_strategy == 'camel':
        return {
            'pseudoElements': [
                to_dict(item, casing_strategy)
                for item in data.pseudo_elements
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'PseudoElements': [
                to_dict(item, casing_strategy)
                for item in data.pseudo_elements
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__rule_match__to_dict(
        data: 'css.RuleMatch',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'rule': to_dict(
                data.rule,
                casing_strategy
            ),
            'matching_selectors': data.matching_selectors,
        }

    if casing_strategy == 'camel':
        return {
            'rule': to_dict(
                data.rule,
                casing_strategy
            ),
            'matchingSelectors': data.matching_selectors,
        }

    if casing_strategy == 'pascal':
        return {
            'Rule': to_dict(
                data.rule,
                casing_strategy
            ),
            'MatchingSelectors': data.matching_selectors,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__value__to_dict(
        data: 'css.Value',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'text': data.text,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'specificity': to_dict(
                data.specificity,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'text': data.text,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'specificity': to_dict(
                data.specificity,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'Text': data.text,
            'Range': to_dict(
                data.range,
                casing_strategy
            ),
            'Specificity': to_dict(
                data.specificity,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__specificity__to_dict(
        data: 'css.Specificity',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'a': data.a,
            'b': data.b,
            'c': data.c,
        }

    if casing_strategy == 'camel':
        return {
            'a': data.a,
            'b': data.b,
            'c': data.c,
        }

    if casing_strategy == 'pascal':
        return {
            'A': data.a,
            'B': data.b,
            'C': data.c,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__selector_list__to_dict(
        data: 'css.SelectorList',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'selectors': [
                to_dict(item, casing_strategy)
                for item in data.selectors
            ],
            'text': data.text,
        }

    if casing_strategy == 'camel':
        return {
            'selectors': [
                to_dict(item, casing_strategy)
                for item in data.selectors
            ],
            'text': data.text,
        }

    if casing_strategy == 'pascal':
        return {
            'Selectors': [
                to_dict(item, casing_strategy)
                for item in data.selectors
            ],
            'Text': data.text,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_style_sheet_header__to_dict(
        data: 'css.CSSStyleSheetHeader',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'style_sheet_id': data.style_sheet_id,
            'frame_id': data.frame_id,
            'source_url': data.source_url,
            'source_map_url': data.source_map_url,
            'origin': data.origin,
            'title': data.title,
            'owner_node': data.owner_node,
            'disabled': data.disabled,
            'has_source_url': data.has_source_url,
            'is_inline': data.is_inline,
            'is_mutable': data.is_mutable,
            'is_constructed': data.is_constructed,
            'start_line': data.start_line,
            'start_column': data.start_column,
            'length': data.length,
            'end_line': data.end_line,
            'end_column': data.end_column,
            'loading_failed': data.loading_failed,
        }

    if casing_strategy == 'camel':
        return {
            'styleSheetId': data.style_sheet_id,
            'frameId': data.frame_id,
            'sourceURL': data.source_url,
            'sourceMapURL': data.source_map_url,
            'origin': data.origin,
            'title': data.title,
            'ownerNode': data.owner_node,
            'disabled': data.disabled,
            'hasSourceURL': data.has_source_url,
            'isInline': data.is_inline,
            'isMutable': data.is_mutable,
            'isConstructed': data.is_constructed,
            'startLine': data.start_line,
            'startColumn': data.start_column,
            'length': data.length,
            'endLine': data.end_line,
            'endColumn': data.end_column,
            'loadingFailed': data.loading_failed,
        }

    if casing_strategy == 'pascal':
        return {
            'StyleSheetId': data.style_sheet_id,
            'FrameId': data.frame_id,
            'SourceURL': data.source_url,
            'SourceMapURL': data.source_map_url,
            'Origin': data.origin,
            'Title': data.title,
            'OwnerNode': data.owner_node,
            'Disabled': data.disabled,
            'HasSourceURL': data.has_source_url,
            'IsInline': data.is_inline,
            'IsMutable': data.is_mutable,
            'IsConstructed': data.is_constructed,
            'StartLine': data.start_line,
            'StartColumn': data.start_column,
            'Length': data.length,
            'EndLine': data.end_line,
            'EndColumn': data.end_column,
            'LoadingFailed': data.loading_failed,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_rule__to_dict(
        data: 'css.CSSRule',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'style_sheet_id': data.style_sheet_id,
            'selector_list': to_dict(
                data.selector_list,
                casing_strategy
            ),
            'nesting_selectors': data.nesting_selectors,
            'origin': data.origin,
            'style': to_dict(
                data.style,
                casing_strategy
            ),
            'media': [
                to_dict(item, casing_strategy)
                for item in data.media
            ],
            'container_queries': [
                to_dict(item, casing_strategy)
                for item in data.container_queries
            ],
            'supports': [
                to_dict(item, casing_strategy)
                for item in data.supports
            ],
            'layers': [
                to_dict(item, casing_strategy)
                for item in data.layers
            ],
            'scopes': [
                to_dict(item, casing_strategy)
                for item in data.scopes
            ],
            'rule_types': data.rule_types,
        }

    if casing_strategy == 'camel':
        return {
            'styleSheetId': data.style_sheet_id,
            'selectorList': to_dict(
                data.selector_list,
                casing_strategy
            ),
            'nestingSelectors': data.nesting_selectors,
            'origin': data.origin,
            'style': to_dict(
                data.style,
                casing_strategy
            ),
            'media': [
                to_dict(item, casing_strategy)
                for item in data.media
            ],
            'containerQueries': [
                to_dict(item, casing_strategy)
                for item in data.container_queries
            ],
            'supports': [
                to_dict(item, casing_strategy)
                for item in data.supports
            ],
            'layers': [
                to_dict(item, casing_strategy)
                for item in data.layers
            ],
            'scopes': [
                to_dict(item, casing_strategy)
                for item in data.scopes
            ],
            'ruleTypes': data.rule_types,
        }

    if casing_strategy == 'pascal':
        return {
            'StyleSheetId': data.style_sheet_id,
            'SelectorList': to_dict(
                data.selector_list,
                casing_strategy
            ),
            'NestingSelectors': data.nesting_selectors,
            'Origin': data.origin,
            'Style': to_dict(
                data.style,
                casing_strategy
            ),
            'Media': [
                to_dict(item, casing_strategy)
                for item in data.media
            ],
            'ContainerQueries': [
                to_dict(item, casing_strategy)
                for item in data.container_queries
            ],
            'Supports': [
                to_dict(item, casing_strategy)
                for item in data.supports
            ],
            'Layers': [
                to_dict(item, casing_strategy)
                for item in data.layers
            ],
            'Scopes': [
                to_dict(item, casing_strategy)
                for item in data.scopes
            ],
            'RuleTypes': data.rule_types,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__rule_usage__to_dict(
        data: 'css.RuleUsage',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'style_sheet_id': data.style_sheet_id,
            'start_offset': data.start_offset,
            'end_offset': data.end_offset,
            'used': data.used,
        }

    if casing_strategy == 'camel':
        return {
            'styleSheetId': data.style_sheet_id,
            'startOffset': data.start_offset,
            'endOffset': data.end_offset,
            'used': data.used,
        }

    if casing_strategy == 'pascal':
        return {
            'StyleSheetId': data.style_sheet_id,
            'StartOffset': data.start_offset,
            'EndOffset': data.end_offset,
            'Used': data.used,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__source_range__to_dict(
        data: 'css.SourceRange',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'start_line': data.start_line,
            'start_column': data.start_column,
            'end_line': data.end_line,
            'end_column': data.end_column,
        }

    if casing_strategy == 'camel':
        return {
            'startLine': data.start_line,
            'startColumn': data.start_column,
            'endLine': data.end_line,
            'endColumn': data.end_column,
        }

    if casing_strategy == 'pascal':
        return {
            'StartLine': data.start_line,
            'StartColumn': data.start_column,
            'EndLine': data.end_line,
            'EndColumn': data.end_column,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__shorthand_entry__to_dict(
        data: 'css.ShorthandEntry',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
            'important': data.important,
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
            'important': data.important,
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
            'Important': data.important,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_computed_style_property__to_dict(
        data: 'css.CSSComputedStyleProperty',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_style__to_dict(
        data: 'css.CSSStyle',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'style_sheet_id': data.style_sheet_id,
            'css_properties': [
                to_dict(item, casing_strategy)
                for item in data.css_properties
            ],
            'shorthand_entries': [
                to_dict(item, casing_strategy)
                for item in data.shorthand_entries
            ],
            'css_text': data.css_text,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'styleSheetId': data.style_sheet_id,
            'cssProperties': [
                to_dict(item, casing_strategy)
                for item in data.css_properties
            ],
            'shorthandEntries': [
                to_dict(item, casing_strategy)
                for item in data.shorthand_entries
            ],
            'cssText': data.css_text,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'StyleSheetId': data.style_sheet_id,
            'CssProperties': [
                to_dict(item, casing_strategy)
                for item in data.css_properties
            ],
            'ShorthandEntries': [
                to_dict(item, casing_strategy)
                for item in data.shorthand_entries
            ],
            'CssText': data.css_text,
            'Range': to_dict(
                data.range,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_property__to_dict(
        data: 'css.CSSProperty',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
            'important': data.important,
            'implicit': data.implicit,
            'text': data.text,
            'parsed_ok': data.parsed_ok,
            'disabled': data.disabled,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'longhand_properties': [
                to_dict(item, casing_strategy)
                for item in data.longhand_properties
            ],
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
            'important': data.important,
            'implicit': data.implicit,
            'text': data.text,
            'parsedOk': data.parsed_ok,
            'disabled': data.disabled,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'longhandProperties': [
                to_dict(item, casing_strategy)
                for item in data.longhand_properties
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
            'Important': data.important,
            'Implicit': data.implicit,
            'Text': data.text,
            'ParsedOk': data.parsed_ok,
            'Disabled': data.disabled,
            'Range': to_dict(
                data.range,
                casing_strategy
            ),
            'LonghandProperties': [
                to_dict(item, casing_strategy)
                for item in data.longhand_properties
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_media__to_dict(
        data: 'css.CSSMedia',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'text': data.text,
            'source': data.source,
            'source_url': data.source_url,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'style_sheet_id': data.style_sheet_id,
            'media_list': [
                to_dict(item, casing_strategy)
                for item in data.media_list
            ],
        }

    if casing_strategy == 'camel':
        return {
            'text': data.text,
            'source': data.source,
            'sourceURL': data.source_url,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'styleSheetId': data.style_sheet_id,
            'mediaList': [
                to_dict(item, casing_strategy)
                for item in data.media_list
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Text': data.text,
            'Source': data.source,
            'SourceURL': data.source_url,
            'Range': to_dict(
                data.range,
                casing_strategy
            ),
            'StyleSheetId': data.style_sheet_id,
            'MediaList': [
                to_dict(item, casing_strategy)
                for item in data.media_list
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__media_query__to_dict(
        data: 'css.MediaQuery',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'expressions': [
                to_dict(item, casing_strategy)
                for item in data.expressions
            ],
            'active': data.active,
        }

    if casing_strategy == 'camel':
        return {
            'expressions': [
                to_dict(item, casing_strategy)
                for item in data.expressions
            ],
            'active': data.active,
        }

    if casing_strategy == 'pascal':
        return {
            'Expressions': [
                to_dict(item, casing_strategy)
                for item in data.expressions
            ],
            'Active': data.active,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__media_query_expression__to_dict(
        data: 'css.MediaQueryExpression',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'value': data.value,
            'unit': data.unit,
            'feature': data.feature,
            'value_range': to_dict(
                data.value_range,
                casing_strategy
            ),
            'computed_length': data.computed_length,
        }

    if casing_strategy == 'camel':
        return {
            'value': data.value,
            'unit': data.unit,
            'feature': data.feature,
            'valueRange': to_dict(
                data.value_range,
                casing_strategy
            ),
            'computedLength': data.computed_length,
        }

    if casing_strategy == 'pascal':
        return {
            'Value': data.value,
            'Unit': data.unit,
            'Feature': data.feature,
            'ValueRange': to_dict(
                data.value_range,
                casing_strategy
            ),
            'ComputedLength': data.computed_length,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_container_query__to_dict(
        data: 'css.CSSContainerQuery',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'text': data.text,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'style_sheet_id': data.style_sheet_id,
            'name': data.name,
            'physical_axes': data.physical_axes,
            'logical_axes': data.logical_axes,
        }

    if casing_strategy == 'camel':
        return {
            'text': data.text,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'styleSheetId': data.style_sheet_id,
            'name': data.name,
            'physicalAxes': data.physical_axes,
            'logicalAxes': data.logical_axes,
        }

    if casing_strategy == 'pascal':
        return {
            'Text': data.text,
            'Range': to_dict(
                data.range,
                casing_strategy
            ),
            'StyleSheetId': data.style_sheet_id,
            'Name': data.name,
            'PhysicalAxes': data.physical_axes,
            'LogicalAxes': data.logical_axes,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_supports__to_dict(
        data: 'css.CSSSupports',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'text': data.text,
            'active': data.active,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'style_sheet_id': data.style_sheet_id,
        }

    if casing_strategy == 'camel':
        return {
            'text': data.text,
            'active': data.active,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'styleSheetId': data.style_sheet_id,
        }

    if casing_strategy == 'pascal':
        return {
            'Text': data.text,
            'Active': data.active,
            'Range': to_dict(
                data.range,
                casing_strategy
            ),
            'StyleSheetId': data.style_sheet_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_scope__to_dict(
        data: 'css.CSSScope',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'text': data.text,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'style_sheet_id': data.style_sheet_id,
        }

    if casing_strategy == 'camel':
        return {
            'text': data.text,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'styleSheetId': data.style_sheet_id,
        }

    if casing_strategy == 'pascal':
        return {
            'Text': data.text,
            'Range': to_dict(
                data.range,
                casing_strategy
            ),
            'StyleSheetId': data.style_sheet_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_layer__to_dict(
        data: 'css.CSSLayer',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'text': data.text,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'style_sheet_id': data.style_sheet_id,
        }

    if casing_strategy == 'camel':
        return {
            'text': data.text,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'styleSheetId': data.style_sheet_id,
        }

    if casing_strategy == 'pascal':
        return {
            'Text': data.text,
            'Range': to_dict(
                data.range,
                casing_strategy
            ),
            'StyleSheetId': data.style_sheet_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_layer_data__to_dict(
        data: 'css.CSSLayerData',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'sub_layers': [
                to_dict(item, casing_strategy)
                for item in data.sub_layers
            ],
            'order': data.order,
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'subLayers': [
                to_dict(item, casing_strategy)
                for item in data.sub_layers
            ],
            'order': data.order,
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'SubLayers': [
                to_dict(item, casing_strategy)
                for item in data.sub_layers
            ],
            'Order': data.order,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__platform_font_usage__to_dict(
        data: 'css.PlatformFontUsage',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'family_name': data.family_name,
            'is_custom_font': data.is_custom_font,
            'glyph_count': data.glyph_count,
        }

    if casing_strategy == 'camel':
        return {
            'familyName': data.family_name,
            'isCustomFont': data.is_custom_font,
            'glyphCount': data.glyph_count,
        }

    if casing_strategy == 'pascal':
        return {
            'FamilyName': data.family_name,
            'IsCustomFont': data.is_custom_font,
            'GlyphCount': data.glyph_count,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__font_variation_axis__to_dict(
        data: 'css.FontVariationAxis',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'tag': data.tag,
            'name': data.name,
            'min_value': data.min_value,
            'max_value': data.max_value,
            'default_value': data.default_value,
        }

    if casing_strategy == 'camel':
        return {
            'tag': data.tag,
            'name': data.name,
            'minValue': data.min_value,
            'maxValue': data.max_value,
            'defaultValue': data.default_value,
        }

    if casing_strategy == 'pascal':
        return {
            'Tag': data.tag,
            'Name': data.name,
            'MinValue': data.min_value,
            'MaxValue': data.max_value,
            'DefaultValue': data.default_value,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__font_face__to_dict(
        data: 'css.FontFace',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'font_family': data.font_family,
            'font_style': data.font_style,
            'font_variant': data.font_variant,
            'font_weight': data.font_weight,
            'font_stretch': data.font_stretch,
            'font_display': data.font_display,
            'unicode_range': data.unicode_range,
            'src': data.src,
            'platform_font_family': data.platform_font_family,
            'font_variation_axes': [
                to_dict(item, casing_strategy)
                for item in data.font_variation_axes
            ],
        }

    if casing_strategy == 'camel':
        return {
            'fontFamily': data.font_family,
            'fontStyle': data.font_style,
            'fontVariant': data.font_variant,
            'fontWeight': data.font_weight,
            'fontStretch': data.font_stretch,
            'fontDisplay': data.font_display,
            'unicodeRange': data.unicode_range,
            'src': data.src,
            'platformFontFamily': data.platform_font_family,
            'fontVariationAxes': [
                to_dict(item, casing_strategy)
                for item in data.font_variation_axes
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'FontFamily': data.font_family,
            'FontStyle': data.font_style,
            'FontVariant': data.font_variant,
            'FontWeight': data.font_weight,
            'FontStretch': data.font_stretch,
            'FontDisplay': data.font_display,
            'UnicodeRange': data.unicode_range,
            'Src': data.src,
            'PlatformFontFamily': data.platform_font_family,
            'FontVariationAxes': [
                to_dict(item, casing_strategy)
                for item in data.font_variation_axes
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_try_rule__to_dict(
        data: 'css.CSSTryRule',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'style_sheet_id': data.style_sheet_id,
            'origin': data.origin,
            'style': to_dict(
                data.style,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'styleSheetId': data.style_sheet_id,
            'origin': data.origin,
            'style': to_dict(
                data.style,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'StyleSheetId': data.style_sheet_id,
            'Origin': data.origin,
            'Style': to_dict(
                data.style,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_position_fallback_rule__to_dict(
        data: 'css.CSSPositionFallbackRule',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': to_dict(
                data.name,
                casing_strategy
            ),
            'try_rules': [
                to_dict(item, casing_strategy)
                for item in data.try_rules
            ],
        }

    if casing_strategy == 'camel':
        return {
            'name': to_dict(
                data.name,
                casing_strategy
            ),
            'tryRules': [
                to_dict(item, casing_strategy)
                for item in data.try_rules
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Name': to_dict(
                data.name,
                casing_strategy
            ),
            'TryRules': [
                to_dict(item, casing_strategy)
                for item in data.try_rules
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_keyframes_rule__to_dict(
        data: 'css.CSSKeyframesRule',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'animation_name': to_dict(
                data.animation_name,
                casing_strategy
            ),
            'keyframes': [
                to_dict(item, casing_strategy)
                for item in data.keyframes
            ],
        }

    if casing_strategy == 'camel':
        return {
            'animationName': to_dict(
                data.animation_name,
                casing_strategy
            ),
            'keyframes': [
                to_dict(item, casing_strategy)
                for item in data.keyframes
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'AnimationName': to_dict(
                data.animation_name,
                casing_strategy
            ),
            'Keyframes': [
                to_dict(item, casing_strategy)
                for item in data.keyframes
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_property_registration__to_dict(
        data: 'css.CSSPropertyRegistration',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'property_name': data.property_name,
            'initial_value': to_dict(
                data.initial_value,
                casing_strategy
            ),
            'inherits': data.inherits,
            'syntax': data.syntax,
        }

    if casing_strategy == 'camel':
        return {
            'propertyName': data.property_name,
            'initialValue': to_dict(
                data.initial_value,
                casing_strategy
            ),
            'inherits': data.inherits,
            'syntax': data.syntax,
        }

    if casing_strategy == 'pascal':
        return {
            'PropertyName': data.property_name,
            'InitialValue': to_dict(
                data.initial_value,
                casing_strategy
            ),
            'Inherits': data.inherits,
            'Syntax': data.syntax,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_property_rule__to_dict(
        data: 'css.CSSPropertyRule',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'style_sheet_id': data.style_sheet_id,
            'origin': data.origin,
            'property_name': to_dict(
                data.property_name,
                casing_strategy
            ),
            'style': to_dict(
                data.style,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'styleSheetId': data.style_sheet_id,
            'origin': data.origin,
            'propertyName': to_dict(
                data.property_name,
                casing_strategy
            ),
            'style': to_dict(
                data.style,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'StyleSheetId': data.style_sheet_id,
            'Origin': data.origin,
            'PropertyName': to_dict(
                data.property_name,
                casing_strategy
            ),
            'Style': to_dict(
                data.style,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_keyframe_rule__to_dict(
        data: 'css.CSSKeyframeRule',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'style_sheet_id': data.style_sheet_id,
            'origin': data.origin,
            'key_text': to_dict(
                data.key_text,
                casing_strategy
            ),
            'style': to_dict(
                data.style,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'styleSheetId': data.style_sheet_id,
            'origin': data.origin,
            'keyText': to_dict(
                data.key_text,
                casing_strategy
            ),
            'style': to_dict(
                data.style,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'StyleSheetId': data.style_sheet_id,
            'Origin': data.origin,
            'KeyText': to_dict(
                data.key_text,
                casing_strategy
            ),
            'Style': to_dict(
                data.style,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__style_declaration_edit__to_dict(
        data: 'css.StyleDeclarationEdit',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'style_sheet_id': data.style_sheet_id,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'text': data.text,
        }

    if casing_strategy == 'camel':
        return {
            'styleSheetId': data.style_sheet_id,
            'range': to_dict(
                data.range,
                casing_strategy
            ),
            'text': data.text,
        }

    if casing_strategy == 'pascal':
        return {
            'StyleSheetId': data.style_sheet_id,
            'Range': to_dict(
                data.range,
                casing_strategy
            ),
            'Text': data.text,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _cache_storage__data_entry__to_dict(
        data: 'cache_storage.DataEntry',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'request_url': data.request_url,
            'request_method': data.request_method,
            'request_headers': [
                to_dict(item, casing_strategy)
                for item in data.request_headers
            ],
            'response_time': data.response_time,
            'response_status': data.response_status,
            'response_status_text': data.response_status_text,
            'response_type': data.response_type,
            'response_headers': [
                to_dict(item, casing_strategy)
                for item in data.response_headers
            ],
        }

    if casing_strategy == 'camel':
        return {
            'requestURL': data.request_url,
            'requestMethod': data.request_method,
            'requestHeaders': [
                to_dict(item, casing_strategy)
                for item in data.request_headers
            ],
            'responseTime': data.response_time,
            'responseStatus': data.response_status,
            'responseStatusText': data.response_status_text,
            'responseType': data.response_type,
            'responseHeaders': [
                to_dict(item, casing_strategy)
                for item in data.response_headers
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'RequestURL': data.request_url,
            'RequestMethod': data.request_method,
            'RequestHeaders': [
                to_dict(item, casing_strategy)
                for item in data.request_headers
            ],
            'ResponseTime': data.response_time,
            'ResponseStatus': data.response_status,
            'ResponseStatusText': data.response_status_text,
            'ResponseType': data.response_type,
            'ResponseHeaders': [
                to_dict(item, casing_strategy)
                for item in data.response_headers
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _cache_storage__cache__to_dict(
        data: 'cache_storage.Cache',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'cache_id': data.cache_id,
            'security_origin': data.security_origin,
            'storage_key': data.storage_key,
            'storage_bucket': to_dict(
                data.storage_bucket,
                casing_strategy
            ),
            'cache_name': data.cache_name,
        }

    if casing_strategy == 'camel':
        return {
            'cacheId': data.cache_id,
            'securityOrigin': data.security_origin,
            'storageKey': data.storage_key,
            'storageBucket': to_dict(
                data.storage_bucket,
                casing_strategy
            ),
            'cacheName': data.cache_name,
        }

    if casing_strategy == 'pascal':
        return {
            'CacheId': data.cache_id,
            'SecurityOrigin': data.security_origin,
            'StorageKey': data.storage_key,
            'StorageBucket': to_dict(
                data.storage_bucket,
                casing_strategy
            ),
            'CacheName': data.cache_name,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _cache_storage__header__to_dict(
        data: 'cache_storage.Header',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _cache_storage__cached_response__to_dict(
        data: 'cache_storage.CachedResponse',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'body': data.body,
        }

    if casing_strategy == 'camel':
        return {
            'body': data.body,
        }

    if casing_strategy == 'pascal':
        return {
            'Body': data.body,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _cast__sink__to_dict(
        data: 'cast.Sink',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'id': data.id,
            'session': data.session,
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'id': data.id,
            'session': data.session,
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Id': data.id,
            'Session': data.session,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__backend_node__to_dict(
        data: 'dom.BackendNode',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'node_type': data.node_type,
            'node_name': data.node_name,
            'backend_node_id': data.backend_node_id,
        }

    if casing_strategy == 'camel':
        return {
            'nodeType': data.node_type,
            'nodeName': data.node_name,
            'backendNodeId': data.backend_node_id,
        }

    if casing_strategy == 'pascal':
        return {
            'NodeType': data.node_type,
            'NodeName': data.node_name,
            'BackendNodeId': data.backend_node_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__node__to_dict(
        data: 'dom.Node',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'node_id': data.node_id,
            'parent_id': data.parent_id,
            'backend_node_id': data.backend_node_id,
            'node_type': data.node_type,
            'node_name': data.node_name,
            'local_name': data.local_name,
            'node_value': data.node_value,
            'child_node_count': data.child_node_count,
            'children': [
                to_dict(item, casing_strategy)
                for item in data.children
            ],
            'attributes': data.attributes,
            'document_url': data.document_url,
            'base_url': data.base_url,
            'public_id': data.public_id,
            'system_id': data.system_id,
            'internal_subset': data.internal_subset,
            'xml_version': data.xml_version,
            'name': data.name,
            'value': data.value,
            'pseudo_type': data.pseudo_type,
            'pseudo_identifier': data.pseudo_identifier,
            'shadow_root_type': data.shadow_root_type,
            'frame_id': data.frame_id,
            'content_document': to_dict(
                data.content_document,
                casing_strategy
            ),
            'shadow_roots': [
                to_dict(item, casing_strategy)
                for item in data.shadow_roots
            ],
            'template_content': to_dict(
                data.template_content,
                casing_strategy
            ),
            'pseudo_elements': [
                to_dict(item, casing_strategy)
                for item in data.pseudo_elements
            ],
            'imported_document': to_dict(
                data.imported_document,
                casing_strategy
            ),
            'distributed_nodes': [
                to_dict(item, casing_strategy)
                for item in data.distributed_nodes
            ],
            'is_svg': data.is_svg,
            'compatibility_mode': data.compatibility_mode,
            'assigned_slot': to_dict(
                data.assigned_slot,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'nodeId': data.node_id,
            'parentId': data.parent_id,
            'backendNodeId': data.backend_node_id,
            'nodeType': data.node_type,
            'nodeName': data.node_name,
            'localName': data.local_name,
            'nodeValue': data.node_value,
            'childNodeCount': data.child_node_count,
            'children': [
                to_dict(item, casing_strategy)
                for item in data.children
            ],
            'attributes': data.attributes,
            'documentURL': data.document_url,
            'baseURL': data.base_url,
            'publicId': data.public_id,
            'systemId': data.system_id,
            'internalSubset': data.internal_subset,
            'xmlVersion': data.xml_version,
            'name': data.name,
            'value': data.value,
            'pseudoType': data.pseudo_type,
            'pseudoIdentifier': data.pseudo_identifier,
            'shadowRootType': data.shadow_root_type,
            'frameId': data.frame_id,
            'contentDocument': to_dict(
                data.content_document,
                casing_strategy
            ),
            'shadowRoots': [
                to_dict(item, casing_strategy)
                for item in data.shadow_roots
            ],
            'templateContent': to_dict(
                data.template_content,
                casing_strategy
            ),
            'pseudoElements': [
                to_dict(item, casing_strategy)
                for item in data.pseudo_elements
            ],
            'importedDocument': to_dict(
                data.imported_document,
                casing_strategy
            ),
            'distributedNodes': [
                to_dict(item, casing_strategy)
                for item in data.distributed_nodes
            ],
            'isSVG': data.is_svg,
            'compatibilityMode': data.compatibility_mode,
            'assignedSlot': to_dict(
                data.assigned_slot,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'NodeId': data.node_id,
            'ParentId': data.parent_id,
            'BackendNodeId': data.backend_node_id,
            'NodeType': data.node_type,
            'NodeName': data.node_name,
            'LocalName': data.local_name,
            'NodeValue': data.node_value,
            'ChildNodeCount': data.child_node_count,
            'Children': [
                to_dict(item, casing_strategy)
                for item in data.children
            ],
            'Attributes': data.attributes,
            'DocumentURL': data.document_url,
            'BaseURL': data.base_url,
            'PublicId': data.public_id,
            'SystemId': data.system_id,
            'InternalSubset': data.internal_subset,
            'XmlVersion': data.xml_version,
            'Name': data.name,
            'Value': data.value,
            'PseudoType': data.pseudo_type,
            'PseudoIdentifier': data.pseudo_identifier,
            'ShadowRootType': data.shadow_root_type,
            'FrameId': data.frame_id,
            'ContentDocument': to_dict(
                data.content_document,
                casing_strategy
            ),
            'ShadowRoots': [
                to_dict(item, casing_strategy)
                for item in data.shadow_roots
            ],
            'TemplateContent': to_dict(
                data.template_content,
                casing_strategy
            ),
            'PseudoElements': [
                to_dict(item, casing_strategy)
                for item in data.pseudo_elements
            ],
            'ImportedDocument': to_dict(
                data.imported_document,
                casing_strategy
            ),
            'DistributedNodes': [
                to_dict(item, casing_strategy)
                for item in data.distributed_nodes
            ],
            'IsSVG': data.is_svg,
            'CompatibilityMode': data.compatibility_mode,
            'AssignedSlot': to_dict(
                data.assigned_slot,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__rgba__to_dict(
        data: 'dom.RGBA',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'r': data.r,
            'g': data.g,
            'b': data.b,
            'a': data.a,
        }

    if casing_strategy == 'camel':
        return {
            'r': data.r,
            'g': data.g,
            'b': data.b,
            'a': data.a,
        }

    if casing_strategy == 'pascal':
        return {
            'R': data.r,
            'G': data.g,
            'B': data.b,
            'A': data.a,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__box_model__to_dict(
        data: 'dom.BoxModel',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'content': data.content,
            'padding': data.padding,
            'border': data.border,
            'margin': data.margin,
            'width': data.width,
            'height': data.height,
            'shape_outside': to_dict(
                data.shape_outside,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'content': data.content,
            'padding': data.padding,
            'border': data.border,
            'margin': data.margin,
            'width': data.width,
            'height': data.height,
            'shapeOutside': to_dict(
                data.shape_outside,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'Content': data.content,
            'Padding': data.padding,
            'Border': data.border,
            'Margin': data.margin,
            'Width': data.width,
            'Height': data.height,
            'ShapeOutside': to_dict(
                data.shape_outside,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__shape_outside_info__to_dict(
        data: 'dom.ShapeOutsideInfo',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'bounds': data.bounds,
            'shape': data.shape,
            'margin_shape': data.margin_shape,
        }

    if casing_strategy == 'camel':
        return {
            'bounds': data.bounds,
            'shape': data.shape,
            'marginShape': data.margin_shape,
        }

    if casing_strategy == 'pascal':
        return {
            'Bounds': data.bounds,
            'Shape': data.shape,
            'MarginShape': data.margin_shape,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__rect__to_dict(
        data: 'dom.Rect',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'x': data.x,
            'y': data.y,
            'width': data.width,
            'height': data.height,
        }

    if casing_strategy == 'camel':
        return {
            'x': data.x,
            'y': data.y,
            'width': data.width,
            'height': data.height,
        }

    if casing_strategy == 'pascal':
        return {
            'X': data.x,
            'Y': data.y,
            'Width': data.width,
            'Height': data.height,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__css_computed_style_property__to_dict(
        data: 'dom.CSSComputedStyleProperty',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_debugger__event_listener__to_dict(
        data: 'dom_debugger.EventListener',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'use_capture': data.use_capture,
            'passive': data.passive,
            'once': data.once,
            'script_id': data.script_id,
            'line_number': data.line_number,
            'column_number': data.column_number,
            'handler': to_dict(
                data.handler,
                casing_strategy
            ),
            'original_handler': to_dict(
                data.original_handler,
                casing_strategy
            ),
            'backend_node_id': data.backend_node_id,
        }

    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'useCapture': data.use_capture,
            'passive': data.passive,
            'once': data.once,
            'scriptId': data.script_id,
            'lineNumber': data.line_number,
            'columnNumber': data.column_number,
            'handler': to_dict(
                data.handler,
                casing_strategy
            ),
            'originalHandler': to_dict(
                data.original_handler,
                casing_strategy
            ),
            'backendNodeId': data.backend_node_id,
        }

    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'UseCapture': data.use_capture,
            'Passive': data.passive,
            'Once': data.once,
            'ScriptId': data.script_id,
            'LineNumber': data.line_number,
            'ColumnNumber': data.column_number,
            'Handler': to_dict(
                data.handler,
                casing_strategy
            ),
            'OriginalHandler': to_dict(
                data.original_handler,
                casing_strategy
            ),
            'BackendNodeId': data.backend_node_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__dom_node__to_dict(
        data: 'dom_snapshot.DOMNode',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'node_type': data.node_type,
            'node_name': data.node_name,
            'node_value': data.node_value,
            'text_value': data.text_value,
            'input_value': data.input_value,
            'input_checked': data.input_checked,
            'option_selected': data.option_selected,
            'backend_node_id': data.backend_node_id,
            'child_node_indexes': data.child_node_indexes,
            'attributes': [
                to_dict(item, casing_strategy)
                for item in data.attributes
            ],
            'pseudo_element_indexes': data.pseudo_element_indexes,
            'layout_node_index': data.layout_node_index,
            'document_url': data.document_url,
            'base_url': data.base_url,
            'content_language': data.content_language,
            'document_encoding': data.document_encoding,
            'public_id': data.public_id,
            'system_id': data.system_id,
            'frame_id': data.frame_id,
            'content_document_index': data.content_document_index,
            'pseudo_type': data.pseudo_type,
            'shadow_root_type': data.shadow_root_type,
            'is_clickable': data.is_clickable,
            'event_listeners': [
                to_dict(item, casing_strategy)
                for item in data.event_listeners
            ],
            'current_source_url': data.current_source_url,
            'origin_url': data.origin_url,
            'scroll_offset_x': data.scroll_offset_x,
            'scroll_offset_y': data.scroll_offset_y,
        }

    if casing_strategy == 'camel':
        return {
            'nodeType': data.node_type,
            'nodeName': data.node_name,
            'nodeValue': data.node_value,
            'textValue': data.text_value,
            'inputValue': data.input_value,
            'inputChecked': data.input_checked,
            'optionSelected': data.option_selected,
            'backendNodeId': data.backend_node_id,
            'childNodeIndexes': data.child_node_indexes,
            'attributes': [
                to_dict(item, casing_strategy)
                for item in data.attributes
            ],
            'pseudoElementIndexes': data.pseudo_element_indexes,
            'layoutNodeIndex': data.layout_node_index,
            'documentURL': data.document_url,
            'baseURL': data.base_url,
            'contentLanguage': data.content_language,
            'documentEncoding': data.document_encoding,
            'publicId': data.public_id,
            'systemId': data.system_id,
            'frameId': data.frame_id,
            'contentDocumentIndex': data.content_document_index,
            'pseudoType': data.pseudo_type,
            'shadowRootType': data.shadow_root_type,
            'isClickable': data.is_clickable,
            'eventListeners': [
                to_dict(item, casing_strategy)
                for item in data.event_listeners
            ],
            'currentSourceURL': data.current_source_url,
            'originURL': data.origin_url,
            'scrollOffsetX': data.scroll_offset_x,
            'scrollOffsetY': data.scroll_offset_y,
        }

    if casing_strategy == 'pascal':
        return {
            'NodeType': data.node_type,
            'NodeName': data.node_name,
            'NodeValue': data.node_value,
            'TextValue': data.text_value,
            'InputValue': data.input_value,
            'InputChecked': data.input_checked,
            'OptionSelected': data.option_selected,
            'BackendNodeId': data.backend_node_id,
            'ChildNodeIndexes': data.child_node_indexes,
            'Attributes': [
                to_dict(item, casing_strategy)
                for item in data.attributes
            ],
            'PseudoElementIndexes': data.pseudo_element_indexes,
            'LayoutNodeIndex': data.layout_node_index,
            'DocumentURL': data.document_url,
            'BaseURL': data.base_url,
            'ContentLanguage': data.content_language,
            'DocumentEncoding': data.document_encoding,
            'PublicId': data.public_id,
            'SystemId': data.system_id,
            'FrameId': data.frame_id,
            'ContentDocumentIndex': data.content_document_index,
            'PseudoType': data.pseudo_type,
            'ShadowRootType': data.shadow_root_type,
            'IsClickable': data.is_clickable,
            'EventListeners': [
                to_dict(item, casing_strategy)
                for item in data.event_listeners
            ],
            'CurrentSourceURL': data.current_source_url,
            'OriginURL': data.origin_url,
            'ScrollOffsetX': data.scroll_offset_x,
            'ScrollOffsetY': data.scroll_offset_y,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__inline_text_box__to_dict(
        data: 'dom_snapshot.InlineTextBox',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'bounding_box': to_dict(
                data.bounding_box,
                casing_strategy
            ),
            'start_character_index': data.start_character_index,
            'num_characters': data.num_characters,
        }

    if casing_strategy == 'camel':
        return {
            'boundingBox': to_dict(
                data.bounding_box,
                casing_strategy
            ),
            'startCharacterIndex': data.start_character_index,
            'numCharacters': data.num_characters,
        }

    if casing_strategy == 'pascal':
        return {
            'BoundingBox': to_dict(
                data.bounding_box,
                casing_strategy
            ),
            'StartCharacterIndex': data.start_character_index,
            'NumCharacters': data.num_characters,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__layout_tree_node__to_dict(
        data: 'dom_snapshot.LayoutTreeNode',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'dom_node_index': data.dom_node_index,
            'bounding_box': to_dict(
                data.bounding_box,
                casing_strategy
            ),
            'layout_text': data.layout_text,
            'inline_text_nodes': [
                to_dict(item, casing_strategy)
                for item in data.inline_text_nodes
            ],
            'style_index': data.style_index,
            'paint_order': data.paint_order,
            'is_stacking_context': data.is_stacking_context,
        }

    if casing_strategy == 'camel':
        return {
            'domNodeIndex': data.dom_node_index,
            'boundingBox': to_dict(
                data.bounding_box,
                casing_strategy
            ),
            'layoutText': data.layout_text,
            'inlineTextNodes': [
                to_dict(item, casing_strategy)
                for item in data.inline_text_nodes
            ],
            'styleIndex': data.style_index,
            'paintOrder': data.paint_order,
            'isStackingContext': data.is_stacking_context,
        }

    if casing_strategy == 'pascal':
        return {
            'DomNodeIndex': data.dom_node_index,
            'BoundingBox': to_dict(
                data.bounding_box,
                casing_strategy
            ),
            'LayoutText': data.layout_text,
            'InlineTextNodes': [
                to_dict(item, casing_strategy)
                for item in data.inline_text_nodes
            ],
            'StyleIndex': data.style_index,
            'PaintOrder': data.paint_order,
            'IsStackingContext': data.is_stacking_context,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__computed_style__to_dict(
        data: 'dom_snapshot.ComputedStyle',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'properties': [
                to_dict(item, casing_strategy)
                for item in data.properties
            ],
        }

    if casing_strategy == 'camel':
        return {
            'properties': [
                to_dict(item, casing_strategy)
                for item in data.properties
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Properties': [
                to_dict(item, casing_strategy)
                for item in data.properties
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__name_value__to_dict(
        data: 'dom_snapshot.NameValue',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__rare_string_data__to_dict(
        data: 'dom_snapshot.RareStringData',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'index': data.index,
            'value': data.value,
        }

    if casing_strategy == 'camel':
        return {
            'index': data.index,
            'value': data.value,
        }

    if casing_strategy == 'pascal':
        return {
            'Index': data.index,
            'Value': data.value,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__rare_boolean_data__to_dict(
        data: 'dom_snapshot.RareBooleanData',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'index': data.index,
        }

    if casing_strategy == 'camel':
        return {
            'index': data.index,
        }

    if casing_strategy == 'pascal':
        return {
            'Index': data.index,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__rare_integer_data__to_dict(
        data: 'dom_snapshot.RareIntegerData',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'index': data.index,
            'value': data.value,
        }

    if casing_strategy == 'camel':
        return {
            'index': data.index,
            'value': data.value,
        }

    if casing_strategy == 'pascal':
        return {
            'Index': data.index,
            'Value': data.value,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__document_snapshot__to_dict(
        data: 'dom_snapshot.DocumentSnapshot',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'document_url': data.document_url,
            'title': data.title,
            'base_url': data.base_url,
            'content_language': data.content_language,
            'encoding_name': data.encoding_name,
            'public_id': data.public_id,
            'system_id': data.system_id,
            'frame_id': data.frame_id,
            'nodes': to_dict(
                data.nodes,
                casing_strategy
            ),
            'layout': to_dict(
                data.layout,
                casing_strategy
            ),
            'text_boxes': to_dict(
                data.text_boxes,
                casing_strategy
            ),
            'scroll_offset_x': data.scroll_offset_x,
            'scroll_offset_y': data.scroll_offset_y,
            'content_width': data.content_width,
            'content_height': data.content_height,
        }

    if casing_strategy == 'camel':
        return {
            'documentURL': data.document_url,
            'title': data.title,
            'baseURL': data.base_url,
            'contentLanguage': data.content_language,
            'encodingName': data.encoding_name,
            'publicId': data.public_id,
            'systemId': data.system_id,
            'frameId': data.frame_id,
            'nodes': to_dict(
                data.nodes,
                casing_strategy
            ),
            'layout': to_dict(
                data.layout,
                casing_strategy
            ),
            'textBoxes': to_dict(
                data.text_boxes,
                casing_strategy
            ),
            'scrollOffsetX': data.scroll_offset_x,
            'scrollOffsetY': data.scroll_offset_y,
            'contentWidth': data.content_width,
            'contentHeight': data.content_height,
        }

    if casing_strategy == 'pascal':
        return {
            'DocumentURL': data.document_url,
            'Title': data.title,
            'BaseURL': data.base_url,
            'ContentLanguage': data.content_language,
            'EncodingName': data.encoding_name,
            'PublicId': data.public_id,
            'SystemId': data.system_id,
            'FrameId': data.frame_id,
            'Nodes': to_dict(
                data.nodes,
                casing_strategy
            ),
            'Layout': to_dict(
                data.layout,
                casing_strategy
            ),
            'TextBoxes': to_dict(
                data.text_boxes,
                casing_strategy
            ),
            'ScrollOffsetX': data.scroll_offset_x,
            'ScrollOffsetY': data.scroll_offset_y,
            'ContentWidth': data.content_width,
            'ContentHeight': data.content_height,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__node_tree_snapshot__to_dict(
        data: 'dom_snapshot.NodeTreeSnapshot',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'parent_index': data.parent_index,
            'node_type': data.node_type,
            'shadow_root_type': to_dict(
                data.shadow_root_type,
                casing_strategy
            ),
            'node_name': data.node_name,
            'node_value': data.node_value,
            'backend_node_id': data.backend_node_id,
            'attributes': data.attributes,
            'text_value': to_dict(
                data.text_value,
                casing_strategy
            ),
            'input_value': to_dict(
                data.input_value,
                casing_strategy
            ),
            'input_checked': to_dict(
                data.input_checked,
                casing_strategy
            ),
            'option_selected': to_dict(
                data.option_selected,
                casing_strategy
            ),
            'content_document_index': to_dict(
                data.content_document_index,
                casing_strategy
            ),
            'pseudo_type': to_dict(
                data.pseudo_type,
                casing_strategy
            ),
            'pseudo_identifier': to_dict(
                data.pseudo_identifier,
                casing_strategy
            ),
            'is_clickable': to_dict(
                data.is_clickable,
                casing_strategy
            ),
            'current_source_url': to_dict(
                data.current_source_url,
                casing_strategy
            ),
            'origin_url': to_dict(
                data.origin_url,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'parentIndex': data.parent_index,
            'nodeType': data.node_type,
            'shadowRootType': to_dict(
                data.shadow_root_type,
                casing_strategy
            ),
            'nodeName': data.node_name,
            'nodeValue': data.node_value,
            'backendNodeId': data.backend_node_id,
            'attributes': data.attributes,
            'textValue': to_dict(
                data.text_value,
                casing_strategy
            ),
            'inputValue': to_dict(
                data.input_value,
                casing_strategy
            ),
            'inputChecked': to_dict(
                data.input_checked,
                casing_strategy
            ),
            'optionSelected': to_dict(
                data.option_selected,
                casing_strategy
            ),
            'contentDocumentIndex': to_dict(
                data.content_document_index,
                casing_strategy
            ),
            'pseudoType': to_dict(
                data.pseudo_type,
                casing_strategy
            ),
            'pseudoIdentifier': to_dict(
                data.pseudo_identifier,
                casing_strategy
            ),
            'isClickable': to_dict(
                data.is_clickable,
                casing_strategy
            ),
            'currentSourceURL': to_dict(
                data.current_source_url,
                casing_strategy
            ),
            'originURL': to_dict(
                data.origin_url,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'ParentIndex': data.parent_index,
            'NodeType': data.node_type,
            'ShadowRootType': to_dict(
                data.shadow_root_type,
                casing_strategy
            ),
            'NodeName': data.node_name,
            'NodeValue': data.node_value,
            'BackendNodeId': data.backend_node_id,
            'Attributes': data.attributes,
            'TextValue': to_dict(
                data.text_value,
                casing_strategy
            ),
            'InputValue': to_dict(
                data.input_value,
                casing_strategy
            ),
            'InputChecked': to_dict(
                data.input_checked,
                casing_strategy
            ),
            'OptionSelected': to_dict(
                data.option_selected,
                casing_strategy
            ),
            'ContentDocumentIndex': to_dict(
                data.content_document_index,
                casing_strategy
            ),
            'PseudoType': to_dict(
                data.pseudo_type,
                casing_strategy
            ),
            'PseudoIdentifier': to_dict(
                data.pseudo_identifier,
                casing_strategy
            ),
            'IsClickable': to_dict(
                data.is_clickable,
                casing_strategy
            ),
            'CurrentSourceURL': to_dict(
                data.current_source_url,
                casing_strategy
            ),
            'OriginURL': to_dict(
                data.origin_url,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__layout_tree_snapshot__to_dict(
        data: 'dom_snapshot.LayoutTreeSnapshot',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'node_index': data.node_index,
            'styles': data.styles,
            'bounds': data.bounds,
            'text': data.text,
            'stacking_contexts': to_dict(
                data.stacking_contexts,
                casing_strategy
            ),
            'paint_orders': data.paint_orders,
            'offset_rects': data.offset_rects,
            'scroll_rects': data.scroll_rects,
            'client_rects': data.client_rects,
            'blended_background_colors': data.blended_background_colors,
            'text_color_opacities': data.text_color_opacities,
        }

    if casing_strategy == 'camel':
        return {
            'nodeIndex': data.node_index,
            'styles': data.styles,
            'bounds': data.bounds,
            'text': data.text,
            'stackingContexts': to_dict(
                data.stacking_contexts,
                casing_strategy
            ),
            'paintOrders': data.paint_orders,
            'offsetRects': data.offset_rects,
            'scrollRects': data.scroll_rects,
            'clientRects': data.client_rects,
            'blendedBackgroundColors': data.blended_background_colors,
            'textColorOpacities': data.text_color_opacities,
        }

    if casing_strategy == 'pascal':
        return {
            'NodeIndex': data.node_index,
            'Styles': data.styles,
            'Bounds': data.bounds,
            'Text': data.text,
            'StackingContexts': to_dict(
                data.stacking_contexts,
                casing_strategy
            ),
            'PaintOrders': data.paint_orders,
            'OffsetRects': data.offset_rects,
            'ScrollRects': data.scroll_rects,
            'ClientRects': data.client_rects,
            'BlendedBackgroundColors': data.blended_background_colors,
            'TextColorOpacities': data.text_color_opacities,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__text_box_snapshot__to_dict(
        data: 'dom_snapshot.TextBoxSnapshot',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'layout_index': data.layout_index,
            'bounds': data.bounds,
            'start': data.start,
            'length': data.length,
        }

    if casing_strategy == 'camel':
        return {
            'layoutIndex': data.layout_index,
            'bounds': data.bounds,
            'start': data.start,
            'length': data.length,
        }

    if casing_strategy == 'pascal':
        return {
            'LayoutIndex': data.layout_index,
            'Bounds': data.bounds,
            'Start': data.start,
            'Length': data.length,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_storage__storage_id__to_dict(
        data: 'dom_storage.StorageId',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'security_origin': data.security_origin,
            'storage_key': data.storage_key,
            'is_local_storage': data.is_local_storage,
        }

    if casing_strategy == 'camel':
        return {
            'securityOrigin': data.security_origin,
            'storageKey': data.storage_key,
            'isLocalStorage': data.is_local_storage,
        }

    if casing_strategy == 'pascal':
        return {
            'SecurityOrigin': data.security_origin,
            'StorageKey': data.storage_key,
            'IsLocalStorage': data.is_local_storage,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _database__database__to_dict(
        data: 'database.Database',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'id': data.id,
            'domain': data.domain,
            'name': data.name,
            'version': data.version,
        }

    if casing_strategy == 'camel':
        return {
            'id': data.id,
            'domain': data.domain,
            'name': data.name,
            'version': data.version,
        }

    if casing_strategy == 'pascal':
        return {
            'Id': data.id,
            'Domain': data.domain,
            'Name': data.name,
            'Version': data.version,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _database__error__to_dict(
        data: 'database.Error',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'message': data.message,
            'code': data.code,
        }

    if casing_strategy == 'camel':
        return {
            'message': data.message,
            'code': data.code,
        }

    if casing_strategy == 'pascal':
        return {
            'Message': data.message,
            'Code': data.code,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _emulation__screen_orientation__to_dict(
        data: 'emulation.ScreenOrientation',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'angle': data.angle,
        }

    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'angle': data.angle,
        }

    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'Angle': data.angle,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _emulation__display_feature__to_dict(
        data: 'emulation.DisplayFeature',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'orientation': data.orientation,
            'offset': data.offset,
            'mask_length': data.mask_length,
        }

    if casing_strategy == 'camel':
        return {
            'orientation': data.orientation,
            'offset': data.offset,
            'maskLength': data.mask_length,
        }

    if casing_strategy == 'pascal':
        return {
            'Orientation': data.orientation,
            'Offset': data.offset,
            'MaskLength': data.mask_length,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _emulation__media_feature__to_dict(
        data: 'emulation.MediaFeature',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _emulation__user_agent_brand_version__to_dict(
        data: 'emulation.UserAgentBrandVersion',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'brand': data.brand,
            'version': data.version,
        }

    if casing_strategy == 'camel':
        return {
            'brand': data.brand,
            'version': data.version,
        }

    if casing_strategy == 'pascal':
        return {
            'Brand': data.brand,
            'Version': data.version,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _emulation__user_agent_metadata__to_dict(
        data: 'emulation.UserAgentMetadata',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'brands': [
                to_dict(item, casing_strategy)
                for item in data.brands
            ],
            'full_version_list': [
                to_dict(item, casing_strategy)
                for item in data.full_version_list
            ],
            'full_version': data.full_version,
            'platform': data.platform,
            'platform_version': data.platform_version,
            'architecture': data.architecture,
            'model': data.model,
            'mobile': data.mobile,
            'bitness': data.bitness,
            'wow64': data.wow64,
        }

    if casing_strategy == 'camel':
        return {
            'brands': [
                to_dict(item, casing_strategy)
                for item in data.brands
            ],
            'fullVersionList': [
                to_dict(item, casing_strategy)
                for item in data.full_version_list
            ],
            'fullVersion': data.full_version,
            'platform': data.platform,
            'platformVersion': data.platform_version,
            'architecture': data.architecture,
            'model': data.model,
            'mobile': data.mobile,
            'bitness': data.bitness,
            'wow64': data.wow64,
        }

    if casing_strategy == 'pascal':
        return {
            'Brands': [
                to_dict(item, casing_strategy)
                for item in data.brands
            ],
            'FullVersionList': [
                to_dict(item, casing_strategy)
                for item in data.full_version_list
            ],
            'FullVersion': data.full_version,
            'Platform': data.platform,
            'PlatformVersion': data.platform_version,
            'Architecture': data.architecture,
            'Model': data.model,
            'Mobile': data.mobile,
            'Bitness': data.bitness,
            'Wow64': data.wow64,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _headless_experimental__screenshot_params__to_dict(
        data: 'headless_experimental.ScreenshotParams',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'format': data.format,
            'quality': data.quality,
            'optimize_for_speed': data.optimize_for_speed,
        }

    if casing_strategy == 'camel':
        return {
            'format': data.format,
            'quality': data.quality,
            'optimizeForSpeed': data.optimize_for_speed,
        }

    if casing_strategy == 'pascal':
        return {
            'Format': data.format,
            'Quality': data.quality,
            'OptimizeForSpeed': data.optimize_for_speed,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _indexed_db__database_with_object_stores__to_dict(
        data: 'indexed_db.DatabaseWithObjectStores',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'version': data.version,
            'object_stores': [
                to_dict(item, casing_strategy)
                for item in data.object_stores
            ],
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'version': data.version,
            'objectStores': [
                to_dict(item, casing_strategy)
                for item in data.object_stores
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Version': data.version,
            'ObjectStores': [
                to_dict(item, casing_strategy)
                for item in data.object_stores
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _indexed_db__object_store__to_dict(
        data: 'indexed_db.ObjectStore',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'key_path': to_dict(
                data.key_path,
                casing_strategy
            ),
            'auto_increment': data.auto_increment,
            'indexes': [
                to_dict(item, casing_strategy)
                for item in data.indexes
            ],
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'keyPath': to_dict(
                data.key_path,
                casing_strategy
            ),
            'autoIncrement': data.auto_increment,
            'indexes': [
                to_dict(item, casing_strategy)
                for item in data.indexes
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'KeyPath': to_dict(
                data.key_path,
                casing_strategy
            ),
            'AutoIncrement': data.auto_increment,
            'Indexes': [
                to_dict(item, casing_strategy)
                for item in data.indexes
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _indexed_db__object_store_index__to_dict(
        data: 'indexed_db.ObjectStoreIndex',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'key_path': to_dict(
                data.key_path,
                casing_strategy
            ),
            'unique': data.unique,
            'multi_entry': data.multi_entry,
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'keyPath': to_dict(
                data.key_path,
                casing_strategy
            ),
            'unique': data.unique,
            'multiEntry': data.multi_entry,
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'KeyPath': to_dict(
                data.key_path,
                casing_strategy
            ),
            'Unique': data.unique,
            'MultiEntry': data.multi_entry,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _indexed_db__key__to_dict(
        data: 'indexed_db.Key',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'number': data.number,
            'string': data.string,
            'date': data.date,
            'array': [
                to_dict(item, casing_strategy)
                for item in data.array
            ],
        }

    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'number': data.number,
            'string': data.string,
            'date': data.date,
            'array': [
                to_dict(item, casing_strategy)
                for item in data.array
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'Number': data.number,
            'String': data.string,
            'Date': data.date,
            'Array': [
                to_dict(item, casing_strategy)
                for item in data.array
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _indexed_db__key_range__to_dict(
        data: 'indexed_db.KeyRange',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'lower': to_dict(
                data.lower,
                casing_strategy
            ),
            'upper': to_dict(
                data.upper,
                casing_strategy
            ),
            'lower_open': data.lower_open,
            'upper_open': data.upper_open,
        }

    if casing_strategy == 'camel':
        return {
            'lower': to_dict(
                data.lower,
                casing_strategy
            ),
            'upper': to_dict(
                data.upper,
                casing_strategy
            ),
            'lowerOpen': data.lower_open,
            'upperOpen': data.upper_open,
        }

    if casing_strategy == 'pascal':
        return {
            'Lower': to_dict(
                data.lower,
                casing_strategy
            ),
            'Upper': to_dict(
                data.upper,
                casing_strategy
            ),
            'LowerOpen': data.lower_open,
            'UpperOpen': data.upper_open,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _indexed_db__data_entry__to_dict(
        data: 'indexed_db.DataEntry',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'key': to_dict(
                data.key,
                casing_strategy
            ),
            'primary_key': to_dict(
                data.primary_key,
                casing_strategy
            ),
            'value': to_dict(
                data.value,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'key': to_dict(
                data.key,
                casing_strategy
            ),
            'primaryKey': to_dict(
                data.primary_key,
                casing_strategy
            ),
            'value': to_dict(
                data.value,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'Key': to_dict(
                data.key,
                casing_strategy
            ),
            'PrimaryKey': to_dict(
                data.primary_key,
                casing_strategy
            ),
            'Value': to_dict(
                data.value,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _indexed_db__key_path__to_dict(
        data: 'indexed_db.KeyPath',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'string': data.string,
            'array': data.array,
        }

    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'string': data.string,
            'array': data.array,
        }

    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'String': data.string,
            'Array': data.array,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _input__touch_point__to_dict(
        data: 'input_.TouchPoint',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'x': data.x,
            'y': data.y,
            'radius_x': data.radius_x,
            'radius_y': data.radius_y,
            'rotation_angle': data.rotation_angle,
            'force': data.force,
            'tangential_pressure': data.tangential_pressure,
            'tilt_x': data.tilt_x,
            'tilt_y': data.tilt_y,
            'twist': data.twist,
            'id': data.id,
        }

    if casing_strategy == 'camel':
        return {
            'x': data.x,
            'y': data.y,
            'radiusX': data.radius_x,
            'radiusY': data.radius_y,
            'rotationAngle': data.rotation_angle,
            'force': data.force,
            'tangentialPressure': data.tangential_pressure,
            'tiltX': data.tilt_x,
            'tiltY': data.tilt_y,
            'twist': data.twist,
            'id': data.id,
        }

    if casing_strategy == 'pascal':
        return {
            'X': data.x,
            'Y': data.y,
            'RadiusX': data.radius_x,
            'RadiusY': data.radius_y,
            'RotationAngle': data.rotation_angle,
            'Force': data.force,
            'TangentialPressure': data.tangential_pressure,
            'TiltX': data.tilt_x,
            'TiltY': data.tilt_y,
            'Twist': data.twist,
            'Id': data.id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _input__drag_data_item__to_dict(
        data: 'input_.DragDataItem',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'mime_type': data.mime_type,
            'data': data.data,
            'title': data.title,
            'base_url': data.base_url,
        }

    if casing_strategy == 'camel':
        return {
            'mimeType': data.mime_type,
            'data': data.data,
            'title': data.title,
            'baseURL': data.base_url,
        }

    if casing_strategy == 'pascal':
        return {
            'MimeType': data.mime_type,
            'Data': data.data,
            'Title': data.title,
            'BaseURL': data.base_url,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _input__drag_data__to_dict(
        data: 'input_.DragData',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'items': [
                to_dict(item, casing_strategy)
                for item in data.items
            ],
            'files': data.files,
            'drag_operations_mask': data.drag_operations_mask,
        }

    if casing_strategy == 'camel':
        return {
            'items': [
                to_dict(item, casing_strategy)
                for item in data.items
            ],
            'files': data.files,
            'dragOperationsMask': data.drag_operations_mask,
        }

    if casing_strategy == 'pascal':
        return {
            'Items': [
                to_dict(item, casing_strategy)
                for item in data.items
            ],
            'Files': data.files,
            'DragOperationsMask': data.drag_operations_mask,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _layer_tree__scroll_rect__to_dict(
        data: 'layer_tree.ScrollRect',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'rect': to_dict(
                data.rect,
                casing_strategy
            ),
            'type': data.type,
        }

    if casing_strategy == 'camel':
        return {
            'rect': to_dict(
                data.rect,
                casing_strategy
            ),
            'type': data.type,
        }

    if casing_strategy == 'pascal':
        return {
            'Rect': to_dict(
                data.rect,
                casing_strategy
            ),
            'Type': data.type,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _layer_tree__sticky_position_constraint__to_dict(
        data: 'layer_tree.StickyPositionConstraint',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'sticky_box_rect': to_dict(
                data.sticky_box_rect,
                casing_strategy
            ),
            'containing_block_rect': to_dict(
                data.containing_block_rect,
                casing_strategy
            ),
            'nearest_layer_shifting_sticky_box': data.nearest_layer_shifting_sticky_box,
            'nearest_layer_shifting_containing_block': data.nearest_layer_shifting_containing_block,
        }

    if casing_strategy == 'camel':
        return {
            'stickyBoxRect': to_dict(
                data.sticky_box_rect,
                casing_strategy
            ),
            'containingBlockRect': to_dict(
                data.containing_block_rect,
                casing_strategy
            ),
            'nearestLayerShiftingStickyBox': data.nearest_layer_shifting_sticky_box,
            'nearestLayerShiftingContainingBlock': data.nearest_layer_shifting_containing_block,
        }

    if casing_strategy == 'pascal':
        return {
            'StickyBoxRect': to_dict(
                data.sticky_box_rect,
                casing_strategy
            ),
            'ContainingBlockRect': to_dict(
                data.containing_block_rect,
                casing_strategy
            ),
            'NearestLayerShiftingStickyBox': data.nearest_layer_shifting_sticky_box,
            'NearestLayerShiftingContainingBlock': data.nearest_layer_shifting_containing_block,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _layer_tree__picture_tile__to_dict(
        data: 'layer_tree.PictureTile',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'x': data.x,
            'y': data.y,
            'picture': data.picture,
        }

    if casing_strategy == 'camel':
        return {
            'x': data.x,
            'y': data.y,
            'picture': data.picture,
        }

    if casing_strategy == 'pascal':
        return {
            'X': data.x,
            'Y': data.y,
            'Picture': data.picture,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _layer_tree__layer__to_dict(
        data: 'layer_tree.Layer',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'layer_id': data.layer_id,
            'parent_layer_id': data.parent_layer_id,
            'backend_node_id': data.backend_node_id,
            'offset_x': data.offset_x,
            'offset_y': data.offset_y,
            'width': data.width,
            'height': data.height,
            'transform': data.transform,
            'anchor_x': data.anchor_x,
            'anchor_y': data.anchor_y,
            'anchor_z': data.anchor_z,
            'paint_count': data.paint_count,
            'draws_content': data.draws_content,
            'invisible': data.invisible,
            'scroll_rects': [
                to_dict(item, casing_strategy)
                for item in data.scroll_rects
            ],
            'sticky_position_constraint': to_dict(
                data.sticky_position_constraint,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'layerId': data.layer_id,
            'parentLayerId': data.parent_layer_id,
            'backendNodeId': data.backend_node_id,
            'offsetX': data.offset_x,
            'offsetY': data.offset_y,
            'width': data.width,
            'height': data.height,
            'transform': data.transform,
            'anchorX': data.anchor_x,
            'anchorY': data.anchor_y,
            'anchorZ': data.anchor_z,
            'paintCount': data.paint_count,
            'drawsContent': data.draws_content,
            'invisible': data.invisible,
            'scrollRects': [
                to_dict(item, casing_strategy)
                for item in data.scroll_rects
            ],
            'stickyPositionConstraint': to_dict(
                data.sticky_position_constraint,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'LayerId': data.layer_id,
            'ParentLayerId': data.parent_layer_id,
            'BackendNodeId': data.backend_node_id,
            'OffsetX': data.offset_x,
            'OffsetY': data.offset_y,
            'Width': data.width,
            'Height': data.height,
            'Transform': data.transform,
            'AnchorX': data.anchor_x,
            'AnchorY': data.anchor_y,
            'AnchorZ': data.anchor_z,
            'PaintCount': data.paint_count,
            'DrawsContent': data.draws_content,
            'Invisible': data.invisible,
            'ScrollRects': [
                to_dict(item, casing_strategy)
                for item in data.scroll_rects
            ],
            'StickyPositionConstraint': to_dict(
                data.sticky_position_constraint,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _log__log_entry__to_dict(
        data: 'log.LogEntry',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'source': data.source,
            'level': data.level,
            'text': data.text,
            'category': data.category,
            'timestamp': data.timestamp,
            'url': data.url,
            'line_number': data.line_number,
            'stack_trace': to_dict(
                data.stack_trace,
                casing_strategy
            ),
            'network_request_id': data.network_request_id,
            'worker_id': data.worker_id,
            'args': [
                to_dict(item, casing_strategy)
                for item in data.args
            ],
        }

    if casing_strategy == 'camel':
        return {
            'source': data.source,
            'level': data.level,
            'text': data.text,
            'category': data.category,
            'timestamp': data.timestamp,
            'url': data.url,
            'lineNumber': data.line_number,
            'stackTrace': to_dict(
                data.stack_trace,
                casing_strategy
            ),
            'networkRequestId': data.network_request_id,
            'workerId': data.worker_id,
            'args': [
                to_dict(item, casing_strategy)
                for item in data.args
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Source': data.source,
            'Level': data.level,
            'Text': data.text,
            'Category': data.category,
            'Timestamp': data.timestamp,
            'Url': data.url,
            'LineNumber': data.line_number,
            'StackTrace': to_dict(
                data.stack_trace,
                casing_strategy
            ),
            'NetworkRequestId': data.network_request_id,
            'WorkerId': data.worker_id,
            'Args': [
                to_dict(item, casing_strategy)
                for item in data.args
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _log__violation_setting__to_dict(
        data: 'log.ViolationSetting',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'threshold': data.threshold,
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'threshold': data.threshold,
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Threshold': data.threshold,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _memory__sampling_profile_node__to_dict(
        data: 'memory.SamplingProfileNode',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'size': data.size,
            'total': data.total,
            'stack': data.stack,
        }

    if casing_strategy == 'camel':
        return {
            'size': data.size,
            'total': data.total,
            'stack': data.stack,
        }

    if casing_strategy == 'pascal':
        return {
            'Size': data.size,
            'Total': data.total,
            'Stack': data.stack,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _memory__sampling_profile__to_dict(
        data: 'memory.SamplingProfile',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'samples': [
                to_dict(item, casing_strategy)
                for item in data.samples
            ],
            'modules': [
                to_dict(item, casing_strategy)
                for item in data.modules
            ],
        }

    if casing_strategy == 'camel':
        return {
            'samples': [
                to_dict(item, casing_strategy)
                for item in data.samples
            ],
            'modules': [
                to_dict(item, casing_strategy)
                for item in data.modules
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Samples': [
                to_dict(item, casing_strategy)
                for item in data.samples
            ],
            'Modules': [
                to_dict(item, casing_strategy)
                for item in data.modules
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _memory__module__to_dict(
        data: 'memory.Module',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'uuid': data.uuid,
            'base_address': data.base_address,
            'size': data.size,
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'uuid': data.uuid,
            'baseAddress': data.base_address,
            'size': data.size,
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Uuid': data.uuid,
            'BaseAddress': data.base_address,
            'Size': data.size,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__resource_timing__to_dict(
        data: 'network.ResourceTiming',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'request_time': data.request_time,
            'proxy_start': data.proxy_start,
            'proxy_end': data.proxy_end,
            'dns_start': data.dns_start,
            'dns_end': data.dns_end,
            'connect_start': data.connect_start,
            'connect_end': data.connect_end,
            'ssl_start': data.ssl_start,
            'ssl_end': data.ssl_end,
            'worker_start': data.worker_start,
            'worker_ready': data.worker_ready,
            'worker_fetch_start': data.worker_fetch_start,
            'worker_respond_with_settled': data.worker_respond_with_settled,
            'send_start': data.send_start,
            'send_end': data.send_end,
            'push_start': data.push_start,
            'push_end': data.push_end,
            'receive_headers_start': data.receive_headers_start,
            'receive_headers_end': data.receive_headers_end,
        }

    if casing_strategy == 'camel':
        return {
            'requestTime': data.request_time,
            'proxyStart': data.proxy_start,
            'proxyEnd': data.proxy_end,
            'dnsStart': data.dns_start,
            'dnsEnd': data.dns_end,
            'connectStart': data.connect_start,
            'connectEnd': data.connect_end,
            'sslStart': data.ssl_start,
            'sslEnd': data.ssl_end,
            'workerStart': data.worker_start,
            'workerReady': data.worker_ready,
            'workerFetchStart': data.worker_fetch_start,
            'workerRespondWithSettled': data.worker_respond_with_settled,
            'sendStart': data.send_start,
            'sendEnd': data.send_end,
            'pushStart': data.push_start,
            'pushEnd': data.push_end,
            'receiveHeadersStart': data.receive_headers_start,
            'receiveHeadersEnd': data.receive_headers_end,
        }

    if casing_strategy == 'pascal':
        return {
            'RequestTime': data.request_time,
            'ProxyStart': data.proxy_start,
            'ProxyEnd': data.proxy_end,
            'DnsStart': data.dns_start,
            'DnsEnd': data.dns_end,
            'ConnectStart': data.connect_start,
            'ConnectEnd': data.connect_end,
            'SslStart': data.ssl_start,
            'SslEnd': data.ssl_end,
            'WorkerStart': data.worker_start,
            'WorkerReady': data.worker_ready,
            'WorkerFetchStart': data.worker_fetch_start,
            'WorkerRespondWithSettled': data.worker_respond_with_settled,
            'SendStart': data.send_start,
            'SendEnd': data.send_end,
            'PushStart': data.push_start,
            'PushEnd': data.push_end,
            'ReceiveHeadersStart': data.receive_headers_start,
            'ReceiveHeadersEnd': data.receive_headers_end,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__post_data_entry__to_dict(
        data: 'network.PostDataEntry',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'bytes': data.bytes,
        }

    if casing_strategy == 'camel':
        return {
            'bytes': data.bytes,
        }

    if casing_strategy == 'pascal':
        return {
            'Bytes': data.bytes,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__request__to_dict(
        data: 'network.Request',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'url': data.url,
            'url_fragment': data.url_fragment,
            'method': data.method,
            'headers': data.headers,
            'post_data': data.post_data,
            'has_post_data': data.has_post_data,
            'post_data_entries': [
                to_dict(item, casing_strategy)
                for item in data.post_data_entries
            ],
            'mixed_content_type': data.mixed_content_type,
            'initial_priority': data.initial_priority,
            'referrer_policy': data.referrer_policy,
            'is_link_preload': data.is_link_preload,
            'trust_token_params': to_dict(
                data.trust_token_params,
                casing_strategy
            ),
            'is_same_site': data.is_same_site,
        }

    if casing_strategy == 'camel':
        return {
            'url': data.url,
            'urlFragment': data.url_fragment,
            'method': data.method,
            'headers': data.headers,
            'postData': data.post_data,
            'hasPostData': data.has_post_data,
            'postDataEntries': [
                to_dict(item, casing_strategy)
                for item in data.post_data_entries
            ],
            'mixedContentType': data.mixed_content_type,
            'initialPriority': data.initial_priority,
            'referrerPolicy': data.referrer_policy,
            'isLinkPreload': data.is_link_preload,
            'trustTokenParams': to_dict(
                data.trust_token_params,
                casing_strategy
            ),
            'isSameSite': data.is_same_site,
        }

    if casing_strategy == 'pascal':
        return {
            'Url': data.url,
            'UrlFragment': data.url_fragment,
            'Method': data.method,
            'Headers': data.headers,
            'PostData': data.post_data,
            'HasPostData': data.has_post_data,
            'PostDataEntries': [
                to_dict(item, casing_strategy)
                for item in data.post_data_entries
            ],
            'MixedContentType': data.mixed_content_type,
            'InitialPriority': data.initial_priority,
            'ReferrerPolicy': data.referrer_policy,
            'IsLinkPreload': data.is_link_preload,
            'TrustTokenParams': to_dict(
                data.trust_token_params,
                casing_strategy
            ),
            'IsSameSite': data.is_same_site,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__signed_certificate_timestamp__to_dict(
        data: 'network.SignedCertificateTimestamp',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'status': data.status,
            'origin': data.origin,
            'log_description': data.log_description,
            'log_id': data.log_id,
            'timestamp': data.timestamp,
            'hash_algorithm': data.hash_algorithm,
            'signature_algorithm': data.signature_algorithm,
            'signature_data': data.signature_data,
        }

    if casing_strategy == 'camel':
        return {
            'status': data.status,
            'origin': data.origin,
            'logDescription': data.log_description,
            'logId': data.log_id,
            'timestamp': data.timestamp,
            'hashAlgorithm': data.hash_algorithm,
            'signatureAlgorithm': data.signature_algorithm,
            'signatureData': data.signature_data,
        }

    if casing_strategy == 'pascal':
        return {
            'Status': data.status,
            'Origin': data.origin,
            'LogDescription': data.log_description,
            'LogId': data.log_id,
            'Timestamp': data.timestamp,
            'HashAlgorithm': data.hash_algorithm,
            'SignatureAlgorithm': data.signature_algorithm,
            'SignatureData': data.signature_data,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__security_details__to_dict(
        data: 'network.SecurityDetails',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'protocol': data.protocol,
            'key_exchange': data.key_exchange,
            'key_exchange_group': data.key_exchange_group,
            'cipher': data.cipher,
            'mac': data.mac,
            'certificate_id': data.certificate_id,
            'subject_name': data.subject_name,
            'san_list': data.san_list,
            'issuer': data.issuer,
            'valid_from': data.valid_from,
            'valid_to': data.valid_to,
            'signed_certificate_timestamp_list': [
                to_dict(item, casing_strategy)
                for item in data.signed_certificate_timestamp_list
            ],
            'certificate_transparency_compliance': data.certificate_transparency_compliance,
            'server_signature_algorithm': data.server_signature_algorithm,
            'encrypted_client_hello': data.encrypted_client_hello,
        }

    if casing_strategy == 'camel':
        return {
            'protocol': data.protocol,
            'keyExchange': data.key_exchange,
            'keyExchangeGroup': data.key_exchange_group,
            'cipher': data.cipher,
            'mac': data.mac,
            'certificateId': data.certificate_id,
            'subjectName': data.subject_name,
            'sanList': data.san_list,
            'issuer': data.issuer,
            'validFrom': data.valid_from,
            'validTo': data.valid_to,
            'signedCertificateTimestampList': [
                to_dict(item, casing_strategy)
                for item in data.signed_certificate_timestamp_list
            ],
            'certificateTransparencyCompliance': data.certificate_transparency_compliance,
            'serverSignatureAlgorithm': data.server_signature_algorithm,
            'encryptedClientHello': data.encrypted_client_hello,
        }

    if casing_strategy == 'pascal':
        return {
            'Protocol': data.protocol,
            'KeyExchange': data.key_exchange,
            'KeyExchangeGroup': data.key_exchange_group,
            'Cipher': data.cipher,
            'Mac': data.mac,
            'CertificateId': data.certificate_id,
            'SubjectName': data.subject_name,
            'SanList': data.san_list,
            'Issuer': data.issuer,
            'ValidFrom': data.valid_from,
            'ValidTo': data.valid_to,
            'SignedCertificateTimestampList': [
                to_dict(item, casing_strategy)
                for item in data.signed_certificate_timestamp_list
            ],
            'CertificateTransparencyCompliance': data.certificate_transparency_compliance,
            'ServerSignatureAlgorithm': data.server_signature_algorithm,
            'EncryptedClientHello': data.encrypted_client_hello,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__cors_error_status__to_dict(
        data: 'network.CorsErrorStatus',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'cors_error': data.cors_error,
            'failed_parameter': data.failed_parameter,
        }

    if casing_strategy == 'camel':
        return {
            'corsError': data.cors_error,
            'failedParameter': data.failed_parameter,
        }

    if casing_strategy == 'pascal':
        return {
            'CorsError': data.cors_error,
            'FailedParameter': data.failed_parameter,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__trust_token_params__to_dict(
        data: 'network.TrustTokenParams',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'operation': data.operation,
            'refresh_policy': data.refresh_policy,
            'issuers': data.issuers,
        }

    if casing_strategy == 'camel':
        return {
            'operation': data.operation,
            'refreshPolicy': data.refresh_policy,
            'issuers': data.issuers,
        }

    if casing_strategy == 'pascal':
        return {
            'Operation': data.operation,
            'RefreshPolicy': data.refresh_policy,
            'Issuers': data.issuers,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__response__to_dict(
        data: 'network.Response',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'url': data.url,
            'status': data.status,
            'status_text': data.status_text,
            'headers': data.headers,
            'headers_text': data.headers_text,
            'mime_type': data.mime_type,
            'request_headers': data.request_headers,
            'request_headers_text': data.request_headers_text,
            'connection_reused': data.connection_reused,
            'connection_id': data.connection_id,
            'remote_ip_address': data.remote_ip_address,
            'remote_port': data.remote_port,
            'from_disk_cache': data.from_disk_cache,
            'from_service_worker': data.from_service_worker,
            'from_prefetch_cache': data.from_prefetch_cache,
            'encoded_data_length': data.encoded_data_length,
            'timing': to_dict(
                data.timing,
                casing_strategy
            ),
            'service_worker_response_source': data.service_worker_response_source,
            'response_time': data.response_time,
            'cache_storage_cache_name': data.cache_storage_cache_name,
            'protocol': data.protocol,
            'alternate_protocol_usage': data.alternate_protocol_usage,
            'security_state': data.security_state,
            'security_details': to_dict(
                data.security_details,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'url': data.url,
            'status': data.status,
            'statusText': data.status_text,
            'headers': data.headers,
            'headersText': data.headers_text,
            'mimeType': data.mime_type,
            'requestHeaders': data.request_headers,
            'requestHeadersText': data.request_headers_text,
            'connectionReused': data.connection_reused,
            'connectionId': data.connection_id,
            'remoteIPAddress': data.remote_ip_address,
            'remotePort': data.remote_port,
            'fromDiskCache': data.from_disk_cache,
            'fromServiceWorker': data.from_service_worker,
            'fromPrefetchCache': data.from_prefetch_cache,
            'encodedDataLength': data.encoded_data_length,
            'timing': to_dict(
                data.timing,
                casing_strategy
            ),
            'serviceWorkerResponseSource': data.service_worker_response_source,
            'responseTime': data.response_time,
            'cacheStorageCacheName': data.cache_storage_cache_name,
            'protocol': data.protocol,
            'alternateProtocolUsage': data.alternate_protocol_usage,
            'securityState': data.security_state,
            'securityDetails': to_dict(
                data.security_details,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'Url': data.url,
            'Status': data.status,
            'StatusText': data.status_text,
            'Headers': data.headers,
            'HeadersText': data.headers_text,
            'MimeType': data.mime_type,
            'RequestHeaders': data.request_headers,
            'RequestHeadersText': data.request_headers_text,
            'ConnectionReused': data.connection_reused,
            'ConnectionId': data.connection_id,
            'RemoteIPAddress': data.remote_ip_address,
            'RemotePort': data.remote_port,
            'FromDiskCache': data.from_disk_cache,
            'FromServiceWorker': data.from_service_worker,
            'FromPrefetchCache': data.from_prefetch_cache,
            'EncodedDataLength': data.encoded_data_length,
            'Timing': to_dict(
                data.timing,
                casing_strategy
            ),
            'ServiceWorkerResponseSource': data.service_worker_response_source,
            'ResponseTime': data.response_time,
            'CacheStorageCacheName': data.cache_storage_cache_name,
            'Protocol': data.protocol,
            'AlternateProtocolUsage': data.alternate_protocol_usage,
            'SecurityState': data.security_state,
            'SecurityDetails': to_dict(
                data.security_details,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__web_socket_request__to_dict(
        data: 'network.WebSocketRequest',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'headers': data.headers,
        }

    if casing_strategy == 'camel':
        return {
            'headers': data.headers,
        }

    if casing_strategy == 'pascal':
        return {
            'Headers': data.headers,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__web_socket_response__to_dict(
        data: 'network.WebSocketResponse',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'status': data.status,
            'status_text': data.status_text,
            'headers': data.headers,
            'headers_text': data.headers_text,
            'request_headers': data.request_headers,
            'request_headers_text': data.request_headers_text,
        }

    if casing_strategy == 'camel':
        return {
            'status': data.status,
            'statusText': data.status_text,
            'headers': data.headers,
            'headersText': data.headers_text,
            'requestHeaders': data.request_headers,
            'requestHeadersText': data.request_headers_text,
        }

    if casing_strategy == 'pascal':
        return {
            'Status': data.status,
            'StatusText': data.status_text,
            'Headers': data.headers,
            'HeadersText': data.headers_text,
            'RequestHeaders': data.request_headers,
            'RequestHeadersText': data.request_headers_text,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__web_socket_frame__to_dict(
        data: 'network.WebSocketFrame',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'opcode': data.opcode,
            'mask': data.mask,
            'payload_data': data.payload_data,
        }

    if casing_strategy == 'camel':
        return {
            'opcode': data.opcode,
            'mask': data.mask,
            'payloadData': data.payload_data,
        }

    if casing_strategy == 'pascal':
        return {
            'Opcode': data.opcode,
            'Mask': data.mask,
            'PayloadData': data.payload_data,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__cached_resource__to_dict(
        data: 'network.CachedResource',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'url': data.url,
            'type': data.type,
            'response': to_dict(
                data.response,
                casing_strategy
            ),
            'body_size': data.body_size,
        }

    if casing_strategy == 'camel':
        return {
            'url': data.url,
            'type': data.type,
            'response': to_dict(
                data.response,
                casing_strategy
            ),
            'bodySize': data.body_size,
        }

    if casing_strategy == 'pascal':
        return {
            'Url': data.url,
            'Type': data.type,
            'Response': to_dict(
                data.response,
                casing_strategy
            ),
            'BodySize': data.body_size,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__initiator__to_dict(
        data: 'network.Initiator',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'stack': to_dict(
                data.stack,
                casing_strategy
            ),
            'url': data.url,
            'line_number': data.line_number,
            'column_number': data.column_number,
            'request_id': data.request_id,
        }

    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'stack': to_dict(
                data.stack,
                casing_strategy
            ),
            'url': data.url,
            'lineNumber': data.line_number,
            'columnNumber': data.column_number,
            'requestId': data.request_id,
        }

    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'Stack': to_dict(
                data.stack,
                casing_strategy
            ),
            'Url': data.url,
            'LineNumber': data.line_number,
            'ColumnNumber': data.column_number,
            'RequestId': data.request_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__cookie__to_dict(
        data: 'network.Cookie',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
            'domain': data.domain,
            'path': data.path,
            'expires': data.expires,
            'size': data.size,
            'http_only': data.http_only,
            'secure': data.secure,
            'session': data.session,
            'same_site': data.same_site,
            'priority': data.priority,
            'same_party': data.same_party,
            'source_scheme': data.source_scheme,
            'source_port': data.source_port,
            'partition_key': data.partition_key,
            'partition_key_opaque': data.partition_key_opaque,
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
            'domain': data.domain,
            'path': data.path,
            'expires': data.expires,
            'size': data.size,
            'httpOnly': data.http_only,
            'secure': data.secure,
            'session': data.session,
            'sameSite': data.same_site,
            'priority': data.priority,
            'sameParty': data.same_party,
            'sourceScheme': data.source_scheme,
            'sourcePort': data.source_port,
            'partitionKey': data.partition_key,
            'partitionKeyOpaque': data.partition_key_opaque,
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
            'Domain': data.domain,
            'Path': data.path,
            'Expires': data.expires,
            'Size': data.size,
            'HttpOnly': data.http_only,
            'Secure': data.secure,
            'Session': data.session,
            'SameSite': data.same_site,
            'Priority': data.priority,
            'SameParty': data.same_party,
            'SourceScheme': data.source_scheme,
            'SourcePort': data.source_port,
            'PartitionKey': data.partition_key,
            'PartitionKeyOpaque': data.partition_key_opaque,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__blocked_set_cookie_with_reason__to_dict(
        data: 'network.BlockedSetCookieWithReason',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'blocked_reasons': data.blocked_reasons,
            'cookie_line': data.cookie_line,
            'cookie': to_dict(
                data.cookie,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'blockedReasons': data.blocked_reasons,
            'cookieLine': data.cookie_line,
            'cookie': to_dict(
                data.cookie,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'BlockedReasons': data.blocked_reasons,
            'CookieLine': data.cookie_line,
            'Cookie': to_dict(
                data.cookie,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__blocked_cookie_with_reason__to_dict(
        data: 'network.BlockedCookieWithReason',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'blocked_reasons': data.blocked_reasons,
            'cookie': to_dict(
                data.cookie,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'blockedReasons': data.blocked_reasons,
            'cookie': to_dict(
                data.cookie,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'BlockedReasons': data.blocked_reasons,
            'Cookie': to_dict(
                data.cookie,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__cookie_param__to_dict(
        data: 'network.CookieParam',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
            'url': data.url,
            'domain': data.domain,
            'path': data.path,
            'secure': data.secure,
            'http_only': data.http_only,
            'same_site': data.same_site,
            'expires': data.expires,
            'priority': data.priority,
            'same_party': data.same_party,
            'source_scheme': data.source_scheme,
            'source_port': data.source_port,
            'partition_key': data.partition_key,
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
            'url': data.url,
            'domain': data.domain,
            'path': data.path,
            'secure': data.secure,
            'httpOnly': data.http_only,
            'sameSite': data.same_site,
            'expires': data.expires,
            'priority': data.priority,
            'sameParty': data.same_party,
            'sourceScheme': data.source_scheme,
            'sourcePort': data.source_port,
            'partitionKey': data.partition_key,
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
            'Url': data.url,
            'Domain': data.domain,
            'Path': data.path,
            'Secure': data.secure,
            'HttpOnly': data.http_only,
            'SameSite': data.same_site,
            'Expires': data.expires,
            'Priority': data.priority,
            'SameParty': data.same_party,
            'SourceScheme': data.source_scheme,
            'SourcePort': data.source_port,
            'PartitionKey': data.partition_key,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__auth_challenge__to_dict(
        data: 'network.AuthChallenge',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'source': data.source,
            'origin': data.origin,
            'scheme': data.scheme,
            'realm': data.realm,
        }

    if casing_strategy == 'camel':
        return {
            'source': data.source,
            'origin': data.origin,
            'scheme': data.scheme,
            'realm': data.realm,
        }

    if casing_strategy == 'pascal':
        return {
            'Source': data.source,
            'Origin': data.origin,
            'Scheme': data.scheme,
            'Realm': data.realm,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__auth_challenge_response__to_dict(
        data: 'network.AuthChallengeResponse',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'response': data.response,
            'username': data.username,
            'password': data.password,
        }

    if casing_strategy == 'camel':
        return {
            'response': data.response,
            'username': data.username,
            'password': data.password,
        }

    if casing_strategy == 'pascal':
        return {
            'Response': data.response,
            'Username': data.username,
            'Password': data.password,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__request_pattern__to_dict(
        data: 'network.RequestPattern',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'url_pattern': data.url_pattern,
            'resource_type': data.resource_type,
            'interception_stage': data.interception_stage,
        }

    if casing_strategy == 'camel':
        return {
            'urlPattern': data.url_pattern,
            'resourceType': data.resource_type,
            'interceptionStage': data.interception_stage,
        }

    if casing_strategy == 'pascal':
        return {
            'UrlPattern': data.url_pattern,
            'ResourceType': data.resource_type,
            'InterceptionStage': data.interception_stage,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__signed_exchange_signature__to_dict(
        data: 'network.SignedExchangeSignature',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'label': data.label,
            'signature': data.signature,
            'integrity': data.integrity,
            'cert_url': data.cert_url,
            'cert_sha256': data.cert_sha256,
            'validity_url': data.validity_url,
            'date': data.date,
            'expires': data.expires,
            'certificates': data.certificates,
        }

    if casing_strategy == 'camel':
        return {
            'label': data.label,
            'signature': data.signature,
            'integrity': data.integrity,
            'certUrl': data.cert_url,
            'certSha256': data.cert_sha256,
            'validityUrl': data.validity_url,
            'date': data.date,
            'expires': data.expires,
            'certificates': data.certificates,
        }

    if casing_strategy == 'pascal':
        return {
            'Label': data.label,
            'Signature': data.signature,
            'Integrity': data.integrity,
            'CertUrl': data.cert_url,
            'CertSha256': data.cert_sha256,
            'ValidityUrl': data.validity_url,
            'Date': data.date,
            'Expires': data.expires,
            'Certificates': data.certificates,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__signed_exchange_header__to_dict(
        data: 'network.SignedExchangeHeader',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'request_url': data.request_url,
            'response_code': data.response_code,
            'response_headers': data.response_headers,
            'signatures': [
                to_dict(item, casing_strategy)
                for item in data.signatures
            ],
            'header_integrity': data.header_integrity,
        }

    if casing_strategy == 'camel':
        return {
            'requestUrl': data.request_url,
            'responseCode': data.response_code,
            'responseHeaders': data.response_headers,
            'signatures': [
                to_dict(item, casing_strategy)
                for item in data.signatures
            ],
            'headerIntegrity': data.header_integrity,
        }

    if casing_strategy == 'pascal':
        return {
            'RequestUrl': data.request_url,
            'ResponseCode': data.response_code,
            'ResponseHeaders': data.response_headers,
            'Signatures': [
                to_dict(item, casing_strategy)
                for item in data.signatures
            ],
            'HeaderIntegrity': data.header_integrity,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__signed_exchange_error__to_dict(
        data: 'network.SignedExchangeError',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'message': data.message,
            'signature_index': data.signature_index,
            'error_field': data.error_field,
        }

    if casing_strategy == 'camel':
        return {
            'message': data.message,
            'signatureIndex': data.signature_index,
            'errorField': data.error_field,
        }

    if casing_strategy == 'pascal':
        return {
            'Message': data.message,
            'SignatureIndex': data.signature_index,
            'ErrorField': data.error_field,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__signed_exchange_info__to_dict(
        data: 'network.SignedExchangeInfo',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'outer_response': to_dict(
                data.outer_response,
                casing_strategy
            ),
            'header': to_dict(
                data.header,
                casing_strategy
            ),
            'security_details': to_dict(
                data.security_details,
                casing_strategy
            ),
            'errors': [
                to_dict(item, casing_strategy)
                for item in data.errors
            ],
        }

    if casing_strategy == 'camel':
        return {
            'outerResponse': to_dict(
                data.outer_response,
                casing_strategy
            ),
            'header': to_dict(
                data.header,
                casing_strategy
            ),
            'securityDetails': to_dict(
                data.security_details,
                casing_strategy
            ),
            'errors': [
                to_dict(item, casing_strategy)
                for item in data.errors
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'OuterResponse': to_dict(
                data.outer_response,
                casing_strategy
            ),
            'Header': to_dict(
                data.header,
                casing_strategy
            ),
            'SecurityDetails': to_dict(
                data.security_details,
                casing_strategy
            ),
            'Errors': [
                to_dict(item, casing_strategy)
                for item in data.errors
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__connect_timing__to_dict(
        data: 'network.ConnectTiming',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'request_time': data.request_time,
        }

    if casing_strategy == 'camel':
        return {
            'requestTime': data.request_time,
        }

    if casing_strategy == 'pascal':
        return {
            'RequestTime': data.request_time,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__client_security_state__to_dict(
        data: 'network.ClientSecurityState',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'initiator_is_secure_context': data.initiator_is_secure_context,
            'initiator_ip_address_space': data.initiator_ip_address_space,
            'private_network_request_policy': data.private_network_request_policy,
        }

    if casing_strategy == 'camel':
        return {
            'initiatorIsSecureContext': data.initiator_is_secure_context,
            'initiatorIPAddressSpace': data.initiator_ip_address_space,
            'privateNetworkRequestPolicy': data.private_network_request_policy,
        }

    if casing_strategy == 'pascal':
        return {
            'InitiatorIsSecureContext': data.initiator_is_secure_context,
            'InitiatorIPAddressSpace': data.initiator_ip_address_space,
            'PrivateNetworkRequestPolicy': data.private_network_request_policy,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__cross_origin_opener_policy_status__to_dict(
        data: 'network.CrossOriginOpenerPolicyStatus',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'value': data.value,
            'report_only_value': data.report_only_value,
            'reporting_endpoint': data.reporting_endpoint,
            'report_only_reporting_endpoint': data.report_only_reporting_endpoint,
        }

    if casing_strategy == 'camel':
        return {
            'value': data.value,
            'reportOnlyValue': data.report_only_value,
            'reportingEndpoint': data.reporting_endpoint,
            'reportOnlyReportingEndpoint': data.report_only_reporting_endpoint,
        }

    if casing_strategy == 'pascal':
        return {
            'Value': data.value,
            'ReportOnlyValue': data.report_only_value,
            'ReportingEndpoint': data.reporting_endpoint,
            'ReportOnlyReportingEndpoint': data.report_only_reporting_endpoint,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__cross_origin_embedder_policy_status__to_dict(
        data: 'network.CrossOriginEmbedderPolicyStatus',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'value': data.value,
            'report_only_value': data.report_only_value,
            'reporting_endpoint': data.reporting_endpoint,
            'report_only_reporting_endpoint': data.report_only_reporting_endpoint,
        }

    if casing_strategy == 'camel':
        return {
            'value': data.value,
            'reportOnlyValue': data.report_only_value,
            'reportingEndpoint': data.reporting_endpoint,
            'reportOnlyReportingEndpoint': data.report_only_reporting_endpoint,
        }

    if casing_strategy == 'pascal':
        return {
            'Value': data.value,
            'ReportOnlyValue': data.report_only_value,
            'ReportingEndpoint': data.reporting_endpoint,
            'ReportOnlyReportingEndpoint': data.report_only_reporting_endpoint,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__content_security_policy_status__to_dict(
        data: 'network.ContentSecurityPolicyStatus',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'effective_directives': data.effective_directives,
            'is_enforced': data.is_enforced,
            'source': data.source,
        }

    if casing_strategy == 'camel':
        return {
            'effectiveDirectives': data.effective_directives,
            'isEnforced': data.is_enforced,
            'source': data.source,
        }

    if casing_strategy == 'pascal':
        return {
            'EffectiveDirectives': data.effective_directives,
            'IsEnforced': data.is_enforced,
            'Source': data.source,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__security_isolation_status__to_dict(
        data: 'network.SecurityIsolationStatus',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'coop': to_dict(
                data.coop,
                casing_strategy
            ),
            'coep': to_dict(
                data.coep,
                casing_strategy
            ),
            'csp': [
                to_dict(item, casing_strategy)
                for item in data.csp
            ],
        }

    if casing_strategy == 'camel':
        return {
            'coop': to_dict(
                data.coop,
                casing_strategy
            ),
            'coep': to_dict(
                data.coep,
                casing_strategy
            ),
            'csp': [
                to_dict(item, casing_strategy)
                for item in data.csp
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Coop': to_dict(
                data.coop,
                casing_strategy
            ),
            'Coep': to_dict(
                data.coep,
                casing_strategy
            ),
            'Csp': [
                to_dict(item, casing_strategy)
                for item in data.csp
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__reporting_api_report__to_dict(
        data: 'network.ReportingApiReport',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'id': data.id,
            'initiator_url': data.initiator_url,
            'destination': data.destination,
            'type': data.type,
            'timestamp': data.timestamp,
            'depth': data.depth,
            'completed_attempts': data.completed_attempts,
            'body': data.body,
            'status': data.status,
        }

    if casing_strategy == 'camel':
        return {
            'id': data.id,
            'initiatorUrl': data.initiator_url,
            'destination': data.destination,
            'type': data.type,
            'timestamp': data.timestamp,
            'depth': data.depth,
            'completedAttempts': data.completed_attempts,
            'body': data.body,
            'status': data.status,
        }

    if casing_strategy == 'pascal':
        return {
            'Id': data.id,
            'InitiatorUrl': data.initiator_url,
            'Destination': data.destination,
            'Type': data.type,
            'Timestamp': data.timestamp,
            'Depth': data.depth,
            'CompletedAttempts': data.completed_attempts,
            'Body': data.body,
            'Status': data.status,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__reporting_api_endpoint__to_dict(
        data: 'network.ReportingApiEndpoint',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'url': data.url,
            'group_name': data.group_name,
        }

    if casing_strategy == 'camel':
        return {
            'url': data.url,
            'groupName': data.group_name,
        }

    if casing_strategy == 'pascal':
        return {
            'Url': data.url,
            'GroupName': data.group_name,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__load_network_resource_page_result__to_dict(
        data: 'network.LoadNetworkResourcePageResult',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'success': data.success,
            'net_error': data.net_error,
            'net_error_name': data.net_error_name,
            'http_status_code': data.http_status_code,
            'stream': data.stream,
            'headers': data.headers,
        }

    if casing_strategy == 'camel':
        return {
            'success': data.success,
            'netError': data.net_error,
            'netErrorName': data.net_error_name,
            'httpStatusCode': data.http_status_code,
            'stream': data.stream,
            'headers': data.headers,
        }

    if casing_strategy == 'pascal':
        return {
            'Success': data.success,
            'NetError': data.net_error,
            'NetErrorName': data.net_error_name,
            'HttpStatusCode': data.http_status_code,
            'Stream': data.stream,
            'Headers': data.headers,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__load_network_resource_options__to_dict(
        data: 'network.LoadNetworkResourceOptions',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'disable_cache': data.disable_cache,
            'include_credentials': data.include_credentials,
        }

    if casing_strategy == 'camel':
        return {
            'disableCache': data.disable_cache,
            'includeCredentials': data.include_credentials,
        }

    if casing_strategy == 'pascal':
        return {
            'DisableCache': data.disable_cache,
            'IncludeCredentials': data.include_credentials,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__source_order_config__to_dict(
        data: 'overlay.SourceOrderConfig',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'parent_outline_color': to_dict(
                data.parent_outline_color,
                casing_strategy
            ),
            'child_outline_color': to_dict(
                data.child_outline_color,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'parentOutlineColor': to_dict(
                data.parent_outline_color,
                casing_strategy
            ),
            'childOutlineColor': to_dict(
                data.child_outline_color,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'ParentOutlineColor': to_dict(
                data.parent_outline_color,
                casing_strategy
            ),
            'ChildOutlineColor': to_dict(
                data.child_outline_color,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__grid_highlight_config__to_dict(
        data: 'overlay.GridHighlightConfig',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'show_grid_extension_lines': data.show_grid_extension_lines,
            'show_positive_line_numbers': data.show_positive_line_numbers,
            'show_negative_line_numbers': data.show_negative_line_numbers,
            'show_area_names': data.show_area_names,
            'show_line_names': data.show_line_names,
            'show_track_sizes': data.show_track_sizes,
            'grid_border_color': to_dict(
                data.grid_border_color,
                casing_strategy
            ),
            'cell_border_color': to_dict(
                data.cell_border_color,
                casing_strategy
            ),
            'row_line_color': to_dict(
                data.row_line_color,
                casing_strategy
            ),
            'column_line_color': to_dict(
                data.column_line_color,
                casing_strategy
            ),
            'grid_border_dash': data.grid_border_dash,
            'cell_border_dash': data.cell_border_dash,
            'row_line_dash': data.row_line_dash,
            'column_line_dash': data.column_line_dash,
            'row_gap_color': to_dict(
                data.row_gap_color,
                casing_strategy
            ),
            'row_hatch_color': to_dict(
                data.row_hatch_color,
                casing_strategy
            ),
            'column_gap_color': to_dict(
                data.column_gap_color,
                casing_strategy
            ),
            'column_hatch_color': to_dict(
                data.column_hatch_color,
                casing_strategy
            ),
            'area_border_color': to_dict(
                data.area_border_color,
                casing_strategy
            ),
            'grid_background_color': to_dict(
                data.grid_background_color,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'showGridExtensionLines': data.show_grid_extension_lines,
            'showPositiveLineNumbers': data.show_positive_line_numbers,
            'showNegativeLineNumbers': data.show_negative_line_numbers,
            'showAreaNames': data.show_area_names,
            'showLineNames': data.show_line_names,
            'showTrackSizes': data.show_track_sizes,
            'gridBorderColor': to_dict(
                data.grid_border_color,
                casing_strategy
            ),
            'cellBorderColor': to_dict(
                data.cell_border_color,
                casing_strategy
            ),
            'rowLineColor': to_dict(
                data.row_line_color,
                casing_strategy
            ),
            'columnLineColor': to_dict(
                data.column_line_color,
                casing_strategy
            ),
            'gridBorderDash': data.grid_border_dash,
            'cellBorderDash': data.cell_border_dash,
            'rowLineDash': data.row_line_dash,
            'columnLineDash': data.column_line_dash,
            'rowGapColor': to_dict(
                data.row_gap_color,
                casing_strategy
            ),
            'rowHatchColor': to_dict(
                data.row_hatch_color,
                casing_strategy
            ),
            'columnGapColor': to_dict(
                data.column_gap_color,
                casing_strategy
            ),
            'columnHatchColor': to_dict(
                data.column_hatch_color,
                casing_strategy
            ),
            'areaBorderColor': to_dict(
                data.area_border_color,
                casing_strategy
            ),
            'gridBackgroundColor': to_dict(
                data.grid_background_color,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'ShowGridExtensionLines': data.show_grid_extension_lines,
            'ShowPositiveLineNumbers': data.show_positive_line_numbers,
            'ShowNegativeLineNumbers': data.show_negative_line_numbers,
            'ShowAreaNames': data.show_area_names,
            'ShowLineNames': data.show_line_names,
            'ShowTrackSizes': data.show_track_sizes,
            'GridBorderColor': to_dict(
                data.grid_border_color,
                casing_strategy
            ),
            'CellBorderColor': to_dict(
                data.cell_border_color,
                casing_strategy
            ),
            'RowLineColor': to_dict(
                data.row_line_color,
                casing_strategy
            ),
            'ColumnLineColor': to_dict(
                data.column_line_color,
                casing_strategy
            ),
            'GridBorderDash': data.grid_border_dash,
            'CellBorderDash': data.cell_border_dash,
            'RowLineDash': data.row_line_dash,
            'ColumnLineDash': data.column_line_dash,
            'RowGapColor': to_dict(
                data.row_gap_color,
                casing_strategy
            ),
            'RowHatchColor': to_dict(
                data.row_hatch_color,
                casing_strategy
            ),
            'ColumnGapColor': to_dict(
                data.column_gap_color,
                casing_strategy
            ),
            'ColumnHatchColor': to_dict(
                data.column_hatch_color,
                casing_strategy
            ),
            'AreaBorderColor': to_dict(
                data.area_border_color,
                casing_strategy
            ),
            'GridBackgroundColor': to_dict(
                data.grid_background_color,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__flex_container_highlight_config__to_dict(
        data: 'overlay.FlexContainerHighlightConfig',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'container_border': to_dict(
                data.container_border,
                casing_strategy
            ),
            'line_separator': to_dict(
                data.line_separator,
                casing_strategy
            ),
            'item_separator': to_dict(
                data.item_separator,
                casing_strategy
            ),
            'main_distributed_space': to_dict(
                data.main_distributed_space,
                casing_strategy
            ),
            'cross_distributed_space': to_dict(
                data.cross_distributed_space,
                casing_strategy
            ),
            'row_gap_space': to_dict(
                data.row_gap_space,
                casing_strategy
            ),
            'column_gap_space': to_dict(
                data.column_gap_space,
                casing_strategy
            ),
            'cross_alignment': to_dict(
                data.cross_alignment,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'containerBorder': to_dict(
                data.container_border,
                casing_strategy
            ),
            'lineSeparator': to_dict(
                data.line_separator,
                casing_strategy
            ),
            'itemSeparator': to_dict(
                data.item_separator,
                casing_strategy
            ),
            'mainDistributedSpace': to_dict(
                data.main_distributed_space,
                casing_strategy
            ),
            'crossDistributedSpace': to_dict(
                data.cross_distributed_space,
                casing_strategy
            ),
            'rowGapSpace': to_dict(
                data.row_gap_space,
                casing_strategy
            ),
            'columnGapSpace': to_dict(
                data.column_gap_space,
                casing_strategy
            ),
            'crossAlignment': to_dict(
                data.cross_alignment,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'ContainerBorder': to_dict(
                data.container_border,
                casing_strategy
            ),
            'LineSeparator': to_dict(
                data.line_separator,
                casing_strategy
            ),
            'ItemSeparator': to_dict(
                data.item_separator,
                casing_strategy
            ),
            'MainDistributedSpace': to_dict(
                data.main_distributed_space,
                casing_strategy
            ),
            'CrossDistributedSpace': to_dict(
                data.cross_distributed_space,
                casing_strategy
            ),
            'RowGapSpace': to_dict(
                data.row_gap_space,
                casing_strategy
            ),
            'ColumnGapSpace': to_dict(
                data.column_gap_space,
                casing_strategy
            ),
            'CrossAlignment': to_dict(
                data.cross_alignment,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__flex_item_highlight_config__to_dict(
        data: 'overlay.FlexItemHighlightConfig',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'base_size_box': to_dict(
                data.base_size_box,
                casing_strategy
            ),
            'base_size_border': to_dict(
                data.base_size_border,
                casing_strategy
            ),
            'flexibility_arrow': to_dict(
                data.flexibility_arrow,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'baseSizeBox': to_dict(
                data.base_size_box,
                casing_strategy
            ),
            'baseSizeBorder': to_dict(
                data.base_size_border,
                casing_strategy
            ),
            'flexibilityArrow': to_dict(
                data.flexibility_arrow,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'BaseSizeBox': to_dict(
                data.base_size_box,
                casing_strategy
            ),
            'BaseSizeBorder': to_dict(
                data.base_size_border,
                casing_strategy
            ),
            'FlexibilityArrow': to_dict(
                data.flexibility_arrow,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__line_style__to_dict(
        data: 'overlay.LineStyle',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'color': to_dict(
                data.color,
                casing_strategy
            ),
            'pattern': data.pattern,
        }

    if casing_strategy == 'camel':
        return {
            'color': to_dict(
                data.color,
                casing_strategy
            ),
            'pattern': data.pattern,
        }

    if casing_strategy == 'pascal':
        return {
            'Color': to_dict(
                data.color,
                casing_strategy
            ),
            'Pattern': data.pattern,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__box_style__to_dict(
        data: 'overlay.BoxStyle',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'fill_color': to_dict(
                data.fill_color,
                casing_strategy
            ),
            'hatch_color': to_dict(
                data.hatch_color,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'fillColor': to_dict(
                data.fill_color,
                casing_strategy
            ),
            'hatchColor': to_dict(
                data.hatch_color,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'FillColor': to_dict(
                data.fill_color,
                casing_strategy
            ),
            'HatchColor': to_dict(
                data.hatch_color,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__highlight_config__to_dict(
        data: 'overlay.HighlightConfig',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'show_info': data.show_info,
            'show_styles': data.show_styles,
            'show_rulers': data.show_rulers,
            'show_accessibility_info': data.show_accessibility_info,
            'show_extension_lines': data.show_extension_lines,
            'content_color': to_dict(
                data.content_color,
                casing_strategy
            ),
            'padding_color': to_dict(
                data.padding_color,
                casing_strategy
            ),
            'border_color': to_dict(
                data.border_color,
                casing_strategy
            ),
            'margin_color': to_dict(
                data.margin_color,
                casing_strategy
            ),
            'event_target_color': to_dict(
                data.event_target_color,
                casing_strategy
            ),
            'shape_color': to_dict(
                data.shape_color,
                casing_strategy
            ),
            'shape_margin_color': to_dict(
                data.shape_margin_color,
                casing_strategy
            ),
            'css_grid_color': to_dict(
                data.css_grid_color,
                casing_strategy
            ),
            'color_format': data.color_format,
            'grid_highlight_config': to_dict(
                data.grid_highlight_config,
                casing_strategy
            ),
            'flex_container_highlight_config': to_dict(
                data.flex_container_highlight_config,
                casing_strategy
            ),
            'flex_item_highlight_config': to_dict(
                data.flex_item_highlight_config,
                casing_strategy
            ),
            'contrast_algorithm': data.contrast_algorithm,
            'container_query_container_highlight_config': to_dict(
                data.container_query_container_highlight_config,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'showInfo': data.show_info,
            'showStyles': data.show_styles,
            'showRulers': data.show_rulers,
            'showAccessibilityInfo': data.show_accessibility_info,
            'showExtensionLines': data.show_extension_lines,
            'contentColor': to_dict(
                data.content_color,
                casing_strategy
            ),
            'paddingColor': to_dict(
                data.padding_color,
                casing_strategy
            ),
            'borderColor': to_dict(
                data.border_color,
                casing_strategy
            ),
            'marginColor': to_dict(
                data.margin_color,
                casing_strategy
            ),
            'eventTargetColor': to_dict(
                data.event_target_color,
                casing_strategy
            ),
            'shapeColor': to_dict(
                data.shape_color,
                casing_strategy
            ),
            'shapeMarginColor': to_dict(
                data.shape_margin_color,
                casing_strategy
            ),
            'cssGridColor': to_dict(
                data.css_grid_color,
                casing_strategy
            ),
            'colorFormat': data.color_format,
            'gridHighlightConfig': to_dict(
                data.grid_highlight_config,
                casing_strategy
            ),
            'flexContainerHighlightConfig': to_dict(
                data.flex_container_highlight_config,
                casing_strategy
            ),
            'flexItemHighlightConfig': to_dict(
                data.flex_item_highlight_config,
                casing_strategy
            ),
            'contrastAlgorithm': data.contrast_algorithm,
            'containerQueryContainerHighlightConfig': to_dict(
                data.container_query_container_highlight_config,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'ShowInfo': data.show_info,
            'ShowStyles': data.show_styles,
            'ShowRulers': data.show_rulers,
            'ShowAccessibilityInfo': data.show_accessibility_info,
            'ShowExtensionLines': data.show_extension_lines,
            'ContentColor': to_dict(
                data.content_color,
                casing_strategy
            ),
            'PaddingColor': to_dict(
                data.padding_color,
                casing_strategy
            ),
            'BorderColor': to_dict(
                data.border_color,
                casing_strategy
            ),
            'MarginColor': to_dict(
                data.margin_color,
                casing_strategy
            ),
            'EventTargetColor': to_dict(
                data.event_target_color,
                casing_strategy
            ),
            'ShapeColor': to_dict(
                data.shape_color,
                casing_strategy
            ),
            'ShapeMarginColor': to_dict(
                data.shape_margin_color,
                casing_strategy
            ),
            'CssGridColor': to_dict(
                data.css_grid_color,
                casing_strategy
            ),
            'ColorFormat': data.color_format,
            'GridHighlightConfig': to_dict(
                data.grid_highlight_config,
                casing_strategy
            ),
            'FlexContainerHighlightConfig': to_dict(
                data.flex_container_highlight_config,
                casing_strategy
            ),
            'FlexItemHighlightConfig': to_dict(
                data.flex_item_highlight_config,
                casing_strategy
            ),
            'ContrastAlgorithm': data.contrast_algorithm,
            'ContainerQueryContainerHighlightConfig': to_dict(
                data.container_query_container_highlight_config,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__grid_node_highlight_config__to_dict(
        data: 'overlay.GridNodeHighlightConfig',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'grid_highlight_config': to_dict(
                data.grid_highlight_config,
                casing_strategy
            ),
            'node_id': data.node_id,
        }

    if casing_strategy == 'camel':
        return {
            'gridHighlightConfig': to_dict(
                data.grid_highlight_config,
                casing_strategy
            ),
            'nodeId': data.node_id,
        }

    if casing_strategy == 'pascal':
        return {
            'GridHighlightConfig': to_dict(
                data.grid_highlight_config,
                casing_strategy
            ),
            'NodeId': data.node_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__flex_node_highlight_config__to_dict(
        data: 'overlay.FlexNodeHighlightConfig',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'flex_container_highlight_config': to_dict(
                data.flex_container_highlight_config,
                casing_strategy
            ),
            'node_id': data.node_id,
        }

    if casing_strategy == 'camel':
        return {
            'flexContainerHighlightConfig': to_dict(
                data.flex_container_highlight_config,
                casing_strategy
            ),
            'nodeId': data.node_id,
        }

    if casing_strategy == 'pascal':
        return {
            'FlexContainerHighlightConfig': to_dict(
                data.flex_container_highlight_config,
                casing_strategy
            ),
            'NodeId': data.node_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__scroll_snap_container_highlight_config__to_dict(
        data: 'overlay.ScrollSnapContainerHighlightConfig',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'snapport_border': to_dict(
                data.snapport_border,
                casing_strategy
            ),
            'snap_area_border': to_dict(
                data.snap_area_border,
                casing_strategy
            ),
            'scroll_margin_color': to_dict(
                data.scroll_margin_color,
                casing_strategy
            ),
            'scroll_padding_color': to_dict(
                data.scroll_padding_color,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'snapportBorder': to_dict(
                data.snapport_border,
                casing_strategy
            ),
            'snapAreaBorder': to_dict(
                data.snap_area_border,
                casing_strategy
            ),
            'scrollMarginColor': to_dict(
                data.scroll_margin_color,
                casing_strategy
            ),
            'scrollPaddingColor': to_dict(
                data.scroll_padding_color,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'SnapportBorder': to_dict(
                data.snapport_border,
                casing_strategy
            ),
            'SnapAreaBorder': to_dict(
                data.snap_area_border,
                casing_strategy
            ),
            'ScrollMarginColor': to_dict(
                data.scroll_margin_color,
                casing_strategy
            ),
            'ScrollPaddingColor': to_dict(
                data.scroll_padding_color,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__scroll_snap_highlight_config__to_dict(
        data: 'overlay.ScrollSnapHighlightConfig',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'scroll_snap_container_highlight_config': to_dict(
                data.scroll_snap_container_highlight_config,
                casing_strategy
            ),
            'node_id': data.node_id,
        }

    if casing_strategy == 'camel':
        return {
            'scrollSnapContainerHighlightConfig': to_dict(
                data.scroll_snap_container_highlight_config,
                casing_strategy
            ),
            'nodeId': data.node_id,
        }

    if casing_strategy == 'pascal':
        return {
            'ScrollSnapContainerHighlightConfig': to_dict(
                data.scroll_snap_container_highlight_config,
                casing_strategy
            ),
            'NodeId': data.node_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__hinge_config__to_dict(
        data: 'overlay.HingeConfig',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'rect': to_dict(
                data.rect,
                casing_strategy
            ),
            'content_color': to_dict(
                data.content_color,
                casing_strategy
            ),
            'outline_color': to_dict(
                data.outline_color,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'rect': to_dict(
                data.rect,
                casing_strategy
            ),
            'contentColor': to_dict(
                data.content_color,
                casing_strategy
            ),
            'outlineColor': to_dict(
                data.outline_color,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'Rect': to_dict(
                data.rect,
                casing_strategy
            ),
            'ContentColor': to_dict(
                data.content_color,
                casing_strategy
            ),
            'OutlineColor': to_dict(
                data.outline_color,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__container_query_highlight_config__to_dict(
        data: 'overlay.ContainerQueryHighlightConfig',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'container_query_container_highlight_config': to_dict(
                data.container_query_container_highlight_config,
                casing_strategy
            ),
            'node_id': data.node_id,
        }

    if casing_strategy == 'camel':
        return {
            'containerQueryContainerHighlightConfig': to_dict(
                data.container_query_container_highlight_config,
                casing_strategy
            ),
            'nodeId': data.node_id,
        }

    if casing_strategy == 'pascal':
        return {
            'ContainerQueryContainerHighlightConfig': to_dict(
                data.container_query_container_highlight_config,
                casing_strategy
            ),
            'NodeId': data.node_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__container_query_container_highlight_config__to_dict(
        data: 'overlay.ContainerQueryContainerHighlightConfig',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'container_border': to_dict(
                data.container_border,
                casing_strategy
            ),
            'descendant_border': to_dict(
                data.descendant_border,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'containerBorder': to_dict(
                data.container_border,
                casing_strategy
            ),
            'descendantBorder': to_dict(
                data.descendant_border,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'ContainerBorder': to_dict(
                data.container_border,
                casing_strategy
            ),
            'DescendantBorder': to_dict(
                data.descendant_border,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__isolated_element_highlight_config__to_dict(
        data: 'overlay.IsolatedElementHighlightConfig',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'isolation_mode_highlight_config': to_dict(
                data.isolation_mode_highlight_config,
                casing_strategy
            ),
            'node_id': data.node_id,
        }

    if casing_strategy == 'camel':
        return {
            'isolationModeHighlightConfig': to_dict(
                data.isolation_mode_highlight_config,
                casing_strategy
            ),
            'nodeId': data.node_id,
        }

    if casing_strategy == 'pascal':
        return {
            'IsolationModeHighlightConfig': to_dict(
                data.isolation_mode_highlight_config,
                casing_strategy
            ),
            'NodeId': data.node_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__isolation_mode_highlight_config__to_dict(
        data: 'overlay.IsolationModeHighlightConfig',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'resizer_color': to_dict(
                data.resizer_color,
                casing_strategy
            ),
            'resizer_handle_color': to_dict(
                data.resizer_handle_color,
                casing_strategy
            ),
            'mask_color': to_dict(
                data.mask_color,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'resizerColor': to_dict(
                data.resizer_color,
                casing_strategy
            ),
            'resizerHandleColor': to_dict(
                data.resizer_handle_color,
                casing_strategy
            ),
            'maskColor': to_dict(
                data.mask_color,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'ResizerColor': to_dict(
                data.resizer_color,
                casing_strategy
            ),
            'ResizerHandleColor': to_dict(
                data.resizer_handle_color,
                casing_strategy
            ),
            'MaskColor': to_dict(
                data.mask_color,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__ad_frame_status__to_dict(
        data: 'page.AdFrameStatus',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'ad_frame_type': data.ad_frame_type,
            'explanations': data.explanations,
        }

    if casing_strategy == 'camel':
        return {
            'adFrameType': data.ad_frame_type,
            'explanations': data.explanations,
        }

    if casing_strategy == 'pascal':
        return {
            'AdFrameType': data.ad_frame_type,
            'Explanations': data.explanations,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__ad_script_id__to_dict(
        data: 'page.AdScriptId',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'script_id': data.script_id,
            'debugger_id': data.debugger_id,
        }

    if casing_strategy == 'camel':
        return {
            'scriptId': data.script_id,
            'debuggerId': data.debugger_id,
        }

    if casing_strategy == 'pascal':
        return {
            'ScriptId': data.script_id,
            'DebuggerId': data.debugger_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__permissions_policy_block_locator__to_dict(
        data: 'page.PermissionsPolicyBlockLocator',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'frame_id': data.frame_id,
            'block_reason': data.block_reason,
        }

    if casing_strategy == 'camel':
        return {
            'frameId': data.frame_id,
            'blockReason': data.block_reason,
        }

    if casing_strategy == 'pascal':
        return {
            'FrameId': data.frame_id,
            'BlockReason': data.block_reason,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__permissions_policy_feature_state__to_dict(
        data: 'page.PermissionsPolicyFeatureState',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'feature': data.feature,
            'allowed': data.allowed,
            'locator': to_dict(
                data.locator,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'feature': data.feature,
            'allowed': data.allowed,
            'locator': to_dict(
                data.locator,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'Feature': data.feature,
            'Allowed': data.allowed,
            'Locator': to_dict(
                data.locator,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__origin_trial_token__to_dict(
        data: 'page.OriginTrialToken',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'origin': data.origin,
            'match_sub_domains': data.match_sub_domains,
            'trial_name': data.trial_name,
            'expiry_time': data.expiry_time,
            'is_third_party': data.is_third_party,
            'usage_restriction': data.usage_restriction,
        }

    if casing_strategy == 'camel':
        return {
            'origin': data.origin,
            'matchSubDomains': data.match_sub_domains,
            'trialName': data.trial_name,
            'expiryTime': data.expiry_time,
            'isThirdParty': data.is_third_party,
            'usageRestriction': data.usage_restriction,
        }

    if casing_strategy == 'pascal':
        return {
            'Origin': data.origin,
            'MatchSubDomains': data.match_sub_domains,
            'TrialName': data.trial_name,
            'ExpiryTime': data.expiry_time,
            'IsThirdParty': data.is_third_party,
            'UsageRestriction': data.usage_restriction,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__origin_trial_token_with_status__to_dict(
        data: 'page.OriginTrialTokenWithStatus',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'raw_token_text': data.raw_token_text,
            'parsed_token': to_dict(
                data.parsed_token,
                casing_strategy
            ),
            'status': data.status,
        }

    if casing_strategy == 'camel':
        return {
            'rawTokenText': data.raw_token_text,
            'parsedToken': to_dict(
                data.parsed_token,
                casing_strategy
            ),
            'status': data.status,
        }

    if casing_strategy == 'pascal':
        return {
            'RawTokenText': data.raw_token_text,
            'ParsedToken': to_dict(
                data.parsed_token,
                casing_strategy
            ),
            'Status': data.status,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__origin_trial__to_dict(
        data: 'page.OriginTrial',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'trial_name': data.trial_name,
            'status': data.status,
            'tokens_with_status': [
                to_dict(item, casing_strategy)
                for item in data.tokens_with_status
            ],
        }

    if casing_strategy == 'camel':
        return {
            'trialName': data.trial_name,
            'status': data.status,
            'tokensWithStatus': [
                to_dict(item, casing_strategy)
                for item in data.tokens_with_status
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'TrialName': data.trial_name,
            'Status': data.status,
            'TokensWithStatus': [
                to_dict(item, casing_strategy)
                for item in data.tokens_with_status
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__frame__to_dict(
        data: 'page.Frame',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'id': data.id,
            'parent_id': data.parent_id,
            'loader_id': data.loader_id,
            'name': data.name,
            'url': data.url,
            'url_fragment': data.url_fragment,
            'domain_and_registry': data.domain_and_registry,
            'security_origin': data.security_origin,
            'mime_type': data.mime_type,
            'unreachable_url': data.unreachable_url,
            'ad_frame_status': to_dict(
                data.ad_frame_status,
                casing_strategy
            ),
            'secure_context_type': data.secure_context_type,
            'cross_origin_isolated_context_type': data.cross_origin_isolated_context_type,
            'gated_api_features': data.gated_api_features,
        }

    if casing_strategy == 'camel':
        return {
            'id': data.id,
            'parentId': data.parent_id,
            'loaderId': data.loader_id,
            'name': data.name,
            'url': data.url,
            'urlFragment': data.url_fragment,
            'domainAndRegistry': data.domain_and_registry,
            'securityOrigin': data.security_origin,
            'mimeType': data.mime_type,
            'unreachableUrl': data.unreachable_url,
            'adFrameStatus': to_dict(
                data.ad_frame_status,
                casing_strategy
            ),
            'secureContextType': data.secure_context_type,
            'crossOriginIsolatedContextType': data.cross_origin_isolated_context_type,
            'gatedAPIFeatures': data.gated_api_features,
        }

    if casing_strategy == 'pascal':
        return {
            'Id': data.id,
            'ParentId': data.parent_id,
            'LoaderId': data.loader_id,
            'Name': data.name,
            'Url': data.url,
            'UrlFragment': data.url_fragment,
            'DomainAndRegistry': data.domain_and_registry,
            'SecurityOrigin': data.security_origin,
            'MimeType': data.mime_type,
            'UnreachableUrl': data.unreachable_url,
            'AdFrameStatus': to_dict(
                data.ad_frame_status,
                casing_strategy
            ),
            'SecureContextType': data.secure_context_type,
            'CrossOriginIsolatedContextType': data.cross_origin_isolated_context_type,
            'GatedAPIFeatures': data.gated_api_features,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__frame_resource__to_dict(
        data: 'page.FrameResource',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'url': data.url,
            'type': data.type,
            'mime_type': data.mime_type,
            'last_modified': data.last_modified,
            'content_size': data.content_size,
            'failed': data.failed,
            'canceled': data.canceled,
        }

    if casing_strategy == 'camel':
        return {
            'url': data.url,
            'type': data.type,
            'mimeType': data.mime_type,
            'lastModified': data.last_modified,
            'contentSize': data.content_size,
            'failed': data.failed,
            'canceled': data.canceled,
        }

    if casing_strategy == 'pascal':
        return {
            'Url': data.url,
            'Type': data.type,
            'MimeType': data.mime_type,
            'LastModified': data.last_modified,
            'ContentSize': data.content_size,
            'Failed': data.failed,
            'Canceled': data.canceled,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__frame_resource_tree__to_dict(
        data: 'page.FrameResourceTree',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'frame': to_dict(
                data.frame,
                casing_strategy
            ),
            'child_frames': [
                to_dict(item, casing_strategy)
                for item in data.child_frames
            ],
            'resources': [
                to_dict(item, casing_strategy)
                for item in data.resources
            ],
        }

    if casing_strategy == 'camel':
        return {
            'frame': to_dict(
                data.frame,
                casing_strategy
            ),
            'childFrames': [
                to_dict(item, casing_strategy)
                for item in data.child_frames
            ],
            'resources': [
                to_dict(item, casing_strategy)
                for item in data.resources
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Frame': to_dict(
                data.frame,
                casing_strategy
            ),
            'ChildFrames': [
                to_dict(item, casing_strategy)
                for item in data.child_frames
            ],
            'Resources': [
                to_dict(item, casing_strategy)
                for item in data.resources
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__frame_tree__to_dict(
        data: 'page.FrameTree',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'frame': to_dict(
                data.frame,
                casing_strategy
            ),
            'child_frames': [
                to_dict(item, casing_strategy)
                for item in data.child_frames
            ],
        }

    if casing_strategy == 'camel':
        return {
            'frame': to_dict(
                data.frame,
                casing_strategy
            ),
            'childFrames': [
                to_dict(item, casing_strategy)
                for item in data.child_frames
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Frame': to_dict(
                data.frame,
                casing_strategy
            ),
            'ChildFrames': [
                to_dict(item, casing_strategy)
                for item in data.child_frames
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__navigation_entry__to_dict(
        data: 'page.NavigationEntry',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'id': data.id,
            'url': data.url,
            'user_typed_url': data.user_typed_url,
            'title': data.title,
            'transition_type': data.transition_type,
        }

    if casing_strategy == 'camel':
        return {
            'id': data.id,
            'url': data.url,
            'userTypedURL': data.user_typed_url,
            'title': data.title,
            'transitionType': data.transition_type,
        }

    if casing_strategy == 'pascal':
        return {
            'Id': data.id,
            'Url': data.url,
            'UserTypedURL': data.user_typed_url,
            'Title': data.title,
            'TransitionType': data.transition_type,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__screencast_frame_metadata__to_dict(
        data: 'page.ScreencastFrameMetadata',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'offset_top': data.offset_top,
            'page_scale_factor': data.page_scale_factor,
            'device_width': data.device_width,
            'device_height': data.device_height,
            'scroll_offset_x': data.scroll_offset_x,
            'scroll_offset_y': data.scroll_offset_y,
            'timestamp': data.timestamp,
        }

    if casing_strategy == 'camel':
        return {
            'offsetTop': data.offset_top,
            'pageScaleFactor': data.page_scale_factor,
            'deviceWidth': data.device_width,
            'deviceHeight': data.device_height,
            'scrollOffsetX': data.scroll_offset_x,
            'scrollOffsetY': data.scroll_offset_y,
            'timestamp': data.timestamp,
        }

    if casing_strategy == 'pascal':
        return {
            'OffsetTop': data.offset_top,
            'PageScaleFactor': data.page_scale_factor,
            'DeviceWidth': data.device_width,
            'DeviceHeight': data.device_height,
            'ScrollOffsetX': data.scroll_offset_x,
            'ScrollOffsetY': data.scroll_offset_y,
            'Timestamp': data.timestamp,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__app_manifest_error__to_dict(
        data: 'page.AppManifestError',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'message': data.message,
            'critical': data.critical,
            'line': data.line,
            'column': data.column,
        }

    if casing_strategy == 'camel':
        return {
            'message': data.message,
            'critical': data.critical,
            'line': data.line,
            'column': data.column,
        }

    if casing_strategy == 'pascal':
        return {
            'Message': data.message,
            'Critical': data.critical,
            'Line': data.line,
            'Column': data.column,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__app_manifest_parsed_properties__to_dict(
        data: 'page.AppManifestParsedProperties',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'scope': data.scope,
        }

    if casing_strategy == 'camel':
        return {
            'scope': data.scope,
        }

    if casing_strategy == 'pascal':
        return {
            'Scope': data.scope,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__layout_viewport__to_dict(
        data: 'page.LayoutViewport',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'page_x': data.page_x,
            'page_y': data.page_y,
            'client_width': data.client_width,
            'client_height': data.client_height,
        }

    if casing_strategy == 'camel':
        return {
            'pageX': data.page_x,
            'pageY': data.page_y,
            'clientWidth': data.client_width,
            'clientHeight': data.client_height,
        }

    if casing_strategy == 'pascal':
        return {
            'PageX': data.page_x,
            'PageY': data.page_y,
            'ClientWidth': data.client_width,
            'ClientHeight': data.client_height,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__visual_viewport__to_dict(
        data: 'page.VisualViewport',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'offset_x': data.offset_x,
            'offset_y': data.offset_y,
            'page_x': data.page_x,
            'page_y': data.page_y,
            'client_width': data.client_width,
            'client_height': data.client_height,
            'scale': data.scale,
            'zoom': data.zoom,
        }

    if casing_strategy == 'camel':
        return {
            'offsetX': data.offset_x,
            'offsetY': data.offset_y,
            'pageX': data.page_x,
            'pageY': data.page_y,
            'clientWidth': data.client_width,
            'clientHeight': data.client_height,
            'scale': data.scale,
            'zoom': data.zoom,
        }

    if casing_strategy == 'pascal':
        return {
            'OffsetX': data.offset_x,
            'OffsetY': data.offset_y,
            'PageX': data.page_x,
            'PageY': data.page_y,
            'ClientWidth': data.client_width,
            'ClientHeight': data.client_height,
            'Scale': data.scale,
            'Zoom': data.zoom,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__viewport__to_dict(
        data: 'page.Viewport',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'x': data.x,
            'y': data.y,
            'width': data.width,
            'height': data.height,
            'scale': data.scale,
        }

    if casing_strategy == 'camel':
        return {
            'x': data.x,
            'y': data.y,
            'width': data.width,
            'height': data.height,
            'scale': data.scale,
        }

    if casing_strategy == 'pascal':
        return {
            'X': data.x,
            'Y': data.y,
            'Width': data.width,
            'Height': data.height,
            'Scale': data.scale,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__font_families__to_dict(
        data: 'page.FontFamilies',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'standard': data.standard,
            'fixed': data.fixed,
            'serif': data.serif,
            'sans_serif': data.sans_serif,
            'cursive': data.cursive,
            'fantasy': data.fantasy,
            'math': data.math,
        }

    if casing_strategy == 'camel':
        return {
            'standard': data.standard,
            'fixed': data.fixed,
            'serif': data.serif,
            'sansSerif': data.sans_serif,
            'cursive': data.cursive,
            'fantasy': data.fantasy,
            'math': data.math,
        }

    if casing_strategy == 'pascal':
        return {
            'Standard': data.standard,
            'Fixed': data.fixed,
            'Serif': data.serif,
            'SansSerif': data.sans_serif,
            'Cursive': data.cursive,
            'Fantasy': data.fantasy,
            'Math': data.math,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__script_font_families__to_dict(
        data: 'page.ScriptFontFamilies',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'script': data.script,
            'font_families': to_dict(
                data.font_families,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'script': data.script,
            'fontFamilies': to_dict(
                data.font_families,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'Script': data.script,
            'FontFamilies': to_dict(
                data.font_families,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__font_sizes__to_dict(
        data: 'page.FontSizes',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'standard': data.standard,
            'fixed': data.fixed,
        }

    if casing_strategy == 'camel':
        return {
            'standard': data.standard,
            'fixed': data.fixed,
        }

    if casing_strategy == 'pascal':
        return {
            'Standard': data.standard,
            'Fixed': data.fixed,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__installability_error_argument__to_dict(
        data: 'page.InstallabilityErrorArgument',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__installability_error__to_dict(
        data: 'page.InstallabilityError',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'error_id': data.error_id,
            'error_arguments': [
                to_dict(item, casing_strategy)
                for item in data.error_arguments
            ],
        }

    if casing_strategy == 'camel':
        return {
            'errorId': data.error_id,
            'errorArguments': [
                to_dict(item, casing_strategy)
                for item in data.error_arguments
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'ErrorId': data.error_id,
            'ErrorArguments': [
                to_dict(item, casing_strategy)
                for item in data.error_arguments
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__compilation_cache_params__to_dict(
        data: 'page.CompilationCacheParams',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'url': data.url,
            'eager': data.eager,
        }

    if casing_strategy == 'camel':
        return {
            'url': data.url,
            'eager': data.eager,
        }

    if casing_strategy == 'pascal':
        return {
            'Url': data.url,
            'Eager': data.eager,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__back_forward_cache_not_restored_explanation__to_dict(
        data: 'page.BackForwardCacheNotRestoredExplanation',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'reason': data.reason,
            'context': data.context,
        }

    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'reason': data.reason,
            'context': data.context,
        }

    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'Reason': data.reason,
            'Context': data.context,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__back_forward_cache_not_restored_explanation_tree__to_dict(
        data: 'page.BackForwardCacheNotRestoredExplanationTree',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'url': data.url,
            'explanations': [
                to_dict(item, casing_strategy)
                for item in data.explanations
            ],
            'children': [
                to_dict(item, casing_strategy)
                for item in data.children
            ],
        }

    if casing_strategy == 'camel':
        return {
            'url': data.url,
            'explanations': [
                to_dict(item, casing_strategy)
                for item in data.explanations
            ],
            'children': [
                to_dict(item, casing_strategy)
                for item in data.children
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Url': data.url,
            'Explanations': [
                to_dict(item, casing_strategy)
                for item in data.explanations
            ],
            'Children': [
                to_dict(item, casing_strategy)
                for item in data.children
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _performance__metric__to_dict(
        data: 'performance.Metric',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _performance_timeline__largest_contentful_paint__to_dict(
        data: 'performance_timeline.LargestContentfulPaint',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'render_time': data.render_time,
            'load_time': data.load_time,
            'size': data.size,
            'element_id': data.element_id,
            'url': data.url,
            'node_id': data.node_id,
        }

    if casing_strategy == 'camel':
        return {
            'renderTime': data.render_time,
            'loadTime': data.load_time,
            'size': data.size,
            'elementId': data.element_id,
            'url': data.url,
            'nodeId': data.node_id,
        }

    if casing_strategy == 'pascal':
        return {
            'RenderTime': data.render_time,
            'LoadTime': data.load_time,
            'Size': data.size,
            'ElementId': data.element_id,
            'Url': data.url,
            'NodeId': data.node_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _performance_timeline__layout_shift_attribution__to_dict(
        data: 'performance_timeline.LayoutShiftAttribution',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'previous_rect': to_dict(
                data.previous_rect,
                casing_strategy
            ),
            'current_rect': to_dict(
                data.current_rect,
                casing_strategy
            ),
            'node_id': data.node_id,
        }

    if casing_strategy == 'camel':
        return {
            'previousRect': to_dict(
                data.previous_rect,
                casing_strategy
            ),
            'currentRect': to_dict(
                data.current_rect,
                casing_strategy
            ),
            'nodeId': data.node_id,
        }

    if casing_strategy == 'pascal':
        return {
            'PreviousRect': to_dict(
                data.previous_rect,
                casing_strategy
            ),
            'CurrentRect': to_dict(
                data.current_rect,
                casing_strategy
            ),
            'NodeId': data.node_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _performance_timeline__layout_shift__to_dict(
        data: 'performance_timeline.LayoutShift',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'value': data.value,
            'had_recent_input': data.had_recent_input,
            'last_input_time': data.last_input_time,
            'sources': [
                to_dict(item, casing_strategy)
                for item in data.sources
            ],
        }

    if casing_strategy == 'camel':
        return {
            'value': data.value,
            'hadRecentInput': data.had_recent_input,
            'lastInputTime': data.last_input_time,
            'sources': [
                to_dict(item, casing_strategy)
                for item in data.sources
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Value': data.value,
            'HadRecentInput': data.had_recent_input,
            'LastInputTime': data.last_input_time,
            'Sources': [
                to_dict(item, casing_strategy)
                for item in data.sources
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _performance_timeline__timeline_event__to_dict(
        data: 'performance_timeline.TimelineEvent',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'frame_id': data.frame_id,
            'type': data.type,
            'name': data.name,
            'time': data.time,
            'duration': data.duration,
            'lcp_details': to_dict(
                data.lcp_details,
                casing_strategy
            ),
            'layout_shift_details': to_dict(
                data.layout_shift_details,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'frameId': data.frame_id,
            'type': data.type,
            'name': data.name,
            'time': data.time,
            'duration': data.duration,
            'lcpDetails': to_dict(
                data.lcp_details,
                casing_strategy
            ),
            'layoutShiftDetails': to_dict(
                data.layout_shift_details,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'FrameId': data.frame_id,
            'Type': data.type,
            'Name': data.name,
            'Time': data.time,
            'Duration': data.duration,
            'LcpDetails': to_dict(
                data.lcp_details,
                casing_strategy
            ),
            'LayoutShiftDetails': to_dict(
                data.layout_shift_details,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _security__certificate_security_state__to_dict(
        data: 'security.CertificateSecurityState',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'protocol': data.protocol,
            'key_exchange': data.key_exchange,
            'key_exchange_group': data.key_exchange_group,
            'cipher': data.cipher,
            'mac': data.mac,
            'certificate': data.certificate,
            'subject_name': data.subject_name,
            'issuer': data.issuer,
            'valid_from': data.valid_from,
            'valid_to': data.valid_to,
            'certificate_network_error': data.certificate_network_error,
            'certificate_has_weak_signature': data.certificate_has_weak_signature,
            'certificate_has_sha1_signature': data.certificate_has_sha1_signature,
            'modern_ssl': data.modern_ssl,
            'obsolete_ssl_protocol': data.obsolete_ssl_protocol,
            'obsolete_ssl_key_exchange': data.obsolete_ssl_key_exchange,
            'obsolete_ssl_cipher': data.obsolete_ssl_cipher,
            'obsolete_ssl_signature': data.obsolete_ssl_signature,
        }

    if casing_strategy == 'camel':
        return {
            'protocol': data.protocol,
            'keyExchange': data.key_exchange,
            'keyExchangeGroup': data.key_exchange_group,
            'cipher': data.cipher,
            'mac': data.mac,
            'certificate': data.certificate,
            'subjectName': data.subject_name,
            'issuer': data.issuer,
            'validFrom': data.valid_from,
            'validTo': data.valid_to,
            'certificateNetworkError': data.certificate_network_error,
            'certificateHasWeakSignature': data.certificate_has_weak_signature,
            'certificateHasSha1Signature': data.certificate_has_sha1_signature,
            'modernSSL': data.modern_ssl,
            'obsoleteSslProtocol': data.obsolete_ssl_protocol,
            'obsoleteSslKeyExchange': data.obsolete_ssl_key_exchange,
            'obsoleteSslCipher': data.obsolete_ssl_cipher,
            'obsoleteSslSignature': data.obsolete_ssl_signature,
        }

    if casing_strategy == 'pascal':
        return {
            'Protocol': data.protocol,
            'KeyExchange': data.key_exchange,
            'KeyExchangeGroup': data.key_exchange_group,
            'Cipher': data.cipher,
            'Mac': data.mac,
            'Certificate': data.certificate,
            'SubjectName': data.subject_name,
            'Issuer': data.issuer,
            'ValidFrom': data.valid_from,
            'ValidTo': data.valid_to,
            'CertificateNetworkError': data.certificate_network_error,
            'CertificateHasWeakSignature': data.certificate_has_weak_signature,
            'CertificateHasSha1Signature': data.certificate_has_sha1_signature,
            'ModernSSL': data.modern_ssl,
            'ObsoleteSslProtocol': data.obsolete_ssl_protocol,
            'ObsoleteSslKeyExchange': data.obsolete_ssl_key_exchange,
            'ObsoleteSslCipher': data.obsolete_ssl_cipher,
            'ObsoleteSslSignature': data.obsolete_ssl_signature,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _security__safety_tip_info__to_dict(
        data: 'security.SafetyTipInfo',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'safety_tip_status': data.safety_tip_status,
            'safe_url': data.safe_url,
        }

    if casing_strategy == 'camel':
        return {
            'safetyTipStatus': data.safety_tip_status,
            'safeUrl': data.safe_url,
        }

    if casing_strategy == 'pascal':
        return {
            'SafetyTipStatus': data.safety_tip_status,
            'SafeUrl': data.safe_url,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _security__visible_security_state__to_dict(
        data: 'security.VisibleSecurityState',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'security_state': data.security_state,
            'certificate_security_state': to_dict(
                data.certificate_security_state,
                casing_strategy
            ),
            'safety_tip_info': to_dict(
                data.safety_tip_info,
                casing_strategy
            ),
            'security_state_issue_ids': data.security_state_issue_ids,
        }

    if casing_strategy == 'camel':
        return {
            'securityState': data.security_state,
            'certificateSecurityState': to_dict(
                data.certificate_security_state,
                casing_strategy
            ),
            'safetyTipInfo': to_dict(
                data.safety_tip_info,
                casing_strategy
            ),
            'securityStateIssueIds': data.security_state_issue_ids,
        }

    if casing_strategy == 'pascal':
        return {
            'SecurityState': data.security_state,
            'CertificateSecurityState': to_dict(
                data.certificate_security_state,
                casing_strategy
            ),
            'SafetyTipInfo': to_dict(
                data.safety_tip_info,
                casing_strategy
            ),
            'SecurityStateIssueIds': data.security_state_issue_ids,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _security__security_state_explanation__to_dict(
        data: 'security.SecurityStateExplanation',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'security_state': data.security_state,
            'title': data.title,
            'summary': data.summary,
            'description': data.description,
            'mixed_content_type': data.mixed_content_type,
            'certificate': data.certificate,
            'recommendations': data.recommendations,
        }

    if casing_strategy == 'camel':
        return {
            'securityState': data.security_state,
            'title': data.title,
            'summary': data.summary,
            'description': data.description,
            'mixedContentType': data.mixed_content_type,
            'certificate': data.certificate,
            'recommendations': data.recommendations,
        }

    if casing_strategy == 'pascal':
        return {
            'SecurityState': data.security_state,
            'Title': data.title,
            'Summary': data.summary,
            'Description': data.description,
            'MixedContentType': data.mixed_content_type,
            'Certificate': data.certificate,
            'Recommendations': data.recommendations,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _security__insecure_content_status__to_dict(
        data: 'security.InsecureContentStatus',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'ran_mixed_content': data.ran_mixed_content,
            'displayed_mixed_content': data.displayed_mixed_content,
            'contained_mixed_form': data.contained_mixed_form,
            'ran_content_with_cert_errors': data.ran_content_with_cert_errors,
            'displayed_content_with_cert_errors': data.displayed_content_with_cert_errors,
            'ran_insecure_content_style': data.ran_insecure_content_style,
            'displayed_insecure_content_style': data.displayed_insecure_content_style,
        }

    if casing_strategy == 'camel':
        return {
            'ranMixedContent': data.ran_mixed_content,
            'displayedMixedContent': data.displayed_mixed_content,
            'containedMixedForm': data.contained_mixed_form,
            'ranContentWithCertErrors': data.ran_content_with_cert_errors,
            'displayedContentWithCertErrors': data.displayed_content_with_cert_errors,
            'ranInsecureContentStyle': data.ran_insecure_content_style,
            'displayedInsecureContentStyle': data.displayed_insecure_content_style,
        }

    if casing_strategy == 'pascal':
        return {
            'RanMixedContent': data.ran_mixed_content,
            'DisplayedMixedContent': data.displayed_mixed_content,
            'ContainedMixedForm': data.contained_mixed_form,
            'RanContentWithCertErrors': data.ran_content_with_cert_errors,
            'DisplayedContentWithCertErrors': data.displayed_content_with_cert_errors,
            'RanInsecureContentStyle': data.ran_insecure_content_style,
            'DisplayedInsecureContentStyle': data.displayed_insecure_content_style,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _service_worker__service_worker_registration__to_dict(
        data: 'service_worker.ServiceWorkerRegistration',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'registration_id': data.registration_id,
            'scope_url': data.scope_url,
            'is_deleted': data.is_deleted,
        }

    if casing_strategy == 'camel':
        return {
            'registrationId': data.registration_id,
            'scopeURL': data.scope_url,
            'isDeleted': data.is_deleted,
        }

    if casing_strategy == 'pascal':
        return {
            'RegistrationId': data.registration_id,
            'ScopeURL': data.scope_url,
            'IsDeleted': data.is_deleted,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _service_worker__service_worker_version__to_dict(
        data: 'service_worker.ServiceWorkerVersion',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'version_id': data.version_id,
            'registration_id': data.registration_id,
            'script_url': data.script_url,
            'running_status': data.running_status,
            'status': data.status,
            'script_last_modified': data.script_last_modified,
            'script_response_time': data.script_response_time,
            'controlled_clients': data.controlled_clients,
            'target_id': data.target_id,
        }

    if casing_strategy == 'camel':
        return {
            'versionId': data.version_id,
            'registrationId': data.registration_id,
            'scriptURL': data.script_url,
            'runningStatus': data.running_status,
            'status': data.status,
            'scriptLastModified': data.script_last_modified,
            'scriptResponseTime': data.script_response_time,
            'controlledClients': data.controlled_clients,
            'targetId': data.target_id,
        }

    if casing_strategy == 'pascal':
        return {
            'VersionId': data.version_id,
            'RegistrationId': data.registration_id,
            'ScriptURL': data.script_url,
            'RunningStatus': data.running_status,
            'Status': data.status,
            'ScriptLastModified': data.script_last_modified,
            'ScriptResponseTime': data.script_response_time,
            'ControlledClients': data.controlled_clients,
            'TargetId': data.target_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _service_worker__service_worker_error_message__to_dict(
        data: 'service_worker.ServiceWorkerErrorMessage',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'error_message': data.error_message,
            'registration_id': data.registration_id,
            'version_id': data.version_id,
            'source_url': data.source_url,
            'line_number': data.line_number,
            'column_number': data.column_number,
        }

    if casing_strategy == 'camel':
        return {
            'errorMessage': data.error_message,
            'registrationId': data.registration_id,
            'versionId': data.version_id,
            'sourceURL': data.source_url,
            'lineNumber': data.line_number,
            'columnNumber': data.column_number,
        }

    if casing_strategy == 'pascal':
        return {
            'ErrorMessage': data.error_message,
            'RegistrationId': data.registration_id,
            'VersionId': data.version_id,
            'SourceURL': data.source_url,
            'LineNumber': data.line_number,
            'ColumnNumber': data.column_number,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__usage_for_type__to_dict(
        data: 'storage.UsageForType',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'storage_type': data.storage_type,
            'usage': data.usage,
        }

    if casing_strategy == 'camel':
        return {
            'storageType': data.storage_type,
            'usage': data.usage,
        }

    if casing_strategy == 'pascal':
        return {
            'StorageType': data.storage_type,
            'Usage': data.usage,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__trust_tokens__to_dict(
        data: 'storage.TrustTokens',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'issuer_origin': data.issuer_origin,
            'count': data.count,
        }

    if casing_strategy == 'camel':
        return {
            'issuerOrigin': data.issuer_origin,
            'count': data.count,
        }

    if casing_strategy == 'pascal':
        return {
            'IssuerOrigin': data.issuer_origin,
            'Count': data.count,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__interest_group_ad__to_dict(
        data: 'storage.InterestGroupAd',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'render_url': data.render_url,
            'metadata': data.metadata,
        }

    if casing_strategy == 'camel':
        return {
            'renderUrl': data.render_url,
            'metadata': data.metadata,
        }

    if casing_strategy == 'pascal':
        return {
            'RenderUrl': data.render_url,
            'Metadata': data.metadata,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__interest_group_details__to_dict(
        data: 'storage.InterestGroupDetails',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'owner_origin': data.owner_origin,
            'name': data.name,
            'expiration_time': data.expiration_time,
            'joining_origin': data.joining_origin,
            'bidding_url': data.bidding_url,
            'bidding_wasm_helper_url': data.bidding_wasm_helper_url,
            'update_url': data.update_url,
            'trusted_bidding_signals_url': data.trusted_bidding_signals_url,
            'trusted_bidding_signals_keys': data.trusted_bidding_signals_keys,
            'user_bidding_signals': data.user_bidding_signals,
            'ads': [
                to_dict(item, casing_strategy)
                for item in data.ads
            ],
            'ad_components': [
                to_dict(item, casing_strategy)
                for item in data.ad_components
            ],
        }

    if casing_strategy == 'camel':
        return {
            'ownerOrigin': data.owner_origin,
            'name': data.name,
            'expirationTime': data.expiration_time,
            'joiningOrigin': data.joining_origin,
            'biddingUrl': data.bidding_url,
            'biddingWasmHelperUrl': data.bidding_wasm_helper_url,
            'updateUrl': data.update_url,
            'trustedBiddingSignalsUrl': data.trusted_bidding_signals_url,
            'trustedBiddingSignalsKeys': data.trusted_bidding_signals_keys,
            'userBiddingSignals': data.user_bidding_signals,
            'ads': [
                to_dict(item, casing_strategy)
                for item in data.ads
            ],
            'adComponents': [
                to_dict(item, casing_strategy)
                for item in data.ad_components
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'OwnerOrigin': data.owner_origin,
            'Name': data.name,
            'ExpirationTime': data.expiration_time,
            'JoiningOrigin': data.joining_origin,
            'BiddingUrl': data.bidding_url,
            'BiddingWasmHelperUrl': data.bidding_wasm_helper_url,
            'UpdateUrl': data.update_url,
            'TrustedBiddingSignalsUrl': data.trusted_bidding_signals_url,
            'TrustedBiddingSignalsKeys': data.trusted_bidding_signals_keys,
            'UserBiddingSignals': data.user_bidding_signals,
            'Ads': [
                to_dict(item, casing_strategy)
                for item in data.ads
            ],
            'AdComponents': [
                to_dict(item, casing_strategy)
                for item in data.ad_components
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__shared_storage_entry__to_dict(
        data: 'storage.SharedStorageEntry',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'key': data.key,
            'value': data.value,
        }

    if casing_strategy == 'camel':
        return {
            'key': data.key,
            'value': data.value,
        }

    if casing_strategy == 'pascal':
        return {
            'Key': data.key,
            'Value': data.value,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__shared_storage_metadata__to_dict(
        data: 'storage.SharedStorageMetadata',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'creation_time': data.creation_time,
            'length': data.length,
            'remaining_budget': data.remaining_budget,
        }

    if casing_strategy == 'camel':
        return {
            'creationTime': data.creation_time,
            'length': data.length,
            'remainingBudget': data.remaining_budget,
        }

    if casing_strategy == 'pascal':
        return {
            'CreationTime': data.creation_time,
            'Length': data.length,
            'RemainingBudget': data.remaining_budget,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__shared_storage_reporting_metadata__to_dict(
        data: 'storage.SharedStorageReportingMetadata',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'event_type': data.event_type,
            'reporting_url': data.reporting_url,
        }

    if casing_strategy == 'camel':
        return {
            'eventType': data.event_type,
            'reportingUrl': data.reporting_url,
        }

    if casing_strategy == 'pascal':
        return {
            'EventType': data.event_type,
            'ReportingUrl': data.reporting_url,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__shared_storage_url_with_metadata__to_dict(
        data: 'storage.SharedStorageUrlWithMetadata',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'url': data.url,
            'reporting_metadata': [
                to_dict(item, casing_strategy)
                for item in data.reporting_metadata
            ],
        }

    if casing_strategy == 'camel':
        return {
            'url': data.url,
            'reportingMetadata': [
                to_dict(item, casing_strategy)
                for item in data.reporting_metadata
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Url': data.url,
            'ReportingMetadata': [
                to_dict(item, casing_strategy)
                for item in data.reporting_metadata
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__shared_storage_access_params__to_dict(
        data: 'storage.SharedStorageAccessParams',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'script_source_url': data.script_source_url,
            'operation_name': data.operation_name,
            'serialized_data': data.serialized_data,
            'urls_with_metadata': [
                to_dict(item, casing_strategy)
                for item in data.urls_with_metadata
            ],
            'key': data.key,
            'value': data.value,
            'ignore_if_present': data.ignore_if_present,
        }

    if casing_strategy == 'camel':
        return {
            'scriptSourceUrl': data.script_source_url,
            'operationName': data.operation_name,
            'serializedData': data.serialized_data,
            'urlsWithMetadata': [
                to_dict(item, casing_strategy)
                for item in data.urls_with_metadata
            ],
            'key': data.key,
            'value': data.value,
            'ignoreIfPresent': data.ignore_if_present,
        }

    if casing_strategy == 'pascal':
        return {
            'ScriptSourceUrl': data.script_source_url,
            'OperationName': data.operation_name,
            'SerializedData': data.serialized_data,
            'UrlsWithMetadata': [
                to_dict(item, casing_strategy)
                for item in data.urls_with_metadata
            ],
            'Key': data.key,
            'Value': data.value,
            'IgnoreIfPresent': data.ignore_if_present,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__storage_bucket__to_dict(
        data: 'storage.StorageBucket',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'storage_key': data.storage_key,
            'name': data.name,
        }

    if casing_strategy == 'camel':
        return {
            'storageKey': data.storage_key,
            'name': data.name,
        }

    if casing_strategy == 'pascal':
        return {
            'StorageKey': data.storage_key,
            'Name': data.name,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__storage_bucket_info__to_dict(
        data: 'storage.StorageBucketInfo',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'bucket': to_dict(
                data.bucket,
                casing_strategy
            ),
            'id': data.id,
            'expiration': data.expiration,
            'quota': data.quota,
            'persistent': data.persistent,
            'durability': data.durability,
        }

    if casing_strategy == 'camel':
        return {
            'bucket': to_dict(
                data.bucket,
                casing_strategy
            ),
            'id': data.id,
            'expiration': data.expiration,
            'quota': data.quota,
            'persistent': data.persistent,
            'durability': data.durability,
        }

    if casing_strategy == 'pascal':
        return {
            'Bucket': to_dict(
                data.bucket,
                casing_strategy
            ),
            'Id': data.id,
            'Expiration': data.expiration,
            'Quota': data.quota,
            'Persistent': data.persistent,
            'Durability': data.durability,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__attribution_reporting_filter_data_entry__to_dict(
        data: 'storage.AttributionReportingFilterDataEntry',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'key': data.key,
            'values': data.values,
        }

    if casing_strategy == 'camel':
        return {
            'key': data.key,
            'values': data.values,
        }

    if casing_strategy == 'pascal':
        return {
            'Key': data.key,
            'Values': data.values,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__attribution_reporting_aggregation_keys_entry__to_dict(
        data: 'storage.AttributionReportingAggregationKeysEntry',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'key': data.key,
            'value': data.value,
        }

    if casing_strategy == 'camel':
        return {
            'key': data.key,
            'value': data.value,
        }

    if casing_strategy == 'pascal':
        return {
            'Key': data.key,
            'Value': data.value,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__attribution_reporting_event_report_windows__to_dict(
        data: 'storage.AttributionReportingEventReportWindows',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'start': data.start,
            'ends': data.ends,
        }

    if casing_strategy == 'camel':
        return {
            'start': data.start,
            'ends': data.ends,
        }

    if casing_strategy == 'pascal':
        return {
            'Start': data.start,
            'Ends': data.ends,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__attribution_reporting_source_registration__to_dict(
        data: 'storage.AttributionReportingSourceRegistration',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'time': data.time,
            'expiry': data.expiry,
            'event_report_window': data.event_report_window,
            'event_report_windows': to_dict(
                data.event_report_windows,
                casing_strategy
            ),
            'aggregatable_report_window': data.aggregatable_report_window,
            'type': data.type,
            'source_origin': data.source_origin,
            'reporting_origin': data.reporting_origin,
            'destination_sites': data.destination_sites,
            'event_id': data.event_id,
            'priority': data.priority,
            'filter_data': [
                to_dict(item, casing_strategy)
                for item in data.filter_data
            ],
            'aggregation_keys': [
                to_dict(item, casing_strategy)
                for item in data.aggregation_keys
            ],
            'debug_key': data.debug_key,
        }

    if casing_strategy == 'camel':
        return {
            'time': data.time,
            'expiry': data.expiry,
            'eventReportWindow': data.event_report_window,
            'eventReportWindows': to_dict(
                data.event_report_windows,
                casing_strategy
            ),
            'aggregatableReportWindow': data.aggregatable_report_window,
            'type': data.type,
            'sourceOrigin': data.source_origin,
            'reportingOrigin': data.reporting_origin,
            'destinationSites': data.destination_sites,
            'eventId': data.event_id,
            'priority': data.priority,
            'filterData': [
                to_dict(item, casing_strategy)
                for item in data.filter_data
            ],
            'aggregationKeys': [
                to_dict(item, casing_strategy)
                for item in data.aggregation_keys
            ],
            'debugKey': data.debug_key,
        }

    if casing_strategy == 'pascal':
        return {
            'Time': data.time,
            'Expiry': data.expiry,
            'EventReportWindow': data.event_report_window,
            'EventReportWindows': to_dict(
                data.event_report_windows,
                casing_strategy
            ),
            'AggregatableReportWindow': data.aggregatable_report_window,
            'Type': data.type,
            'SourceOrigin': data.source_origin,
            'ReportingOrigin': data.reporting_origin,
            'DestinationSites': data.destination_sites,
            'EventId': data.event_id,
            'Priority': data.priority,
            'FilterData': [
                to_dict(item, casing_strategy)
                for item in data.filter_data
            ],
            'AggregationKeys': [
                to_dict(item, casing_strategy)
                for item in data.aggregation_keys
            ],
            'DebugKey': data.debug_key,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _system_info__gpu_device__to_dict(
        data: 'system_info.GPUDevice',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'vendor_id': data.vendor_id,
            'device_id': data.device_id,
            'sub_sys_id': data.sub_sys_id,
            'revision': data.revision,
            'vendor_string': data.vendor_string,
            'device_string': data.device_string,
            'driver_vendor': data.driver_vendor,
            'driver_version': data.driver_version,
        }

    if casing_strategy == 'camel':
        return {
            'vendorId': data.vendor_id,
            'deviceId': data.device_id,
            'subSysId': data.sub_sys_id,
            'revision': data.revision,
            'vendorString': data.vendor_string,
            'deviceString': data.device_string,
            'driverVendor': data.driver_vendor,
            'driverVersion': data.driver_version,
        }

    if casing_strategy == 'pascal':
        return {
            'VendorId': data.vendor_id,
            'DeviceId': data.device_id,
            'SubSysId': data.sub_sys_id,
            'Revision': data.revision,
            'VendorString': data.vendor_string,
            'DeviceString': data.device_string,
            'DriverVendor': data.driver_vendor,
            'DriverVersion': data.driver_version,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _system_info__size__to_dict(
        data: 'system_info.Size',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'width': data.width,
            'height': data.height,
        }

    if casing_strategy == 'camel':
        return {
            'width': data.width,
            'height': data.height,
        }

    if casing_strategy == 'pascal':
        return {
            'Width': data.width,
            'Height': data.height,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _system_info__video_decode_accelerator_capability__to_dict(
        data: 'system_info.VideoDecodeAcceleratorCapability',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'profile': data.profile,
            'max_resolution': to_dict(
                data.max_resolution,
                casing_strategy
            ),
            'min_resolution': to_dict(
                data.min_resolution,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'profile': data.profile,
            'maxResolution': to_dict(
                data.max_resolution,
                casing_strategy
            ),
            'minResolution': to_dict(
                data.min_resolution,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'Profile': data.profile,
            'MaxResolution': to_dict(
                data.max_resolution,
                casing_strategy
            ),
            'MinResolution': to_dict(
                data.min_resolution,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _system_info__video_encode_accelerator_capability__to_dict(
        data: 'system_info.VideoEncodeAcceleratorCapability',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'profile': data.profile,
            'max_resolution': to_dict(
                data.max_resolution,
                casing_strategy
            ),
            'max_framerate_numerator': data.max_framerate_numerator,
            'max_framerate_denominator': data.max_framerate_denominator,
        }

    if casing_strategy == 'camel':
        return {
            'profile': data.profile,
            'maxResolution': to_dict(
                data.max_resolution,
                casing_strategy
            ),
            'maxFramerateNumerator': data.max_framerate_numerator,
            'maxFramerateDenominator': data.max_framerate_denominator,
        }

    if casing_strategy == 'pascal':
        return {
            'Profile': data.profile,
            'MaxResolution': to_dict(
                data.max_resolution,
                casing_strategy
            ),
            'MaxFramerateNumerator': data.max_framerate_numerator,
            'MaxFramerateDenominator': data.max_framerate_denominator,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _system_info__image_decode_accelerator_capability__to_dict(
        data: 'system_info.ImageDecodeAcceleratorCapability',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'image_type': data.image_type,
            'max_dimensions': to_dict(
                data.max_dimensions,
                casing_strategy
            ),
            'min_dimensions': to_dict(
                data.min_dimensions,
                casing_strategy
            ),
            'subsamplings': data.subsamplings,
        }

    if casing_strategy == 'camel':
        return {
            'imageType': data.image_type,
            'maxDimensions': to_dict(
                data.max_dimensions,
                casing_strategy
            ),
            'minDimensions': to_dict(
                data.min_dimensions,
                casing_strategy
            ),
            'subsamplings': data.subsamplings,
        }

    if casing_strategy == 'pascal':
        return {
            'ImageType': data.image_type,
            'MaxDimensions': to_dict(
                data.max_dimensions,
                casing_strategy
            ),
            'MinDimensions': to_dict(
                data.min_dimensions,
                casing_strategy
            ),
            'Subsamplings': data.subsamplings,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _system_info__gpu_info__to_dict(
        data: 'system_info.GPUInfo',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'devices': [
                to_dict(item, casing_strategy)
                for item in data.devices
            ],
            'aux_attributes': data.aux_attributes,
            'feature_status': data.feature_status,
            'driver_bug_workarounds': data.driver_bug_workarounds,
            'video_decoding': [
                to_dict(item, casing_strategy)
                for item in data.video_decoding
            ],
            'video_encoding': [
                to_dict(item, casing_strategy)
                for item in data.video_encoding
            ],
            'image_decoding': [
                to_dict(item, casing_strategy)
                for item in data.image_decoding
            ],
        }

    if casing_strategy == 'camel':
        return {
            'devices': [
                to_dict(item, casing_strategy)
                for item in data.devices
            ],
            'auxAttributes': data.aux_attributes,
            'featureStatus': data.feature_status,
            'driverBugWorkarounds': data.driver_bug_workarounds,
            'videoDecoding': [
                to_dict(item, casing_strategy)
                for item in data.video_decoding
            ],
            'videoEncoding': [
                to_dict(item, casing_strategy)
                for item in data.video_encoding
            ],
            'imageDecoding': [
                to_dict(item, casing_strategy)
                for item in data.image_decoding
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Devices': [
                to_dict(item, casing_strategy)
                for item in data.devices
            ],
            'AuxAttributes': data.aux_attributes,
            'FeatureStatus': data.feature_status,
            'DriverBugWorkarounds': data.driver_bug_workarounds,
            'VideoDecoding': [
                to_dict(item, casing_strategy)
                for item in data.video_decoding
            ],
            'VideoEncoding': [
                to_dict(item, casing_strategy)
                for item in data.video_encoding
            ],
            'ImageDecoding': [
                to_dict(item, casing_strategy)
                for item in data.image_decoding
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _system_info__process_info__to_dict(
        data: 'system_info.ProcessInfo',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'id': data.id,
            'cpu_time': data.cpu_time,
        }

    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'id': data.id,
            'cpuTime': data.cpu_time,
        }

    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'Id': data.id,
            'CpuTime': data.cpu_time,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _target__target_info__to_dict(
        data: 'target.TargetInfo',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'target_id': data.target_id,
            'type': data.type,
            'title': data.title,
            'url': data.url,
            'attached': data.attached,
            'opener_id': data.opener_id,
            'can_access_opener': data.can_access_opener,
            'opener_frame_id': data.opener_frame_id,
            'browser_context_id': data.browser_context_id,
            'subtype': data.subtype,
        }

    if casing_strategy == 'camel':
        return {
            'targetId': data.target_id,
            'type': data.type,
            'title': data.title,
            'url': data.url,
            'attached': data.attached,
            'openerId': data.opener_id,
            'canAccessOpener': data.can_access_opener,
            'openerFrameId': data.opener_frame_id,
            'browserContextId': data.browser_context_id,
            'subtype': data.subtype,
        }

    if casing_strategy == 'pascal':
        return {
            'TargetId': data.target_id,
            'Type': data.type,
            'Title': data.title,
            'Url': data.url,
            'Attached': data.attached,
            'OpenerId': data.opener_id,
            'CanAccessOpener': data.can_access_opener,
            'OpenerFrameId': data.opener_frame_id,
            'BrowserContextId': data.browser_context_id,
            'Subtype': data.subtype,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _target__filter_entry__to_dict(
        data: 'target.FilterEntry',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'exclude': data.exclude,
            'type': data.type,
        }

    if casing_strategy == 'camel':
        return {
            'exclude': data.exclude,
            'type': data.type,
        }

    if casing_strategy == 'pascal':
        return {
            'Exclude': data.exclude,
            'Type': data.type,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _target__remote_location__to_dict(
        data: 'target.RemoteLocation',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'host': data.host,
            'port': data.port,
        }

    if casing_strategy == 'camel':
        return {
            'host': data.host,
            'port': data.port,
        }

    if casing_strategy == 'pascal':
        return {
            'Host': data.host,
            'Port': data.port,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _tracing__trace_config__to_dict(
        data: 'tracing.TraceConfig',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'record_mode': data.record_mode,
            'trace_buffer_size_in_kb': data.trace_buffer_size_in_kb,
            'enable_sampling': data.enable_sampling,
            'enable_systrace': data.enable_systrace,
            'enable_argument_filter': data.enable_argument_filter,
            'included_categories': data.included_categories,
            'excluded_categories': data.excluded_categories,
            'synthetic_delays': data.synthetic_delays,
            'memory_dump_config': data.memory_dump_config,
        }

    if casing_strategy == 'camel':
        return {
            'recordMode': data.record_mode,
            'traceBufferSizeInKb': data.trace_buffer_size_in_kb,
            'enableSampling': data.enable_sampling,
            'enableSystrace': data.enable_systrace,
            'enableArgumentFilter': data.enable_argument_filter,
            'includedCategories': data.included_categories,
            'excludedCategories': data.excluded_categories,
            'syntheticDelays': data.synthetic_delays,
            'memoryDumpConfig': data.memory_dump_config,
        }

    if casing_strategy == 'pascal':
        return {
            'RecordMode': data.record_mode,
            'TraceBufferSizeInKb': data.trace_buffer_size_in_kb,
            'EnableSampling': data.enable_sampling,
            'EnableSystrace': data.enable_systrace,
            'EnableArgumentFilter': data.enable_argument_filter,
            'IncludedCategories': data.included_categories,
            'ExcludedCategories': data.excluded_categories,
            'SyntheticDelays': data.synthetic_delays,
            'MemoryDumpConfig': data.memory_dump_config,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _fetch__request_pattern__to_dict(
        data: 'fetch.RequestPattern',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'url_pattern': data.url_pattern,
            'resource_type': data.resource_type,
            'request_stage': data.request_stage,
        }

    if casing_strategy == 'camel':
        return {
            'urlPattern': data.url_pattern,
            'resourceType': data.resource_type,
            'requestStage': data.request_stage,
        }

    if casing_strategy == 'pascal':
        return {
            'UrlPattern': data.url_pattern,
            'ResourceType': data.resource_type,
            'RequestStage': data.request_stage,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _fetch__header_entry__to_dict(
        data: 'fetch.HeaderEntry',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _fetch__auth_challenge__to_dict(
        data: 'fetch.AuthChallenge',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'source': data.source,
            'origin': data.origin,
            'scheme': data.scheme,
            'realm': data.realm,
        }

    if casing_strategy == 'camel':
        return {
            'source': data.source,
            'origin': data.origin,
            'scheme': data.scheme,
            'realm': data.realm,
        }

    if casing_strategy == 'pascal':
        return {
            'Source': data.source,
            'Origin': data.origin,
            'Scheme': data.scheme,
            'Realm': data.realm,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _fetch__auth_challenge_response__to_dict(
        data: 'fetch.AuthChallengeResponse',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'response': data.response,
            'username': data.username,
            'password': data.password,
        }

    if casing_strategy == 'camel':
        return {
            'response': data.response,
            'username': data.username,
            'password': data.password,
        }

    if casing_strategy == 'pascal':
        return {
            'Response': data.response,
            'Username': data.username,
            'Password': data.password,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _web_audio__context_realtime_data__to_dict(
        data: 'web_audio.ContextRealtimeData',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'current_time': data.current_time,
            'render_capacity': data.render_capacity,
            'callback_interval_mean': data.callback_interval_mean,
            'callback_interval_variance': data.callback_interval_variance,
        }

    if casing_strategy == 'camel':
        return {
            'currentTime': data.current_time,
            'renderCapacity': data.render_capacity,
            'callbackIntervalMean': data.callback_interval_mean,
            'callbackIntervalVariance': data.callback_interval_variance,
        }

    if casing_strategy == 'pascal':
        return {
            'CurrentTime': data.current_time,
            'RenderCapacity': data.render_capacity,
            'CallbackIntervalMean': data.callback_interval_mean,
            'CallbackIntervalVariance': data.callback_interval_variance,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _web_audio__base_audio_context__to_dict(
        data: 'web_audio.BaseAudioContext',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'context_id': data.context_id,
            'context_type': data.context_type,
            'context_state': data.context_state,
            'realtime_data': to_dict(
                data.realtime_data,
                casing_strategy
            ),
            'callback_buffer_size': data.callback_buffer_size,
            'max_output_channel_count': data.max_output_channel_count,
            'sample_rate': data.sample_rate,
        }

    if casing_strategy == 'camel':
        return {
            'contextId': data.context_id,
            'contextType': data.context_type,
            'contextState': data.context_state,
            'realtimeData': to_dict(
                data.realtime_data,
                casing_strategy
            ),
            'callbackBufferSize': data.callback_buffer_size,
            'maxOutputChannelCount': data.max_output_channel_count,
            'sampleRate': data.sample_rate,
        }

    if casing_strategy == 'pascal':
        return {
            'ContextId': data.context_id,
            'ContextType': data.context_type,
            'ContextState': data.context_state,
            'RealtimeData': to_dict(
                data.realtime_data,
                casing_strategy
            ),
            'CallbackBufferSize': data.callback_buffer_size,
            'MaxOutputChannelCount': data.max_output_channel_count,
            'SampleRate': data.sample_rate,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _web_audio__audio_listener__to_dict(
        data: 'web_audio.AudioListener',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'listener_id': data.listener_id,
            'context_id': data.context_id,
        }

    if casing_strategy == 'camel':
        return {
            'listenerId': data.listener_id,
            'contextId': data.context_id,
        }

    if casing_strategy == 'pascal':
        return {
            'ListenerId': data.listener_id,
            'ContextId': data.context_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _web_audio__audio_node__to_dict(
        data: 'web_audio.AudioNode',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'node_id': data.node_id,
            'context_id': data.context_id,
            'node_type': data.node_type,
            'number_of_inputs': data.number_of_inputs,
            'number_of_outputs': data.number_of_outputs,
            'channel_count': data.channel_count,
            'channel_count_mode': data.channel_count_mode,
            'channel_interpretation': data.channel_interpretation,
        }

    if casing_strategy == 'camel':
        return {
            'nodeId': data.node_id,
            'contextId': data.context_id,
            'nodeType': data.node_type,
            'numberOfInputs': data.number_of_inputs,
            'numberOfOutputs': data.number_of_outputs,
            'channelCount': data.channel_count,
            'channelCountMode': data.channel_count_mode,
            'channelInterpretation': data.channel_interpretation,
        }

    if casing_strategy == 'pascal':
        return {
            'NodeId': data.node_id,
            'ContextId': data.context_id,
            'NodeType': data.node_type,
            'NumberOfInputs': data.number_of_inputs,
            'NumberOfOutputs': data.number_of_outputs,
            'ChannelCount': data.channel_count,
            'ChannelCountMode': data.channel_count_mode,
            'ChannelInterpretation': data.channel_interpretation,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _web_audio__audio_param__to_dict(
        data: 'web_audio.AudioParam',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'param_id': data.param_id,
            'node_id': data.node_id,
            'context_id': data.context_id,
            'param_type': data.param_type,
            'rate': data.rate,
            'default_value': data.default_value,
            'min_value': data.min_value,
            'max_value': data.max_value,
        }

    if casing_strategy == 'camel':
        return {
            'paramId': data.param_id,
            'nodeId': data.node_id,
            'contextId': data.context_id,
            'paramType': data.param_type,
            'rate': data.rate,
            'defaultValue': data.default_value,
            'minValue': data.min_value,
            'maxValue': data.max_value,
        }

    if casing_strategy == 'pascal':
        return {
            'ParamId': data.param_id,
            'NodeId': data.node_id,
            'ContextId': data.context_id,
            'ParamType': data.param_type,
            'Rate': data.rate,
            'DefaultValue': data.default_value,
            'MinValue': data.min_value,
            'MaxValue': data.max_value,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _web_authn__virtual_authenticator_options__to_dict(
        data: 'web_authn.VirtualAuthenticatorOptions',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'protocol': data.protocol,
            'ctap2_version': data.ctap2_version,
            'transport': data.transport,
            'has_resident_key': data.has_resident_key,
            'has_user_verification': data.has_user_verification,
            'has_large_blob': data.has_large_blob,
            'has_cred_blob': data.has_cred_blob,
            'has_min_pin_length': data.has_min_pin_length,
            'has_prf': data.has_prf,
            'automatic_presence_simulation': data.automatic_presence_simulation,
            'is_user_verified': data.is_user_verified,
        }

    if casing_strategy == 'camel':
        return {
            'protocol': data.protocol,
            'ctap2Version': data.ctap2_version,
            'transport': data.transport,
            'hasResidentKey': data.has_resident_key,
            'hasUserVerification': data.has_user_verification,
            'hasLargeBlob': data.has_large_blob,
            'hasCredBlob': data.has_cred_blob,
            'hasMinPinLength': data.has_min_pin_length,
            'hasPrf': data.has_prf,
            'automaticPresenceSimulation': data.automatic_presence_simulation,
            'isUserVerified': data.is_user_verified,
        }

    if casing_strategy == 'pascal':
        return {
            'Protocol': data.protocol,
            'Ctap2Version': data.ctap2_version,
            'Transport': data.transport,
            'HasResidentKey': data.has_resident_key,
            'HasUserVerification': data.has_user_verification,
            'HasLargeBlob': data.has_large_blob,
            'HasCredBlob': data.has_cred_blob,
            'HasMinPinLength': data.has_min_pin_length,
            'HasPrf': data.has_prf,
            'AutomaticPresenceSimulation': data.automatic_presence_simulation,
            'IsUserVerified': data.is_user_verified,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _web_authn__credential__to_dict(
        data: 'web_authn.Credential',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'credential_id': data.credential_id,
            'is_resident_credential': data.is_resident_credential,
            'rp_id': data.rp_id,
            'private_key': data.private_key,
            'user_handle': data.user_handle,
            'sign_count': data.sign_count,
            'large_blob': data.large_blob,
        }

    if casing_strategy == 'camel':
        return {
            'credentialId': data.credential_id,
            'isResidentCredential': data.is_resident_credential,
            'rpId': data.rp_id,
            'privateKey': data.private_key,
            'userHandle': data.user_handle,
            'signCount': data.sign_count,
            'largeBlob': data.large_blob,
        }

    if casing_strategy == 'pascal':
        return {
            'CredentialId': data.credential_id,
            'IsResidentCredential': data.is_resident_credential,
            'RpId': data.rp_id,
            'PrivateKey': data.private_key,
            'UserHandle': data.user_handle,
            'SignCount': data.sign_count,
            'LargeBlob': data.large_blob,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _media__player_message__to_dict(
        data: 'media.PlayerMessage',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'level': data.level,
            'message': data.message,
        }

    if casing_strategy == 'camel':
        return {
            'level': data.level,
            'message': data.message,
        }

    if casing_strategy == 'pascal':
        return {
            'Level': data.level,
            'Message': data.message,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _media__player_property__to_dict(
        data: 'media.PlayerProperty',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': data.value,
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': data.value,
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': data.value,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _media__player_event__to_dict(
        data: 'media.PlayerEvent',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'timestamp': data.timestamp,
            'value': data.value,
        }

    if casing_strategy == 'camel':
        return {
            'timestamp': data.timestamp,
            'value': data.value,
        }

    if casing_strategy == 'pascal':
        return {
            'Timestamp': data.timestamp,
            'Value': data.value,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _media__player_error_source_location__to_dict(
        data: 'media.PlayerErrorSourceLocation',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'file': data.file,
            'line': data.line,
        }

    if casing_strategy == 'camel':
        return {
            'file': data.file,
            'line': data.line,
        }

    if casing_strategy == 'pascal':
        return {
            'File': data.file,
            'Line': data.line,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _media__player_error__to_dict(
        data: 'media.PlayerError',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'error_type': data.error_type,
            'code': data.code,
            'stack': [
                to_dict(item, casing_strategy)
                for item in data.stack
            ],
            'cause': [
                to_dict(item, casing_strategy)
                for item in data.cause
            ],
            'data': data.data,
        }

    if casing_strategy == 'camel':
        return {
            'errorType': data.error_type,
            'code': data.code,
            'stack': [
                to_dict(item, casing_strategy)
                for item in data.stack
            ],
            'cause': [
                to_dict(item, casing_strategy)
                for item in data.cause
            ],
            'data': data.data,
        }

    if casing_strategy == 'pascal':
        return {
            'ErrorType': data.error_type,
            'Code': data.code,
            'Stack': [
                to_dict(item, casing_strategy)
                for item in data.stack
            ],
            'Cause': [
                to_dict(item, casing_strategy)
                for item in data.cause
            ],
            'Data': data.data,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _device_access__prompt_device__to_dict(
        data: 'device_access.PromptDevice',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'id': data.id,
            'name': data.name,
        }

    if casing_strategy == 'camel':
        return {
            'id': data.id,
            'name': data.name,
        }

    if casing_strategy == 'pascal':
        return {
            'Id': data.id,
            'Name': data.name,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _preload__rule_set__to_dict(
        data: 'preload.RuleSet',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'id': data.id,
            'loader_id': data.loader_id,
            'source_text': data.source_text,
            'backend_node_id': data.backend_node_id,
            'url': data.url,
            'request_id': data.request_id,
            'error_type': data.error_type,
            'error_message': data.error_message,
        }

    if casing_strategy == 'camel':
        return {
            'id': data.id,
            'loaderId': data.loader_id,
            'sourceText': data.source_text,
            'backendNodeId': data.backend_node_id,
            'url': data.url,
            'requestId': data.request_id,
            'errorType': data.error_type,
            'errorMessage': data.error_message,
        }

    if casing_strategy == 'pascal':
        return {
            'Id': data.id,
            'LoaderId': data.loader_id,
            'SourceText': data.source_text,
            'BackendNodeId': data.backend_node_id,
            'Url': data.url,
            'RequestId': data.request_id,
            'ErrorType': data.error_type,
            'ErrorMessage': data.error_message,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _preload__preloading_attempt_key__to_dict(
        data: 'preload.PreloadingAttemptKey',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'loader_id': data.loader_id,
            'action': data.action,
            'url': data.url,
            'target_hint': data.target_hint,
        }

    if casing_strategy == 'camel':
        return {
            'loaderId': data.loader_id,
            'action': data.action,
            'url': data.url,
            'targetHint': data.target_hint,
        }

    if casing_strategy == 'pascal':
        return {
            'LoaderId': data.loader_id,
            'Action': data.action,
            'Url': data.url,
            'TargetHint': data.target_hint,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _preload__preloading_attempt_source__to_dict(
        data: 'preload.PreloadingAttemptSource',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'key': to_dict(
                data.key,
                casing_strategy
            ),
            'rule_set_ids': data.rule_set_ids,
            'node_ids': data.node_ids,
        }

    if casing_strategy == 'camel':
        return {
            'key': to_dict(
                data.key,
                casing_strategy
            ),
            'ruleSetIds': data.rule_set_ids,
            'nodeIds': data.node_ids,
        }

    if casing_strategy == 'pascal':
        return {
            'Key': to_dict(
                data.key,
                casing_strategy
            ),
            'RuleSetIds': data.rule_set_ids,
            'NodeIds': data.node_ids,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _fed_cm__account__to_dict(
        data: 'fed_cm.Account',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'account_id': data.account_id,
            'email': data.email,
            'name': data.name,
            'given_name': data.given_name,
            'picture_url': data.picture_url,
            'idp_config_url': data.idp_config_url,
            'idp_signin_url': data.idp_signin_url,
            'login_state': data.login_state,
            'terms_of_service_url': data.terms_of_service_url,
            'privacy_policy_url': data.privacy_policy_url,
        }

    if casing_strategy == 'camel':
        return {
            'accountId': data.account_id,
            'email': data.email,
            'name': data.name,
            'givenName': data.given_name,
            'pictureUrl': data.picture_url,
            'idpConfigUrl': data.idp_config_url,
            'idpSigninUrl': data.idp_signin_url,
            'loginState': data.login_state,
            'termsOfServiceUrl': data.terms_of_service_url,
            'privacyPolicyUrl': data.privacy_policy_url,
        }

    if casing_strategy == 'pascal':
        return {
            'AccountId': data.account_id,
            'Email': data.email,
            'Name': data.name,
            'GivenName': data.given_name,
            'PictureUrl': data.picture_url,
            'IdpConfigUrl': data.idp_config_url,
            'IdpSigninUrl': data.idp_signin_url,
            'LoginState': data.login_state,
            'TermsOfServiceUrl': data.terms_of_service_url,
            'PrivacyPolicyUrl': data.privacy_policy_url,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _console__console_message__to_dict(
        data: 'console.ConsoleMessage',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'source': data.source,
            'level': data.level,
            'text': data.text,
            'url': data.url,
            'line': data.line,
            'column': data.column,
        }

    if casing_strategy == 'camel':
        return {
            'source': data.source,
            'level': data.level,
            'text': data.text,
            'url': data.url,
            'line': data.line,
            'column': data.column,
        }

    if casing_strategy == 'pascal':
        return {
            'Source': data.source,
            'Level': data.level,
            'Text': data.text,
            'Url': data.url,
            'Line': data.line,
            'Column': data.column,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__location__to_dict(
        data: 'debugger.Location',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'script_id': data.script_id,
            'line_number': data.line_number,
            'column_number': data.column_number,
        }

    if casing_strategy == 'camel':
        return {
            'scriptId': data.script_id,
            'lineNumber': data.line_number,
            'columnNumber': data.column_number,
        }

    if casing_strategy == 'pascal':
        return {
            'ScriptId': data.script_id,
            'LineNumber': data.line_number,
            'ColumnNumber': data.column_number,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__script_position__to_dict(
        data: 'debugger.ScriptPosition',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'line_number': data.line_number,
            'column_number': data.column_number,
        }

    if casing_strategy == 'camel':
        return {
            'lineNumber': data.line_number,
            'columnNumber': data.column_number,
        }

    if casing_strategy == 'pascal':
        return {
            'LineNumber': data.line_number,
            'ColumnNumber': data.column_number,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__call_frame__to_dict(
        data: 'debugger.CallFrame',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'call_frame_id': data.call_frame_id,
            'function_name': data.function_name,
            'function_location': to_dict(
                data.function_location,
                casing_strategy
            ),
            'location': to_dict(
                data.location,
                casing_strategy
            ),
            'url': data.url,
            'scope_chain': [
                to_dict(item, casing_strategy)
                for item in data.scope_chain
            ],
            'this': to_dict(
                data.this,
                casing_strategy
            ),
            'return_value': to_dict(
                data.return_value,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'callFrameId': data.call_frame_id,
            'functionName': data.function_name,
            'functionLocation': to_dict(
                data.function_location,
                casing_strategy
            ),
            'location': to_dict(
                data.location,
                casing_strategy
            ),
            'url': data.url,
            'scopeChain': [
                to_dict(item, casing_strategy)
                for item in data.scope_chain
            ],
            'this': to_dict(
                data.this,
                casing_strategy
            ),
            'returnValue': to_dict(
                data.return_value,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'CallFrameId': data.call_frame_id,
            'FunctionName': data.function_name,
            'FunctionLocation': to_dict(
                data.function_location,
                casing_strategy
            ),
            'Location': to_dict(
                data.location,
                casing_strategy
            ),
            'Url': data.url,
            'ScopeChain': [
                to_dict(item, casing_strategy)
                for item in data.scope_chain
            ],
            'This': to_dict(
                data.this,
                casing_strategy
            ),
            'ReturnValue': to_dict(
                data.return_value,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__scope__to_dict(
        data: 'debugger.Scope',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'object': to_dict(
                data.object,
                casing_strategy
            ),
            'name': data.name,
            'start_location': to_dict(
                data.start_location,
                casing_strategy
            ),
            'end_location': to_dict(
                data.end_location,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'object': to_dict(
                data.object,
                casing_strategy
            ),
            'name': data.name,
            'startLocation': to_dict(
                data.start_location,
                casing_strategy
            ),
            'endLocation': to_dict(
                data.end_location,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'Object': to_dict(
                data.object,
                casing_strategy
            ),
            'Name': data.name,
            'StartLocation': to_dict(
                data.start_location,
                casing_strategy
            ),
            'EndLocation': to_dict(
                data.end_location,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__search_match__to_dict(
        data: 'debugger.SearchMatch',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'line_number': data.line_number,
            'line_content': data.line_content,
        }

    if casing_strategy == 'camel':
        return {
            'lineNumber': data.line_number,
            'lineContent': data.line_content,
        }

    if casing_strategy == 'pascal':
        return {
            'LineNumber': data.line_number,
            'LineContent': data.line_content,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__break_location__to_dict(
        data: 'debugger.BreakLocation',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'script_id': data.script_id,
            'line_number': data.line_number,
            'column_number': data.column_number,
            'type': data.type,
        }

    if casing_strategy == 'camel':
        return {
            'scriptId': data.script_id,
            'lineNumber': data.line_number,
            'columnNumber': data.column_number,
            'type': data.type,
        }

    if casing_strategy == 'pascal':
        return {
            'ScriptId': data.script_id,
            'LineNumber': data.line_number,
            'ColumnNumber': data.column_number,
            'Type': data.type,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _heap_profiler__sampling_heap_profile_node__to_dict(
        data: 'heap_profiler.SamplingHeapProfileNode',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'call_frame': to_dict(
                data.call_frame,
                casing_strategy
            ),
            'self_size': data.self_size,
            'id': data.id,
            'children': [
                to_dict(item, casing_strategy)
                for item in data.children
            ],
        }

    if casing_strategy == 'camel':
        return {
            'callFrame': to_dict(
                data.call_frame,
                casing_strategy
            ),
            'selfSize': data.self_size,
            'id': data.id,
            'children': [
                to_dict(item, casing_strategy)
                for item in data.children
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'CallFrame': to_dict(
                data.call_frame,
                casing_strategy
            ),
            'SelfSize': data.self_size,
            'Id': data.id,
            'Children': [
                to_dict(item, casing_strategy)
                for item in data.children
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _heap_profiler__sampling_heap_profile_sample__to_dict(
        data: 'heap_profiler.SamplingHeapProfileSample',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'size': data.size,
            'node_id': data.node_id,
            'ordinal': data.ordinal,
        }

    if casing_strategy == 'camel':
        return {
            'size': data.size,
            'nodeId': data.node_id,
            'ordinal': data.ordinal,
        }

    if casing_strategy == 'pascal':
        return {
            'Size': data.size,
            'NodeId': data.node_id,
            'Ordinal': data.ordinal,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _heap_profiler__sampling_heap_profile__to_dict(
        data: 'heap_profiler.SamplingHeapProfile',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'head': to_dict(
                data.head,
                casing_strategy
            ),
            'samples': [
                to_dict(item, casing_strategy)
                for item in data.samples
            ],
        }

    if casing_strategy == 'camel':
        return {
            'head': to_dict(
                data.head,
                casing_strategy
            ),
            'samples': [
                to_dict(item, casing_strategy)
                for item in data.samples
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Head': to_dict(
                data.head,
                casing_strategy
            ),
            'Samples': [
                to_dict(item, casing_strategy)
                for item in data.samples
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _profiler__profile_node__to_dict(
        data: 'profiler.ProfileNode',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'id': data.id,
            'call_frame': to_dict(
                data.call_frame,
                casing_strategy
            ),
            'hit_count': data.hit_count,
            'children': data.children,
            'deopt_reason': data.deopt_reason,
            'position_ticks': [
                to_dict(item, casing_strategy)
                for item in data.position_ticks
            ],
        }

    if casing_strategy == 'camel':
        return {
            'id': data.id,
            'callFrame': to_dict(
                data.call_frame,
                casing_strategy
            ),
            'hitCount': data.hit_count,
            'children': data.children,
            'deoptReason': data.deopt_reason,
            'positionTicks': [
                to_dict(item, casing_strategy)
                for item in data.position_ticks
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Id': data.id,
            'CallFrame': to_dict(
                data.call_frame,
                casing_strategy
            ),
            'HitCount': data.hit_count,
            'Children': data.children,
            'DeoptReason': data.deopt_reason,
            'PositionTicks': [
                to_dict(item, casing_strategy)
                for item in data.position_ticks
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _profiler__profile__to_dict(
        data: 'profiler.Profile',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'nodes': [
                to_dict(item, casing_strategy)
                for item in data.nodes
            ],
            'start_time': data.start_time,
            'end_time': data.end_time,
            'samples': data.samples,
            'time_deltas': data.time_deltas,
        }

    if casing_strategy == 'camel':
        return {
            'nodes': [
                to_dict(item, casing_strategy)
                for item in data.nodes
            ],
            'startTime': data.start_time,
            'endTime': data.end_time,
            'samples': data.samples,
            'timeDeltas': data.time_deltas,
        }

    if casing_strategy == 'pascal':
        return {
            'Nodes': [
                to_dict(item, casing_strategy)
                for item in data.nodes
            ],
            'StartTime': data.start_time,
            'EndTime': data.end_time,
            'Samples': data.samples,
            'TimeDeltas': data.time_deltas,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _profiler__position_tick_info__to_dict(
        data: 'profiler.PositionTickInfo',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'line': data.line,
            'ticks': data.ticks,
        }

    if casing_strategy == 'camel':
        return {
            'line': data.line,
            'ticks': data.ticks,
        }

    if casing_strategy == 'pascal':
        return {
            'Line': data.line,
            'Ticks': data.ticks,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _profiler__coverage_range__to_dict(
        data: 'profiler.CoverageRange',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'start_offset': data.start_offset,
            'end_offset': data.end_offset,
            'count': data.count,
        }

    if casing_strategy == 'camel':
        return {
            'startOffset': data.start_offset,
            'endOffset': data.end_offset,
            'count': data.count,
        }

    if casing_strategy == 'pascal':
        return {
            'StartOffset': data.start_offset,
            'EndOffset': data.end_offset,
            'Count': data.count,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _profiler__function_coverage__to_dict(
        data: 'profiler.FunctionCoverage',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'function_name': data.function_name,
            'ranges': [
                to_dict(item, casing_strategy)
                for item in data.ranges
            ],
            'is_block_coverage': data.is_block_coverage,
        }

    if casing_strategy == 'camel':
        return {
            'functionName': data.function_name,
            'ranges': [
                to_dict(item, casing_strategy)
                for item in data.ranges
            ],
            'isBlockCoverage': data.is_block_coverage,
        }

    if casing_strategy == 'pascal':
        return {
            'FunctionName': data.function_name,
            'Ranges': [
                to_dict(item, casing_strategy)
                for item in data.ranges
            ],
            'IsBlockCoverage': data.is_block_coverage,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _profiler__script_coverage__to_dict(
        data: 'profiler.ScriptCoverage',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'script_id': data.script_id,
            'url': data.url,
            'functions': [
                to_dict(item, casing_strategy)
                for item in data.functions
            ],
        }

    if casing_strategy == 'camel':
        return {
            'scriptId': data.script_id,
            'url': data.url,
            'functions': [
                to_dict(item, casing_strategy)
                for item in data.functions
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'ScriptId': data.script_id,
            'Url': data.url,
            'Functions': [
                to_dict(item, casing_strategy)
                for item in data.functions
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _profiler__type_object__to_dict(
        data: 'profiler.TypeObject',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _profiler__type_profile_entry__to_dict(
        data: 'profiler.TypeProfileEntry',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'offset': data.offset,
            'types': [
                to_dict(item, casing_strategy)
                for item in data.types
            ],
        }

    if casing_strategy == 'camel':
        return {
            'offset': data.offset,
            'types': [
                to_dict(item, casing_strategy)
                for item in data.types
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Offset': data.offset,
            'Types': [
                to_dict(item, casing_strategy)
                for item in data.types
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _profiler__script_type_profile__to_dict(
        data: 'profiler.ScriptTypeProfile',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'script_id': data.script_id,
            'url': data.url,
            'entries': [
                to_dict(item, casing_strategy)
                for item in data.entries
            ],
        }

    if casing_strategy == 'camel':
        return {
            'scriptId': data.script_id,
            'url': data.url,
            'entries': [
                to_dict(item, casing_strategy)
                for item in data.entries
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'ScriptId': data.script_id,
            'Url': data.url,
            'Entries': [
                to_dict(item, casing_strategy)
                for item in data.entries
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__remote_object__to_dict(
        data: 'runtime.RemoteObject',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'subtype': data.subtype,
            'class_name': data.class_name,
            'value': data.value,
            'unserializable_value': data.unserializable_value,
            'description': data.description,
            'object_id': data.object_id,
            'preview': to_dict(
                data.preview,
                casing_strategy
            ),
            'custom_preview': to_dict(
                data.custom_preview,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'subtype': data.subtype,
            'className': data.class_name,
            'value': data.value,
            'unserializableValue': data.unserializable_value,
            'description': data.description,
            'objectId': data.object_id,
            'preview': to_dict(
                data.preview,
                casing_strategy
            ),
            'customPreview': to_dict(
                data.custom_preview,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'Subtype': data.subtype,
            'ClassName': data.class_name,
            'Value': data.value,
            'UnserializableValue': data.unserializable_value,
            'Description': data.description,
            'ObjectId': data.object_id,
            'Preview': to_dict(
                data.preview,
                casing_strategy
            ),
            'CustomPreview': to_dict(
                data.custom_preview,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__custom_preview__to_dict(
        data: 'runtime.CustomPreview',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'header': data.header,
            'body_getter_id': data.body_getter_id,
        }

    if casing_strategy == 'camel':
        return {
            'header': data.header,
            'bodyGetterId': data.body_getter_id,
        }

    if casing_strategy == 'pascal':
        return {
            'Header': data.header,
            'BodyGetterId': data.body_getter_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__object_preview__to_dict(
        data: 'runtime.ObjectPreview',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'type': data.type,
            'subtype': data.subtype,
            'description': data.description,
            'overflow': data.overflow,
            'properties': [
                to_dict(item, casing_strategy)
                for item in data.properties
            ],
            'entries': [
                to_dict(item, casing_strategy)
                for item in data.entries
            ],
        }

    if casing_strategy == 'camel':
        return {
            'type': data.type,
            'subtype': data.subtype,
            'description': data.description,
            'overflow': data.overflow,
            'properties': [
                to_dict(item, casing_strategy)
                for item in data.properties
            ],
            'entries': [
                to_dict(item, casing_strategy)
                for item in data.entries
            ],
        }

    if casing_strategy == 'pascal':
        return {
            'Type': data.type,
            'Subtype': data.subtype,
            'Description': data.description,
            'Overflow': data.overflow,
            'Properties': [
                to_dict(item, casing_strategy)
                for item in data.properties
            ],
            'Entries': [
                to_dict(item, casing_strategy)
                for item in data.entries
            ],
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__property_preview__to_dict(
        data: 'runtime.PropertyPreview',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'type': data.type,
            'value': data.value,
            'value_preview': to_dict(
                data.value_preview,
                casing_strategy
            ),
            'subtype': data.subtype,
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'type': data.type,
            'value': data.value,
            'valuePreview': to_dict(
                data.value_preview,
                casing_strategy
            ),
            'subtype': data.subtype,
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Type': data.type,
            'Value': data.value,
            'ValuePreview': to_dict(
                data.value_preview,
                casing_strategy
            ),
            'Subtype': data.subtype,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__entry_preview__to_dict(
        data: 'runtime.EntryPreview',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'key': to_dict(
                data.key,
                casing_strategy
            ),
            'value': to_dict(
                data.value,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'key': to_dict(
                data.key,
                casing_strategy
            ),
            'value': to_dict(
                data.value,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'Key': to_dict(
                data.key,
                casing_strategy
            ),
            'Value': to_dict(
                data.value,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__property_descriptor__to_dict(
        data: 'runtime.PropertyDescriptor',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': to_dict(
                data.value,
                casing_strategy
            ),
            'writable': data.writable,
            'get': to_dict(
                data.get,
                casing_strategy
            ),
            'set': to_dict(
                data.set,
                casing_strategy
            ),
            'configurable': data.configurable,
            'enumerable': data.enumerable,
            'was_thrown': data.was_thrown,
            'is_own': data.is_own,
            'symbol': to_dict(
                data.symbol,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': to_dict(
                data.value,
                casing_strategy
            ),
            'writable': data.writable,
            'get': to_dict(
                data.get,
                casing_strategy
            ),
            'set': to_dict(
                data.set,
                casing_strategy
            ),
            'configurable': data.configurable,
            'enumerable': data.enumerable,
            'wasThrown': data.was_thrown,
            'isOwn': data.is_own,
            'symbol': to_dict(
                data.symbol,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': to_dict(
                data.value,
                casing_strategy
            ),
            'Writable': data.writable,
            'Get': to_dict(
                data.get,
                casing_strategy
            ),
            'Set': to_dict(
                data.set,
                casing_strategy
            ),
            'Configurable': data.configurable,
            'Enumerable': data.enumerable,
            'WasThrown': data.was_thrown,
            'IsOwn': data.is_own,
            'Symbol': to_dict(
                data.symbol,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__internal_property_descriptor__to_dict(
        data: 'runtime.InternalPropertyDescriptor',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': to_dict(
                data.value,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': to_dict(
                data.value,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': to_dict(
                data.value,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__private_property_descriptor__to_dict(
        data: 'runtime.PrivatePropertyDescriptor',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'value': to_dict(
                data.value,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'value': to_dict(
                data.value,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Value': to_dict(
                data.value,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__call_argument__to_dict(
        data: 'runtime.CallArgument',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'value': data.value,
            'unserializable_value': data.unserializable_value,
            'object_id': data.object_id,
        }

    if casing_strategy == 'camel':
        return {
            'value': data.value,
            'unserializableValue': data.unserializable_value,
            'objectId': data.object_id,
        }

    if casing_strategy == 'pascal':
        return {
            'Value': data.value,
            'UnserializableValue': data.unserializable_value,
            'ObjectId': data.object_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__execution_context_description__to_dict(
        data: 'runtime.ExecutionContextDescription',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'id': data.id,
            'origin': data.origin,
            'name': data.name,
            'aux_data': data.aux_data,
        }

    if casing_strategy == 'camel':
        return {
            'id': data.id,
            'origin': data.origin,
            'name': data.name,
            'auxData': data.aux_data,
        }

    if casing_strategy == 'pascal':
        return {
            'Id': data.id,
            'Origin': data.origin,
            'Name': data.name,
            'AuxData': data.aux_data,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__exception_details__to_dict(
        data: 'runtime.ExceptionDetails',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'exception_id': data.exception_id,
            'text': data.text,
            'line_number': data.line_number,
            'column_number': data.column_number,
            'script_id': data.script_id,
            'url': data.url,
            'stack_trace': to_dict(
                data.stack_trace,
                casing_strategy
            ),
            'exception': to_dict(
                data.exception,
                casing_strategy
            ),
            'execution_context_id': data.execution_context_id,
        }

    if casing_strategy == 'camel':
        return {
            'exceptionId': data.exception_id,
            'text': data.text,
            'lineNumber': data.line_number,
            'columnNumber': data.column_number,
            'scriptId': data.script_id,
            'url': data.url,
            'stackTrace': to_dict(
                data.stack_trace,
                casing_strategy
            ),
            'exception': to_dict(
                data.exception,
                casing_strategy
            ),
            'executionContextId': data.execution_context_id,
        }

    if casing_strategy == 'pascal':
        return {
            'ExceptionId': data.exception_id,
            'Text': data.text,
            'LineNumber': data.line_number,
            'ColumnNumber': data.column_number,
            'ScriptId': data.script_id,
            'Url': data.url,
            'StackTrace': to_dict(
                data.stack_trace,
                casing_strategy
            ),
            'Exception': to_dict(
                data.exception,
                casing_strategy
            ),
            'ExecutionContextId': data.execution_context_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__call_frame__to_dict(
        data: 'runtime.CallFrame',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'function_name': data.function_name,
            'script_id': data.script_id,
            'url': data.url,
            'line_number': data.line_number,
            'column_number': data.column_number,
        }

    if casing_strategy == 'camel':
        return {
            'functionName': data.function_name,
            'scriptId': data.script_id,
            'url': data.url,
            'lineNumber': data.line_number,
            'columnNumber': data.column_number,
        }

    if casing_strategy == 'pascal':
        return {
            'FunctionName': data.function_name,
            'ScriptId': data.script_id,
            'Url': data.url,
            'LineNumber': data.line_number,
            'ColumnNumber': data.column_number,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__stack_trace__to_dict(
        data: 'runtime.StackTrace',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'description': data.description,
            'call_frames': [
                to_dict(item, casing_strategy)
                for item in data.call_frames
            ],
            'parent': to_dict(
                data.parent,
                casing_strategy
            ),
            'parent_id': to_dict(
                data.parent_id,
                casing_strategy
            ),
        }

    if casing_strategy == 'camel':
        return {
            'description': data.description,
            'callFrames': [
                to_dict(item, casing_strategy)
                for item in data.call_frames
            ],
            'parent': to_dict(
                data.parent,
                casing_strategy
            ),
            'parentId': to_dict(
                data.parent_id,
                casing_strategy
            ),
        }

    if casing_strategy == 'pascal':
        return {
            'Description': data.description,
            'CallFrames': [
                to_dict(item, casing_strategy)
                for item in data.call_frames
            ],
            'Parent': to_dict(
                data.parent,
                casing_strategy
            ),
            'ParentId': to_dict(
                data.parent_id,
                casing_strategy
            ),
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__stack_trace_id__to_dict(
        data: 'runtime.StackTraceId',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'id': data.id,
            'debugger_id': data.debugger_id,
        }

    if casing_strategy == 'camel':
        return {
            'id': data.id,
            'debuggerId': data.debugger_id,
        }

    if casing_strategy == 'pascal':
        return {
            'Id': data.id,
            'DebuggerId': data.debugger_id,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _schema__domain__to_dict(
        data: 'schema.Domain',
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> dict:

    if casing_strategy == 'snake':
        return {
            'name': data.name,
            'version': data.version,
        }

    if casing_strategy == 'camel':
        return {
            'name': data.name,
            'version': data.version,
        }

    if casing_strategy == 'pascal':
        return {
            'Name': data.name,
            'Version': data.version,
        }

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _accessibility__ax_value_source__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'accessibility.AXValueSource':

    if casing_strategy == 'snake':
        return accessibility.AXValueSource(
            type=data['type'],
            value=from_dict(
                accessibility.AXValue,
                data.get('value', None),
                casing_strategy
            ),
            attribute=data.get('attribute', None),
            attribute_value=from_dict(
                accessibility.AXValue,
                data.get('attribute_value', None),
                casing_strategy
            ),
            superseded=data.get('superseded', None),
            native_source=data.get('native_source', None),
            native_source_value=from_dict(
                accessibility.AXValue,
                data.get('native_source_value', None),
                casing_strategy
            ),
            invalid=data.get('invalid', None),
            invalid_reason=data.get('invalid_reason', None)
        )

    if casing_strategy == 'camel':
        return accessibility.AXValueSource(
            type=data['type'],
            value=from_dict(
                accessibility.AXValue,
                data.get('value', None),
                casing_strategy
            ),
            attribute=data.get('attribute', None),
            attribute_value=from_dict(
                accessibility.AXValue,
                data.get('attributeValue', None),
                casing_strategy
            ),
            superseded=data.get('superseded', None),
            native_source=data.get('nativeSource', None),
            native_source_value=from_dict(
                accessibility.AXValue,
                data.get('nativeSourceValue', None),
                casing_strategy
            ),
            invalid=data.get('invalid', None),
            invalid_reason=data.get('invalidReason', None)
        )

    if casing_strategy == 'pascal':
        return accessibility.AXValueSource(
            type=data['Type'],
            value=from_dict(
                accessibility.AXValue,
                data.get('Value', None),
                casing_strategy
            ),
            attribute=data.get('Attribute', None),
            attribute_value=from_dict(
                accessibility.AXValue,
                data.get('AttributeValue', None),
                casing_strategy
            ),
            superseded=data.get('Superseded', None),
            native_source=data.get('NativeSource', None),
            native_source_value=from_dict(
                accessibility.AXValue,
                data.get('NativeSourceValue', None),
                casing_strategy
            ),
            invalid=data.get('Invalid', None),
            invalid_reason=data.get('InvalidReason', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _accessibility__ax_related_node__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'accessibility.AXRelatedNode':

    if casing_strategy == 'snake':
        return accessibility.AXRelatedNode(
            backend_dom_node_id=data['backend_dom_node_id'],
            idref=data.get('idref', None),
            text=data.get('text', None)
        )

    if casing_strategy == 'camel':
        return accessibility.AXRelatedNode(
            backend_dom_node_id=data['backendDOMNodeId'],
            idref=data.get('idref', None),
            text=data.get('text', None)
        )

    if casing_strategy == 'pascal':
        return accessibility.AXRelatedNode(
            backend_dom_node_id=data['BackendDOMNodeId'],
            idref=data.get('Idref', None),
            text=data.get('Text', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _accessibility__ax_property__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'accessibility.AXProperty':

    if casing_strategy == 'snake':
        return accessibility.AXProperty(
            name=data['name'],
            value=from_dict(
                accessibility.AXValue,
                data['value'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return accessibility.AXProperty(
            name=data['name'],
            value=from_dict(
                accessibility.AXValue,
                data['value'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return accessibility.AXProperty(
            name=data['Name'],
            value=from_dict(
                accessibility.AXValue,
                data['Value'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _accessibility__ax_value__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'accessibility.AXValue':

    if casing_strategy == 'snake':
        return accessibility.AXValue(
            type=data['type'],
            value=data.get('value', None),
            related_nodes=[
                from_dict(accessibility.AXRelatedNode, item, casing_strategy)
                for item in data.get('related_nodes', [])
            ],
            sources=[
                from_dict(accessibility.AXValueSource, item, casing_strategy)
                for item in data.get('sources', [])
            ]
        )

    if casing_strategy == 'camel':
        return accessibility.AXValue(
            type=data['type'],
            value=data.get('value', None),
            related_nodes=[
                from_dict(accessibility.AXRelatedNode, item, casing_strategy)
                for item in data.get('relatedNodes', [])
            ],
            sources=[
                from_dict(accessibility.AXValueSource, item, casing_strategy)
                for item in data.get('sources', [])
            ]
        )

    if casing_strategy == 'pascal':
        return accessibility.AXValue(
            type=data['Type'],
            value=data.get('Value', None),
            related_nodes=[
                from_dict(accessibility.AXRelatedNode, item, casing_strategy)
                for item in data.get('RelatedNodes', [])
            ],
            sources=[
                from_dict(accessibility.AXValueSource, item, casing_strategy)
                for item in data.get('Sources', [])
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _accessibility__ax_node__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'accessibility.AXNode':

    if casing_strategy == 'snake':
        return accessibility.AXNode(
            node_id=data['node_id'],
            ignored=data['ignored'],
            ignored_reasons=[
                from_dict(accessibility.AXProperty, item, casing_strategy)
                for item in data.get('ignored_reasons', [])
            ],
            role=from_dict(
                accessibility.AXValue,
                data.get('role', None),
                casing_strategy
            ),
            chrome_role=from_dict(
                accessibility.AXValue,
                data.get('chrome_role', None),
                casing_strategy
            ),
            name=from_dict(
                accessibility.AXValue,
                data.get('name', None),
                casing_strategy
            ),
            description=from_dict(
                accessibility.AXValue,
                data.get('description', None),
                casing_strategy
            ),
            value=from_dict(
                accessibility.AXValue,
                data.get('value', None),
                casing_strategy
            ),
            properties=[
                from_dict(accessibility.AXProperty, item, casing_strategy)
                for item in data.get('properties', [])
            ],
            parent_id=data.get('parent_id', None),
            child_ids=data.get('child_ids', []),
            backend_dom_node_id=data.get('backend_dom_node_id', None),
            frame_id=data.get('frame_id', None)
        )

    if casing_strategy == 'camel':
        return accessibility.AXNode(
            node_id=data['nodeId'],
            ignored=data['ignored'],
            ignored_reasons=[
                from_dict(accessibility.AXProperty, item, casing_strategy)
                for item in data.get('ignoredReasons', [])
            ],
            role=from_dict(
                accessibility.AXValue,
                data.get('role', None),
                casing_strategy
            ),
            chrome_role=from_dict(
                accessibility.AXValue,
                data.get('chromeRole', None),
                casing_strategy
            ),
            name=from_dict(
                accessibility.AXValue,
                data.get('name', None),
                casing_strategy
            ),
            description=from_dict(
                accessibility.AXValue,
                data.get('description', None),
                casing_strategy
            ),
            value=from_dict(
                accessibility.AXValue,
                data.get('value', None),
                casing_strategy
            ),
            properties=[
                from_dict(accessibility.AXProperty, item, casing_strategy)
                for item in data.get('properties', [])
            ],
            parent_id=data.get('parentId', None),
            child_ids=data.get('childIds', []),
            backend_dom_node_id=data.get('backendDOMNodeId', None),
            frame_id=data.get('frameId', None)
        )

    if casing_strategy == 'pascal':
        return accessibility.AXNode(
            node_id=data['NodeId'],
            ignored=data['Ignored'],
            ignored_reasons=[
                from_dict(accessibility.AXProperty, item, casing_strategy)
                for item in data.get('IgnoredReasons', [])
            ],
            role=from_dict(
                accessibility.AXValue,
                data.get('Role', None),
                casing_strategy
            ),
            chrome_role=from_dict(
                accessibility.AXValue,
                data.get('ChromeRole', None),
                casing_strategy
            ),
            name=from_dict(
                accessibility.AXValue,
                data.get('Name', None),
                casing_strategy
            ),
            description=from_dict(
                accessibility.AXValue,
                data.get('Description', None),
                casing_strategy
            ),
            value=from_dict(
                accessibility.AXValue,
                data.get('Value', None),
                casing_strategy
            ),
            properties=[
                from_dict(accessibility.AXProperty, item, casing_strategy)
                for item in data.get('Properties', [])
            ],
            parent_id=data.get('ParentId', None),
            child_ids=data.get('ChildIds', []),
            backend_dom_node_id=data.get('BackendDOMNodeId', None),
            frame_id=data.get('FrameId', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _animation__animation__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'animation.Animation':

    if casing_strategy == 'snake':
        return animation.Animation(
            id=data['id'],
            name=data['name'],
            paused_state=data['paused_state'],
            play_state=data['play_state'],
            playback_rate=data['playback_rate'],
            start_time=data['start_time'],
            current_time=data['current_time'],
            type=data['type'],
            source=from_dict(
                animation.AnimationEffect,
                data.get('source', None),
                casing_strategy
            ),
            css_id=data.get('css_id', None)
        )

    if casing_strategy == 'camel':
        return animation.Animation(
            id=data['id'],
            name=data['name'],
            paused_state=data['pausedState'],
            play_state=data['playState'],
            playback_rate=data['playbackRate'],
            start_time=data['startTime'],
            current_time=data['currentTime'],
            type=data['type'],
            source=from_dict(
                animation.AnimationEffect,
                data.get('source', None),
                casing_strategy
            ),
            css_id=data.get('cssId', None)
        )

    if casing_strategy == 'pascal':
        return animation.Animation(
            id=data['Id'],
            name=data['Name'],
            paused_state=data['PausedState'],
            play_state=data['PlayState'],
            playback_rate=data['PlaybackRate'],
            start_time=data['StartTime'],
            current_time=data['CurrentTime'],
            type=data['Type'],
            source=from_dict(
                animation.AnimationEffect,
                data.get('Source', None),
                casing_strategy
            ),
            css_id=data.get('CssId', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _animation__animation_effect__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'animation.AnimationEffect':

    if casing_strategy == 'snake':
        return animation.AnimationEffect(
            delay=data['delay'],
            end_delay=data['end_delay'],
            iteration_start=data['iteration_start'],
            iterations=data['iterations'],
            duration=data['duration'],
            direction=data['direction'],
            fill=data['fill'],
            backend_node_id=data.get('backend_node_id', None),
            keyframes_rule=from_dict(
                animation.KeyframesRule,
                data.get('keyframes_rule', None),
                casing_strategy
            ),
            easing=data['easing']
        )

    if casing_strategy == 'camel':
        return animation.AnimationEffect(
            delay=data['delay'],
            end_delay=data['endDelay'],
            iteration_start=data['iterationStart'],
            iterations=data['iterations'],
            duration=data['duration'],
            direction=data['direction'],
            fill=data['fill'],
            backend_node_id=data.get('backendNodeId', None),
            keyframes_rule=from_dict(
                animation.KeyframesRule,
                data.get('keyframesRule', None),
                casing_strategy
            ),
            easing=data['easing']
        )

    if casing_strategy == 'pascal':
        return animation.AnimationEffect(
            delay=data['Delay'],
            end_delay=data['EndDelay'],
            iteration_start=data['IterationStart'],
            iterations=data['Iterations'],
            duration=data['Duration'],
            direction=data['Direction'],
            fill=data['Fill'],
            backend_node_id=data.get('BackendNodeId', None),
            keyframes_rule=from_dict(
                animation.KeyframesRule,
                data.get('KeyframesRule', None),
                casing_strategy
            ),
            easing=data['Easing']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _animation__keyframes_rule__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'animation.KeyframesRule':

    if casing_strategy == 'snake':
        return animation.KeyframesRule(
            name=data.get('name', None),
            keyframes=[
                from_dict(animation.KeyframeStyle, item, casing_strategy)
                for item in data['keyframes']
            ]
        )

    if casing_strategy == 'camel':
        return animation.KeyframesRule(
            name=data.get('name', None),
            keyframes=[
                from_dict(animation.KeyframeStyle, item, casing_strategy)
                for item in data['keyframes']
            ]
        )

    if casing_strategy == 'pascal':
        return animation.KeyframesRule(
            name=data.get('Name', None),
            keyframes=[
                from_dict(animation.KeyframeStyle, item, casing_strategy)
                for item in data['Keyframes']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _animation__keyframe_style__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'animation.KeyframeStyle':

    if casing_strategy == 'snake':
        return animation.KeyframeStyle(
            offset=data['offset'],
            easing=data['easing']
        )

    if casing_strategy == 'camel':
        return animation.KeyframeStyle(
            offset=data['offset'],
            easing=data['easing']
        )

    if casing_strategy == 'pascal':
        return animation.KeyframeStyle(
            offset=data['Offset'],
            easing=data['Easing']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__affected_cookie__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.AffectedCookie':

    if casing_strategy == 'snake':
        return audits.AffectedCookie(
            name=data['name'],
            path=data['path'],
            domain=data['domain']
        )

    if casing_strategy == 'camel':
        return audits.AffectedCookie(
            name=data['name'],
            path=data['path'],
            domain=data['domain']
        )

    if casing_strategy == 'pascal':
        return audits.AffectedCookie(
            name=data['Name'],
            path=data['Path'],
            domain=data['Domain']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__affected_request__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.AffectedRequest':

    if casing_strategy == 'snake':
        return audits.AffectedRequest(
            request_id=data['request_id'],
            url=data.get('url', None)
        )

    if casing_strategy == 'camel':
        return audits.AffectedRequest(
            request_id=data['requestId'],
            url=data.get('url', None)
        )

    if casing_strategy == 'pascal':
        return audits.AffectedRequest(
            request_id=data['RequestId'],
            url=data.get('Url', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__affected_frame__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.AffectedFrame':

    if casing_strategy == 'snake':
        return audits.AffectedFrame(
            frame_id=data['frame_id']
        )

    if casing_strategy == 'camel':
        return audits.AffectedFrame(
            frame_id=data['frameId']
        )

    if casing_strategy == 'pascal':
        return audits.AffectedFrame(
            frame_id=data['FrameId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__cookie_issue_details__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.CookieIssueDetails':

    if casing_strategy == 'snake':
        return audits.CookieIssueDetails(
            cookie=from_dict(
                audits.AffectedCookie,
                data.get('cookie', None),
                casing_strategy
            ),
            raw_cookie_line=data.get('raw_cookie_line', None),
            cookie_warning_reasons=data['cookie_warning_reasons'],
            cookie_exclusion_reasons=data['cookie_exclusion_reasons'],
            operation=data['operation'],
            site_for_cookies=data.get('site_for_cookies', None),
            cookie_url=data.get('cookie_url', None),
            request=from_dict(
                audits.AffectedRequest,
                data.get('request', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return audits.CookieIssueDetails(
            cookie=from_dict(
                audits.AffectedCookie,
                data.get('cookie', None),
                casing_strategy
            ),
            raw_cookie_line=data.get('rawCookieLine', None),
            cookie_warning_reasons=data['cookieWarningReasons'],
            cookie_exclusion_reasons=data['cookieExclusionReasons'],
            operation=data['operation'],
            site_for_cookies=data.get('siteForCookies', None),
            cookie_url=data.get('cookieUrl', None),
            request=from_dict(
                audits.AffectedRequest,
                data.get('request', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return audits.CookieIssueDetails(
            cookie=from_dict(
                audits.AffectedCookie,
                data.get('Cookie', None),
                casing_strategy
            ),
            raw_cookie_line=data.get('RawCookieLine', None),
            cookie_warning_reasons=data['CookieWarningReasons'],
            cookie_exclusion_reasons=data['CookieExclusionReasons'],
            operation=data['Operation'],
            site_for_cookies=data.get('SiteForCookies', None),
            cookie_url=data.get('CookieUrl', None),
            request=from_dict(
                audits.AffectedRequest,
                data.get('Request', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__mixed_content_issue_details__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.MixedContentIssueDetails':

    if casing_strategy == 'snake':
        return audits.MixedContentIssueDetails(
            resource_type=data.get('resource_type', None),
            resolution_status=data['resolution_status'],
            insecure_url=data['insecure_url'],
            main_resource_url=data['main_resource_url'],
            request=from_dict(
                audits.AffectedRequest,
                data.get('request', None),
                casing_strategy
            ),
            frame=from_dict(
                audits.AffectedFrame,
                data.get('frame', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return audits.MixedContentIssueDetails(
            resource_type=data.get('resourceType', None),
            resolution_status=data['resolutionStatus'],
            insecure_url=data['insecureURL'],
            main_resource_url=data['mainResourceURL'],
            request=from_dict(
                audits.AffectedRequest,
                data.get('request', None),
                casing_strategy
            ),
            frame=from_dict(
                audits.AffectedFrame,
                data.get('frame', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return audits.MixedContentIssueDetails(
            resource_type=data.get('ResourceType', None),
            resolution_status=data['ResolutionStatus'],
            insecure_url=data['InsecureURL'],
            main_resource_url=data['MainResourceURL'],
            request=from_dict(
                audits.AffectedRequest,
                data.get('Request', None),
                casing_strategy
            ),
            frame=from_dict(
                audits.AffectedFrame,
                data.get('Frame', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__blocked_by_response_issue_details__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.BlockedByResponseIssueDetails':

    if casing_strategy == 'snake':
        return audits.BlockedByResponseIssueDetails(
            request=from_dict(
                audits.AffectedRequest,
                data['request'],
                casing_strategy
            ),
            parent_frame=from_dict(
                audits.AffectedFrame,
                data.get('parent_frame', None),
                casing_strategy
            ),
            blocked_frame=from_dict(
                audits.AffectedFrame,
                data.get('blocked_frame', None),
                casing_strategy
            ),
            reason=data['reason']
        )

    if casing_strategy == 'camel':
        return audits.BlockedByResponseIssueDetails(
            request=from_dict(
                audits.AffectedRequest,
                data['request'],
                casing_strategy
            ),
            parent_frame=from_dict(
                audits.AffectedFrame,
                data.get('parentFrame', None),
                casing_strategy
            ),
            blocked_frame=from_dict(
                audits.AffectedFrame,
                data.get('blockedFrame', None),
                casing_strategy
            ),
            reason=data['reason']
        )

    if casing_strategy == 'pascal':
        return audits.BlockedByResponseIssueDetails(
            request=from_dict(
                audits.AffectedRequest,
                data['Request'],
                casing_strategy
            ),
            parent_frame=from_dict(
                audits.AffectedFrame,
                data.get('ParentFrame', None),
                casing_strategy
            ),
            blocked_frame=from_dict(
                audits.AffectedFrame,
                data.get('BlockedFrame', None),
                casing_strategy
            ),
            reason=data['Reason']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__heavy_ad_issue_details__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.HeavyAdIssueDetails':

    if casing_strategy == 'snake':
        return audits.HeavyAdIssueDetails(
            resolution=data['resolution'],
            reason=data['reason'],
            frame=from_dict(
                audits.AffectedFrame,
                data['frame'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return audits.HeavyAdIssueDetails(
            resolution=data['resolution'],
            reason=data['reason'],
            frame=from_dict(
                audits.AffectedFrame,
                data['frame'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return audits.HeavyAdIssueDetails(
            resolution=data['Resolution'],
            reason=data['Reason'],
            frame=from_dict(
                audits.AffectedFrame,
                data['Frame'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__source_code_location__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.SourceCodeLocation':

    if casing_strategy == 'snake':
        return audits.SourceCodeLocation(
            script_id=data.get('script_id', None),
            url=data['url'],
            line_number=data['line_number'],
            column_number=data['column_number']
        )

    if casing_strategy == 'camel':
        return audits.SourceCodeLocation(
            script_id=data.get('scriptId', None),
            url=data['url'],
            line_number=data['lineNumber'],
            column_number=data['columnNumber']
        )

    if casing_strategy == 'pascal':
        return audits.SourceCodeLocation(
            script_id=data.get('ScriptId', None),
            url=data['Url'],
            line_number=data['LineNumber'],
            column_number=data['ColumnNumber']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__content_security_policy_issue_details__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.ContentSecurityPolicyIssueDetails':

    if casing_strategy == 'snake':
        return audits.ContentSecurityPolicyIssueDetails(
            blocked_url=data.get('blocked_url', None),
            violated_directive=data['violated_directive'],
            is_report_only=data['is_report_only'],
            content_security_policy_violation_type=data['content_security_policy_violation_type'],
            frame_ancestor=from_dict(
                audits.AffectedFrame,
                data.get('frame_ancestor', None),
                casing_strategy
            ),
            source_code_location=from_dict(
                audits.SourceCodeLocation,
                data.get('source_code_location', None),
                casing_strategy
            ),
            violating_node_id=data.get('violating_node_id', None)
        )

    if casing_strategy == 'camel':
        return audits.ContentSecurityPolicyIssueDetails(
            blocked_url=data.get('blockedURL', None),
            violated_directive=data['violatedDirective'],
            is_report_only=data['isReportOnly'],
            content_security_policy_violation_type=data['contentSecurityPolicyViolationType'],
            frame_ancestor=from_dict(
                audits.AffectedFrame,
                data.get('frameAncestor', None),
                casing_strategy
            ),
            source_code_location=from_dict(
                audits.SourceCodeLocation,
                data.get('sourceCodeLocation', None),
                casing_strategy
            ),
            violating_node_id=data.get('violatingNodeId', None)
        )

    if casing_strategy == 'pascal':
        return audits.ContentSecurityPolicyIssueDetails(
            blocked_url=data.get('BlockedURL', None),
            violated_directive=data['ViolatedDirective'],
            is_report_only=data['IsReportOnly'],
            content_security_policy_violation_type=data['ContentSecurityPolicyViolationType'],
            frame_ancestor=from_dict(
                audits.AffectedFrame,
                data.get('FrameAncestor', None),
                casing_strategy
            ),
            source_code_location=from_dict(
                audits.SourceCodeLocation,
                data.get('SourceCodeLocation', None),
                casing_strategy
            ),
            violating_node_id=data.get('ViolatingNodeId', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__shared_array_buffer_issue_details__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.SharedArrayBufferIssueDetails':

    if casing_strategy == 'snake':
        return audits.SharedArrayBufferIssueDetails(
            source_code_location=from_dict(
                audits.SourceCodeLocation,
                data['source_code_location'],
                casing_strategy
            ),
            is_warning=data['is_warning'],
            type=data['type']
        )

    if casing_strategy == 'camel':
        return audits.SharedArrayBufferIssueDetails(
            source_code_location=from_dict(
                audits.SourceCodeLocation,
                data['sourceCodeLocation'],
                casing_strategy
            ),
            is_warning=data['isWarning'],
            type=data['type']
        )

    if casing_strategy == 'pascal':
        return audits.SharedArrayBufferIssueDetails(
            source_code_location=from_dict(
                audits.SourceCodeLocation,
                data['SourceCodeLocation'],
                casing_strategy
            ),
            is_warning=data['IsWarning'],
            type=data['Type']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__low_text_contrast_issue_details__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.LowTextContrastIssueDetails':

    if casing_strategy == 'snake':
        return audits.LowTextContrastIssueDetails(
            violating_node_id=data['violating_node_id'],
            violating_node_selector=data['violating_node_selector'],
            contrast_ratio=data['contrast_ratio'],
            threshold_aa=data['threshold_aa'],
            threshold_aaa=data['threshold_aaa'],
            font_size=data['font_size'],
            font_weight=data['font_weight']
        )

    if casing_strategy == 'camel':
        return audits.LowTextContrastIssueDetails(
            violating_node_id=data['violatingNodeId'],
            violating_node_selector=data['violatingNodeSelector'],
            contrast_ratio=data['contrastRatio'],
            threshold_aa=data['thresholdAA'],
            threshold_aaa=data['thresholdAAA'],
            font_size=data['fontSize'],
            font_weight=data['fontWeight']
        )

    if casing_strategy == 'pascal':
        return audits.LowTextContrastIssueDetails(
            violating_node_id=data['ViolatingNodeId'],
            violating_node_selector=data['ViolatingNodeSelector'],
            contrast_ratio=data['ContrastRatio'],
            threshold_aa=data['ThresholdAA'],
            threshold_aaa=data['ThresholdAAA'],
            font_size=data['FontSize'],
            font_weight=data['FontWeight']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__cors_issue_details__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.CorsIssueDetails':

    if casing_strategy == 'snake':
        return audits.CorsIssueDetails(
            cors_error_status=from_dict(
                audits.CorsErrorStatus,
                data['cors_error_status'],
                casing_strategy
            ),
            is_warning=data['is_warning'],
            request=from_dict(
                audits.AffectedRequest,
                data['request'],
                casing_strategy
            ),
            location=from_dict(
                audits.SourceCodeLocation,
                data.get('location', None),
                casing_strategy
            ),
            initiator_origin=data.get('initiator_origin', None),
            resource_ip_address_space=data.get('resource_ip_address_space', None),
            client_security_state=from_dict(
                audits.ClientSecurityState,
                data.get('client_security_state', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return audits.CorsIssueDetails(
            cors_error_status=from_dict(
                audits.CorsErrorStatus,
                data['corsErrorStatus'],
                casing_strategy
            ),
            is_warning=data['isWarning'],
            request=from_dict(
                audits.AffectedRequest,
                data['request'],
                casing_strategy
            ),
            location=from_dict(
                audits.SourceCodeLocation,
                data.get('location', None),
                casing_strategy
            ),
            initiator_origin=data.get('initiatorOrigin', None),
            resource_ip_address_space=data.get('resourceIPAddressSpace', None),
            client_security_state=from_dict(
                audits.ClientSecurityState,
                data.get('clientSecurityState', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return audits.CorsIssueDetails(
            cors_error_status=from_dict(
                audits.CorsErrorStatus,
                data['CorsErrorStatus'],
                casing_strategy
            ),
            is_warning=data['IsWarning'],
            request=from_dict(
                audits.AffectedRequest,
                data['Request'],
                casing_strategy
            ),
            location=from_dict(
                audits.SourceCodeLocation,
                data.get('Location', None),
                casing_strategy
            ),
            initiator_origin=data.get('InitiatorOrigin', None),
            resource_ip_address_space=data.get('ResourceIPAddressSpace', None),
            client_security_state=from_dict(
                audits.ClientSecurityState,
                data.get('ClientSecurityState', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__attribution_reporting_issue_details__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.AttributionReportingIssueDetails':

    if casing_strategy == 'snake':
        return audits.AttributionReportingIssueDetails(
            violation_type=data['violation_type'],
            request=from_dict(
                audits.AffectedRequest,
                data.get('request', None),
                casing_strategy
            ),
            violating_node_id=data.get('violating_node_id', None),
            invalid_parameter=data.get('invalid_parameter', None)
        )

    if casing_strategy == 'camel':
        return audits.AttributionReportingIssueDetails(
            violation_type=data['violationType'],
            request=from_dict(
                audits.AffectedRequest,
                data.get('request', None),
                casing_strategy
            ),
            violating_node_id=data.get('violatingNodeId', None),
            invalid_parameter=data.get('invalidParameter', None)
        )

    if casing_strategy == 'pascal':
        return audits.AttributionReportingIssueDetails(
            violation_type=data['ViolationType'],
            request=from_dict(
                audits.AffectedRequest,
                data.get('Request', None),
                casing_strategy
            ),
            violating_node_id=data.get('ViolatingNodeId', None),
            invalid_parameter=data.get('InvalidParameter', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__quirks_mode_issue_details__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.QuirksModeIssueDetails':

    if casing_strategy == 'snake':
        return audits.QuirksModeIssueDetails(
            is_limited_quirks_mode=data['is_limited_quirks_mode'],
            document_node_id=data['document_node_id'],
            url=data['url'],
            frame_id=data['frame_id'],
            loader_id=data['loader_id']
        )

    if casing_strategy == 'camel':
        return audits.QuirksModeIssueDetails(
            is_limited_quirks_mode=data['isLimitedQuirksMode'],
            document_node_id=data['documentNodeId'],
            url=data['url'],
            frame_id=data['frameId'],
            loader_id=data['loaderId']
        )

    if casing_strategy == 'pascal':
        return audits.QuirksModeIssueDetails(
            is_limited_quirks_mode=data['IsLimitedQuirksMode'],
            document_node_id=data['DocumentNodeId'],
            url=data['Url'],
            frame_id=data['FrameId'],
            loader_id=data['LoaderId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__navigator_user_agent_issue_details__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.NavigatorUserAgentIssueDetails':

    if casing_strategy == 'snake':
        return audits.NavigatorUserAgentIssueDetails(
            url=data['url'],
            location=from_dict(
                audits.SourceCodeLocation,
                data.get('location', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return audits.NavigatorUserAgentIssueDetails(
            url=data['url'],
            location=from_dict(
                audits.SourceCodeLocation,
                data.get('location', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return audits.NavigatorUserAgentIssueDetails(
            url=data['Url'],
            location=from_dict(
                audits.SourceCodeLocation,
                data.get('Location', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__generic_issue_details__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.GenericIssueDetails':

    if casing_strategy == 'snake':
        return audits.GenericIssueDetails(
            error_type=data['error_type'],
            frame_id=data.get('frame_id', None),
            violating_node_id=data.get('violating_node_id', None),
            violating_node_attribute=data.get('violating_node_attribute', None),
            request=from_dict(
                audits.AffectedRequest,
                data.get('request', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return audits.GenericIssueDetails(
            error_type=data['errorType'],
            frame_id=data.get('frameId', None),
            violating_node_id=data.get('violatingNodeId', None),
            violating_node_attribute=data.get('violatingNodeAttribute', None),
            request=from_dict(
                audits.AffectedRequest,
                data.get('request', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return audits.GenericIssueDetails(
            error_type=data['ErrorType'],
            frame_id=data.get('FrameId', None),
            violating_node_id=data.get('ViolatingNodeId', None),
            violating_node_attribute=data.get('ViolatingNodeAttribute', None),
            request=from_dict(
                audits.AffectedRequest,
                data.get('Request', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__deprecation_issue_details__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.DeprecationIssueDetails':

    if casing_strategy == 'snake':
        return audits.DeprecationIssueDetails(
            affected_frame=from_dict(
                audits.AffectedFrame,
                data.get('affected_frame', None),
                casing_strategy
            ),
            source_code_location=from_dict(
                audits.SourceCodeLocation,
                data['source_code_location'],
                casing_strategy
            ),
            type=data['type']
        )

    if casing_strategy == 'camel':
        return audits.DeprecationIssueDetails(
            affected_frame=from_dict(
                audits.AffectedFrame,
                data.get('affectedFrame', None),
                casing_strategy
            ),
            source_code_location=from_dict(
                audits.SourceCodeLocation,
                data['sourceCodeLocation'],
                casing_strategy
            ),
            type=data['type']
        )

    if casing_strategy == 'pascal':
        return audits.DeprecationIssueDetails(
            affected_frame=from_dict(
                audits.AffectedFrame,
                data.get('AffectedFrame', None),
                casing_strategy
            ),
            source_code_location=from_dict(
                audits.SourceCodeLocation,
                data['SourceCodeLocation'],
                casing_strategy
            ),
            type=data['Type']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__bounce_tracking_issue_details__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.BounceTrackingIssueDetails':

    if casing_strategy == 'snake':
        return audits.BounceTrackingIssueDetails(
            tracking_sites=data['tracking_sites']
        )

    if casing_strategy == 'camel':
        return audits.BounceTrackingIssueDetails(
            tracking_sites=data['trackingSites']
        )

    if casing_strategy == 'pascal':
        return audits.BounceTrackingIssueDetails(
            tracking_sites=data['TrackingSites']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__federated_auth_request_issue_details__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.FederatedAuthRequestIssueDetails':

    if casing_strategy == 'snake':
        return audits.FederatedAuthRequestIssueDetails(
            federated_auth_request_issue_reason=data['federated_auth_request_issue_reason']
        )

    if casing_strategy == 'camel':
        return audits.FederatedAuthRequestIssueDetails(
            federated_auth_request_issue_reason=data['federatedAuthRequestIssueReason']
        )

    if casing_strategy == 'pascal':
        return audits.FederatedAuthRequestIssueDetails(
            federated_auth_request_issue_reason=data['FederatedAuthRequestIssueReason']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__federated_auth_user_info_request_issue_details__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.FederatedAuthUserInfoRequestIssueDetails':

    if casing_strategy == 'snake':
        return audits.FederatedAuthUserInfoRequestIssueDetails(
            federated_auth_user_info_request_issue_reason=data['federated_auth_user_info_request_issue_reason']
        )

    if casing_strategy == 'camel':
        return audits.FederatedAuthUserInfoRequestIssueDetails(
            federated_auth_user_info_request_issue_reason=data['federatedAuthUserInfoRequestIssueReason']
        )

    if casing_strategy == 'pascal':
        return audits.FederatedAuthUserInfoRequestIssueDetails(
            federated_auth_user_info_request_issue_reason=data['FederatedAuthUserInfoRequestIssueReason']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__client_hint_issue_details__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.ClientHintIssueDetails':

    if casing_strategy == 'snake':
        return audits.ClientHintIssueDetails(
            source_code_location=from_dict(
                audits.SourceCodeLocation,
                data['source_code_location'],
                casing_strategy
            ),
            client_hint_issue_reason=data['client_hint_issue_reason']
        )

    if casing_strategy == 'camel':
        return audits.ClientHintIssueDetails(
            source_code_location=from_dict(
                audits.SourceCodeLocation,
                data['sourceCodeLocation'],
                casing_strategy
            ),
            client_hint_issue_reason=data['clientHintIssueReason']
        )

    if casing_strategy == 'pascal':
        return audits.ClientHintIssueDetails(
            source_code_location=from_dict(
                audits.SourceCodeLocation,
                data['SourceCodeLocation'],
                casing_strategy
            ),
            client_hint_issue_reason=data['ClientHintIssueReason']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__failed_request_info__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.FailedRequestInfo':

    if casing_strategy == 'snake':
        return audits.FailedRequestInfo(
            url=data['url'],
            failure_message=data['failure_message'],
            request_id=data.get('request_id', None)
        )

    if casing_strategy == 'camel':
        return audits.FailedRequestInfo(
            url=data['url'],
            failure_message=data['failureMessage'],
            request_id=data.get('requestId', None)
        )

    if casing_strategy == 'pascal':
        return audits.FailedRequestInfo(
            url=data['Url'],
            failure_message=data['FailureMessage'],
            request_id=data.get('RequestId', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__stylesheet_loading_issue_details__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.StylesheetLoadingIssueDetails':

    if casing_strategy == 'snake':
        return audits.StylesheetLoadingIssueDetails(
            source_code_location=from_dict(
                audits.SourceCodeLocation,
                data['source_code_location'],
                casing_strategy
            ),
            style_sheet_loading_issue_reason=data['style_sheet_loading_issue_reason'],
            failed_request_info=from_dict(
                audits.FailedRequestInfo,
                data.get('failed_request_info', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return audits.StylesheetLoadingIssueDetails(
            source_code_location=from_dict(
                audits.SourceCodeLocation,
                data['sourceCodeLocation'],
                casing_strategy
            ),
            style_sheet_loading_issue_reason=data['styleSheetLoadingIssueReason'],
            failed_request_info=from_dict(
                audits.FailedRequestInfo,
                data.get('failedRequestInfo', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return audits.StylesheetLoadingIssueDetails(
            source_code_location=from_dict(
                audits.SourceCodeLocation,
                data['SourceCodeLocation'],
                casing_strategy
            ),
            style_sheet_loading_issue_reason=data['StyleSheetLoadingIssueReason'],
            failed_request_info=from_dict(
                audits.FailedRequestInfo,
                data.get('FailedRequestInfo', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__inspector_issue_details__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.InspectorIssueDetails':

    if casing_strategy == 'snake':
        return audits.InspectorIssueDetails(
            cookie_issue_details=from_dict(
                audits.CookieIssueDetails,
                data.get('cookie_issue_details', None),
                casing_strategy
            ),
            mixed_content_issue_details=from_dict(
                audits.MixedContentIssueDetails,
                data.get('mixed_content_issue_details', None),
                casing_strategy
            ),
            blocked_by_response_issue_details=from_dict(
                audits.BlockedByResponseIssueDetails,
                data.get('blocked_by_response_issue_details', None),
                casing_strategy
            ),
            heavy_ad_issue_details=from_dict(
                audits.HeavyAdIssueDetails,
                data.get('heavy_ad_issue_details', None),
                casing_strategy
            ),
            content_security_policy_issue_details=from_dict(
                audits.ContentSecurityPolicyIssueDetails,
                data.get('content_security_policy_issue_details', None),
                casing_strategy
            ),
            shared_array_buffer_issue_details=from_dict(
                audits.SharedArrayBufferIssueDetails,
                data.get('shared_array_buffer_issue_details', None),
                casing_strategy
            ),
            low_text_contrast_issue_details=from_dict(
                audits.LowTextContrastIssueDetails,
                data.get('low_text_contrast_issue_details', None),
                casing_strategy
            ),
            cors_issue_details=from_dict(
                audits.CorsIssueDetails,
                data.get('cors_issue_details', None),
                casing_strategy
            ),
            attribution_reporting_issue_details=from_dict(
                audits.AttributionReportingIssueDetails,
                data.get('attribution_reporting_issue_details', None),
                casing_strategy
            ),
            quirks_mode_issue_details=from_dict(
                audits.QuirksModeIssueDetails,
                data.get('quirks_mode_issue_details', None),
                casing_strategy
            ),
            navigator_user_agent_issue_details=from_dict(
                audits.NavigatorUserAgentIssueDetails,
                data.get('navigator_user_agent_issue_details', None),
                casing_strategy
            ),
            generic_issue_details=from_dict(
                audits.GenericIssueDetails,
                data.get('generic_issue_details', None),
                casing_strategy
            ),
            deprecation_issue_details=from_dict(
                audits.DeprecationIssueDetails,
                data.get('deprecation_issue_details', None),
                casing_strategy
            ),
            client_hint_issue_details=from_dict(
                audits.ClientHintIssueDetails,
                data.get('client_hint_issue_details', None),
                casing_strategy
            ),
            federated_auth_request_issue_details=from_dict(
                audits.FederatedAuthRequestIssueDetails,
                data.get('federated_auth_request_issue_details', None),
                casing_strategy
            ),
            bounce_tracking_issue_details=from_dict(
                audits.BounceTrackingIssueDetails,
                data.get('bounce_tracking_issue_details', None),
                casing_strategy
            ),
            stylesheet_loading_issue_details=from_dict(
                audits.StylesheetLoadingIssueDetails,
                data.get('stylesheet_loading_issue_details', None),
                casing_strategy
            ),
            federated_auth_user_info_request_issue_details=from_dict(
                audits.FederatedAuthUserInfoRequestIssueDetails,
                data.get('federated_auth_user_info_request_issue_details', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return audits.InspectorIssueDetails(
            cookie_issue_details=from_dict(
                audits.CookieIssueDetails,
                data.get('cookieIssueDetails', None),
                casing_strategy
            ),
            mixed_content_issue_details=from_dict(
                audits.MixedContentIssueDetails,
                data.get('mixedContentIssueDetails', None),
                casing_strategy
            ),
            blocked_by_response_issue_details=from_dict(
                audits.BlockedByResponseIssueDetails,
                data.get('blockedByResponseIssueDetails', None),
                casing_strategy
            ),
            heavy_ad_issue_details=from_dict(
                audits.HeavyAdIssueDetails,
                data.get('heavyAdIssueDetails', None),
                casing_strategy
            ),
            content_security_policy_issue_details=from_dict(
                audits.ContentSecurityPolicyIssueDetails,
                data.get('contentSecurityPolicyIssueDetails', None),
                casing_strategy
            ),
            shared_array_buffer_issue_details=from_dict(
                audits.SharedArrayBufferIssueDetails,
                data.get('sharedArrayBufferIssueDetails', None),
                casing_strategy
            ),
            low_text_contrast_issue_details=from_dict(
                audits.LowTextContrastIssueDetails,
                data.get('lowTextContrastIssueDetails', None),
                casing_strategy
            ),
            cors_issue_details=from_dict(
                audits.CorsIssueDetails,
                data.get('corsIssueDetails', None),
                casing_strategy
            ),
            attribution_reporting_issue_details=from_dict(
                audits.AttributionReportingIssueDetails,
                data.get('attributionReportingIssueDetails', None),
                casing_strategy
            ),
            quirks_mode_issue_details=from_dict(
                audits.QuirksModeIssueDetails,
                data.get('quirksModeIssueDetails', None),
                casing_strategy
            ),
            navigator_user_agent_issue_details=from_dict(
                audits.NavigatorUserAgentIssueDetails,
                data.get('navigatorUserAgentIssueDetails', None),
                casing_strategy
            ),
            generic_issue_details=from_dict(
                audits.GenericIssueDetails,
                data.get('genericIssueDetails', None),
                casing_strategy
            ),
            deprecation_issue_details=from_dict(
                audits.DeprecationIssueDetails,
                data.get('deprecationIssueDetails', None),
                casing_strategy
            ),
            client_hint_issue_details=from_dict(
                audits.ClientHintIssueDetails,
                data.get('clientHintIssueDetails', None),
                casing_strategy
            ),
            federated_auth_request_issue_details=from_dict(
                audits.FederatedAuthRequestIssueDetails,
                data.get('federatedAuthRequestIssueDetails', None),
                casing_strategy
            ),
            bounce_tracking_issue_details=from_dict(
                audits.BounceTrackingIssueDetails,
                data.get('bounceTrackingIssueDetails', None),
                casing_strategy
            ),
            stylesheet_loading_issue_details=from_dict(
                audits.StylesheetLoadingIssueDetails,
                data.get('stylesheetLoadingIssueDetails', None),
                casing_strategy
            ),
            federated_auth_user_info_request_issue_details=from_dict(
                audits.FederatedAuthUserInfoRequestIssueDetails,
                data.get('federatedAuthUserInfoRequestIssueDetails', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return audits.InspectorIssueDetails(
            cookie_issue_details=from_dict(
                audits.CookieIssueDetails,
                data.get('CookieIssueDetails', None),
                casing_strategy
            ),
            mixed_content_issue_details=from_dict(
                audits.MixedContentIssueDetails,
                data.get('MixedContentIssueDetails', None),
                casing_strategy
            ),
            blocked_by_response_issue_details=from_dict(
                audits.BlockedByResponseIssueDetails,
                data.get('BlockedByResponseIssueDetails', None),
                casing_strategy
            ),
            heavy_ad_issue_details=from_dict(
                audits.HeavyAdIssueDetails,
                data.get('HeavyAdIssueDetails', None),
                casing_strategy
            ),
            content_security_policy_issue_details=from_dict(
                audits.ContentSecurityPolicyIssueDetails,
                data.get('ContentSecurityPolicyIssueDetails', None),
                casing_strategy
            ),
            shared_array_buffer_issue_details=from_dict(
                audits.SharedArrayBufferIssueDetails,
                data.get('SharedArrayBufferIssueDetails', None),
                casing_strategy
            ),
            low_text_contrast_issue_details=from_dict(
                audits.LowTextContrastIssueDetails,
                data.get('LowTextContrastIssueDetails', None),
                casing_strategy
            ),
            cors_issue_details=from_dict(
                audits.CorsIssueDetails,
                data.get('CorsIssueDetails', None),
                casing_strategy
            ),
            attribution_reporting_issue_details=from_dict(
                audits.AttributionReportingIssueDetails,
                data.get('AttributionReportingIssueDetails', None),
                casing_strategy
            ),
            quirks_mode_issue_details=from_dict(
                audits.QuirksModeIssueDetails,
                data.get('QuirksModeIssueDetails', None),
                casing_strategy
            ),
            navigator_user_agent_issue_details=from_dict(
                audits.NavigatorUserAgentIssueDetails,
                data.get('NavigatorUserAgentIssueDetails', None),
                casing_strategy
            ),
            generic_issue_details=from_dict(
                audits.GenericIssueDetails,
                data.get('GenericIssueDetails', None),
                casing_strategy
            ),
            deprecation_issue_details=from_dict(
                audits.DeprecationIssueDetails,
                data.get('DeprecationIssueDetails', None),
                casing_strategy
            ),
            client_hint_issue_details=from_dict(
                audits.ClientHintIssueDetails,
                data.get('ClientHintIssueDetails', None),
                casing_strategy
            ),
            federated_auth_request_issue_details=from_dict(
                audits.FederatedAuthRequestIssueDetails,
                data.get('FederatedAuthRequestIssueDetails', None),
                casing_strategy
            ),
            bounce_tracking_issue_details=from_dict(
                audits.BounceTrackingIssueDetails,
                data.get('BounceTrackingIssueDetails', None),
                casing_strategy
            ),
            stylesheet_loading_issue_details=from_dict(
                audits.StylesheetLoadingIssueDetails,
                data.get('StylesheetLoadingIssueDetails', None),
                casing_strategy
            ),
            federated_auth_user_info_request_issue_details=from_dict(
                audits.FederatedAuthUserInfoRequestIssueDetails,
                data.get('FederatedAuthUserInfoRequestIssueDetails', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__inspector_issue__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.InspectorIssue':

    if casing_strategy == 'snake':
        return audits.InspectorIssue(
            code=data['code'],
            details=from_dict(
                audits.InspectorIssueDetails,
                data['details'],
                casing_strategy
            ),
            issue_id=data.get('issue_id', None)
        )

    if casing_strategy == 'camel':
        return audits.InspectorIssue(
            code=data['code'],
            details=from_dict(
                audits.InspectorIssueDetails,
                data['details'],
                casing_strategy
            ),
            issue_id=data.get('issueId', None)
        )

    if casing_strategy == 'pascal':
        return audits.InspectorIssue(
            code=data['Code'],
            details=from_dict(
                audits.InspectorIssueDetails,
                data['Details'],
                casing_strategy
            ),
            issue_id=data.get('IssueId', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _autofill__credit_card__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'autofill.CreditCard':

    if casing_strategy == 'snake':
        return autofill.CreditCard(
            number=data['number'],
            name=data['name'],
            expiry_month=data['expiry_month'],
            expiry_year=data['expiry_year'],
            cvc=data['cvc']
        )

    if casing_strategy == 'camel':
        return autofill.CreditCard(
            number=data['number'],
            name=data['name'],
            expiry_month=data['expiryMonth'],
            expiry_year=data['expiryYear'],
            cvc=data['cvc']
        )

    if casing_strategy == 'pascal':
        return autofill.CreditCard(
            number=data['Number'],
            name=data['Name'],
            expiry_month=data['ExpiryMonth'],
            expiry_year=data['ExpiryYear'],
            cvc=data['Cvc']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _autofill__address_field__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'autofill.AddressField':

    if casing_strategy == 'snake':
        return autofill.AddressField(
            name=data['name'],
            value=data['value']
        )

    if casing_strategy == 'camel':
        return autofill.AddressField(
            name=data['name'],
            value=data['value']
        )

    if casing_strategy == 'pascal':
        return autofill.AddressField(
            name=data['Name'],
            value=data['Value']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _autofill__address_fields__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'autofill.AddressFields':

    if casing_strategy == 'snake':
        return autofill.AddressFields(
            fields=[
                from_dict(autofill.AddressField, item, casing_strategy)
                for item in data['fields']
            ]
        )

    if casing_strategy == 'camel':
        return autofill.AddressFields(
            fields=[
                from_dict(autofill.AddressField, item, casing_strategy)
                for item in data['fields']
            ]
        )

    if casing_strategy == 'pascal':
        return autofill.AddressFields(
            fields=[
                from_dict(autofill.AddressField, item, casing_strategy)
                for item in data['Fields']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _autofill__address__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'autofill.Address':

    if casing_strategy == 'snake':
        return autofill.Address(
            fields=[
                from_dict(autofill.AddressField, item, casing_strategy)
                for item in data['fields']
            ]
        )

    if casing_strategy == 'camel':
        return autofill.Address(
            fields=[
                from_dict(autofill.AddressField, item, casing_strategy)
                for item in data['fields']
            ]
        )

    if casing_strategy == 'pascal':
        return autofill.Address(
            fields=[
                from_dict(autofill.AddressField, item, casing_strategy)
                for item in data['Fields']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _autofill__address_ui__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'autofill.AddressUI':

    if casing_strategy == 'snake':
        return autofill.AddressUI(
            address_fields=[
                from_dict(autofill.AddressFields, item, casing_strategy)
                for item in data['address_fields']
            ]
        )

    if casing_strategy == 'camel':
        return autofill.AddressUI(
            address_fields=[
                from_dict(autofill.AddressFields, item, casing_strategy)
                for item in data['addressFields']
            ]
        )

    if casing_strategy == 'pascal':
        return autofill.AddressUI(
            address_fields=[
                from_dict(autofill.AddressFields, item, casing_strategy)
                for item in data['AddressFields']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _autofill__filled_field__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'autofill.FilledField':

    if casing_strategy == 'snake':
        return autofill.FilledField(
            html_type=data['html_type'],
            id=data['id'],
            name=data['name'],
            value=data['value'],
            autofill_type=data['autofill_type'],
            filling_strategy=data['filling_strategy']
        )

    if casing_strategy == 'camel':
        return autofill.FilledField(
            html_type=data['htmlType'],
            id=data['id'],
            name=data['name'],
            value=data['value'],
            autofill_type=data['autofillType'],
            filling_strategy=data['fillingStrategy']
        )

    if casing_strategy == 'pascal':
        return autofill.FilledField(
            html_type=data['HtmlType'],
            id=data['Id'],
            name=data['Name'],
            value=data['Value'],
            autofill_type=data['AutofillType'],
            filling_strategy=data['FillingStrategy']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _background_service__event_metadata__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'background_service.EventMetadata':

    if casing_strategy == 'snake':
        return background_service.EventMetadata(
            key=data['key'],
            value=data['value']
        )

    if casing_strategy == 'camel':
        return background_service.EventMetadata(
            key=data['key'],
            value=data['value']
        )

    if casing_strategy == 'pascal':
        return background_service.EventMetadata(
            key=data['Key'],
            value=data['Value']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _background_service__background_service_event__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'background_service.BackgroundServiceEvent':

    if casing_strategy == 'snake':
        return background_service.BackgroundServiceEvent(
            timestamp=data['timestamp'],
            origin=data['origin'],
            service_worker_registration_id=data['service_worker_registration_id'],
            service=data['service'],
            event_name=data['event_name'],
            instance_id=data['instance_id'],
            event_metadata=[
                from_dict(background_service.EventMetadata, item, casing_strategy)
                for item in data['event_metadata']
            ],
            storage_key=data['storage_key']
        )

    if casing_strategy == 'camel':
        return background_service.BackgroundServiceEvent(
            timestamp=data['timestamp'],
            origin=data['origin'],
            service_worker_registration_id=data['serviceWorkerRegistrationId'],
            service=data['service'],
            event_name=data['eventName'],
            instance_id=data['instanceId'],
            event_metadata=[
                from_dict(background_service.EventMetadata, item, casing_strategy)
                for item in data['eventMetadata']
            ],
            storage_key=data['storageKey']
        )

    if casing_strategy == 'pascal':
        return background_service.BackgroundServiceEvent(
            timestamp=data['Timestamp'],
            origin=data['Origin'],
            service_worker_registration_id=data['ServiceWorkerRegistrationId'],
            service=data['Service'],
            event_name=data['EventName'],
            instance_id=data['InstanceId'],
            event_metadata=[
                from_dict(background_service.EventMetadata, item, casing_strategy)
                for item in data['EventMetadata']
            ],
            storage_key=data['StorageKey']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _browser__bounds__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'browser.Bounds':

    if casing_strategy == 'snake':
        return browser.Bounds(
            left=data.get('left', None),
            top=data.get('top', None),
            width=data.get('width', None),
            height=data.get('height', None),
            window_state=data.get('window_state', None)
        )

    if casing_strategy == 'camel':
        return browser.Bounds(
            left=data.get('left', None),
            top=data.get('top', None),
            width=data.get('width', None),
            height=data.get('height', None),
            window_state=data.get('windowState', None)
        )

    if casing_strategy == 'pascal':
        return browser.Bounds(
            left=data.get('Left', None),
            top=data.get('Top', None),
            width=data.get('Width', None),
            height=data.get('Height', None),
            window_state=data.get('WindowState', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _browser__permission_descriptor__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'browser.PermissionDescriptor':

    if casing_strategy == 'snake':
        return browser.PermissionDescriptor(
            name=data['name'],
            sysex=data.get('sysex', None),
            user_visible_only=data.get('user_visible_only', None),
            allow_without_sanitization=data.get('allow_without_sanitization', None),
            pan_tilt_zoom=data.get('pan_tilt_zoom', None)
        )

    if casing_strategy == 'camel':
        return browser.PermissionDescriptor(
            name=data['name'],
            sysex=data.get('sysex', None),
            user_visible_only=data.get('userVisibleOnly', None),
            allow_without_sanitization=data.get('allowWithoutSanitization', None),
            pan_tilt_zoom=data.get('panTiltZoom', None)
        )

    if casing_strategy == 'pascal':
        return browser.PermissionDescriptor(
            name=data['Name'],
            sysex=data.get('Sysex', None),
            user_visible_only=data.get('UserVisibleOnly', None),
            allow_without_sanitization=data.get('AllowWithoutSanitization', None),
            pan_tilt_zoom=data.get('PanTiltZoom', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _browser__bucket__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'browser.Bucket':

    if casing_strategy == 'snake':
        return browser.Bucket(
            low=data['low'],
            high=data['high'],
            count=data['count']
        )

    if casing_strategy == 'camel':
        return browser.Bucket(
            low=data['low'],
            high=data['high'],
            count=data['count']
        )

    if casing_strategy == 'pascal':
        return browser.Bucket(
            low=data['Low'],
            high=data['High'],
            count=data['Count']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _browser__histogram__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'browser.Histogram':

    if casing_strategy == 'snake':
        return browser.Histogram(
            name=data['name'],
            sum=data['sum'],
            count=data['count'],
            buckets=[
                from_dict(browser.Bucket, item, casing_strategy)
                for item in data['buckets']
            ]
        )

    if casing_strategy == 'camel':
        return browser.Histogram(
            name=data['name'],
            sum=data['sum'],
            count=data['count'],
            buckets=[
                from_dict(browser.Bucket, item, casing_strategy)
                for item in data['buckets']
            ]
        )

    if casing_strategy == 'pascal':
        return browser.Histogram(
            name=data['Name'],
            sum=data['Sum'],
            count=data['Count'],
            buckets=[
                from_dict(browser.Bucket, item, casing_strategy)
                for item in data['Buckets']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__pseudo_element_matches__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.PseudoElementMatches':

    if casing_strategy == 'snake':
        return css.PseudoElementMatches(
            pseudo_type=data['pseudo_type'],
            pseudo_identifier=data.get('pseudo_identifier', None),
            matches=[
                from_dict(css.RuleMatch, item, casing_strategy)
                for item in data['matches']
            ]
        )

    if casing_strategy == 'camel':
        return css.PseudoElementMatches(
            pseudo_type=data['pseudoType'],
            pseudo_identifier=data.get('pseudoIdentifier', None),
            matches=[
                from_dict(css.RuleMatch, item, casing_strategy)
                for item in data['matches']
            ]
        )

    if casing_strategy == 'pascal':
        return css.PseudoElementMatches(
            pseudo_type=data['PseudoType'],
            pseudo_identifier=data.get('PseudoIdentifier', None),
            matches=[
                from_dict(css.RuleMatch, item, casing_strategy)
                for item in data['Matches']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__inherited_style_entry__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.InheritedStyleEntry':

    if casing_strategy == 'snake':
        return css.InheritedStyleEntry(
            inline_style=from_dict(
                css.CSSStyle,
                data.get('inline_style', None),
                casing_strategy
            ),
            matched_css_rules=[
                from_dict(css.RuleMatch, item, casing_strategy)
                for item in data['matched_css_rules']
            ]
        )

    if casing_strategy == 'camel':
        return css.InheritedStyleEntry(
            inline_style=from_dict(
                css.CSSStyle,
                data.get('inlineStyle', None),
                casing_strategy
            ),
            matched_css_rules=[
                from_dict(css.RuleMatch, item, casing_strategy)
                for item in data['matchedCSSRules']
            ]
        )

    if casing_strategy == 'pascal':
        return css.InheritedStyleEntry(
            inline_style=from_dict(
                css.CSSStyle,
                data.get('InlineStyle', None),
                casing_strategy
            ),
            matched_css_rules=[
                from_dict(css.RuleMatch, item, casing_strategy)
                for item in data['MatchedCSSRules']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__inherited_pseudo_element_matches__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.InheritedPseudoElementMatches':

    if casing_strategy == 'snake':
        return css.InheritedPseudoElementMatches(
            pseudo_elements=[
                from_dict(css.PseudoElementMatches, item, casing_strategy)
                for item in data['pseudo_elements']
            ]
        )

    if casing_strategy == 'camel':
        return css.InheritedPseudoElementMatches(
            pseudo_elements=[
                from_dict(css.PseudoElementMatches, item, casing_strategy)
                for item in data['pseudoElements']
            ]
        )

    if casing_strategy == 'pascal':
        return css.InheritedPseudoElementMatches(
            pseudo_elements=[
                from_dict(css.PseudoElementMatches, item, casing_strategy)
                for item in data['PseudoElements']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__rule_match__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.RuleMatch':

    if casing_strategy == 'snake':
        return css.RuleMatch(
            rule=from_dict(
                css.CSSRule,
                data['rule'],
                casing_strategy
            ),
            matching_selectors=data['matching_selectors']
        )

    if casing_strategy == 'camel':
        return css.RuleMatch(
            rule=from_dict(
                css.CSSRule,
                data['rule'],
                casing_strategy
            ),
            matching_selectors=data['matchingSelectors']
        )

    if casing_strategy == 'pascal':
        return css.RuleMatch(
            rule=from_dict(
                css.CSSRule,
                data['Rule'],
                casing_strategy
            ),
            matching_selectors=data['MatchingSelectors']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__value__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.Value':

    if casing_strategy == 'snake':
        return css.Value(
            text=data['text'],
            range=from_dict(
                css.SourceRange,
                data.get('range', None),
                casing_strategy
            ),
            specificity=from_dict(
                css.Specificity,
                data.get('specificity', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return css.Value(
            text=data['text'],
            range=from_dict(
                css.SourceRange,
                data.get('range', None),
                casing_strategy
            ),
            specificity=from_dict(
                css.Specificity,
                data.get('specificity', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return css.Value(
            text=data['Text'],
            range=from_dict(
                css.SourceRange,
                data.get('Range', None),
                casing_strategy
            ),
            specificity=from_dict(
                css.Specificity,
                data.get('Specificity', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__specificity__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.Specificity':

    if casing_strategy == 'snake':
        return css.Specificity(
            a=data['a'],
            b=data['b'],
            c=data['c']
        )

    if casing_strategy == 'camel':
        return css.Specificity(
            a=data['a'],
            b=data['b'],
            c=data['c']
        )

    if casing_strategy == 'pascal':
        return css.Specificity(
            a=data['A'],
            b=data['B'],
            c=data['C']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__selector_list__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.SelectorList':

    if casing_strategy == 'snake':
        return css.SelectorList(
            selectors=[
                from_dict(css.Value, item, casing_strategy)
                for item in data['selectors']
            ],
            text=data['text']
        )

    if casing_strategy == 'camel':
        return css.SelectorList(
            selectors=[
                from_dict(css.Value, item, casing_strategy)
                for item in data['selectors']
            ],
            text=data['text']
        )

    if casing_strategy == 'pascal':
        return css.SelectorList(
            selectors=[
                from_dict(css.Value, item, casing_strategy)
                for item in data['Selectors']
            ],
            text=data['Text']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_style_sheet_header__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.CSSStyleSheetHeader':

    if casing_strategy == 'snake':
        return css.CSSStyleSheetHeader(
            style_sheet_id=data['style_sheet_id'],
            frame_id=data['frame_id'],
            source_url=data['source_url'],
            source_map_url=data.get('source_map_url', None),
            origin=data['origin'],
            title=data['title'],
            owner_node=data.get('owner_node', None),
            disabled=data['disabled'],
            has_source_url=data.get('has_source_url', None),
            is_inline=data['is_inline'],
            is_mutable=data['is_mutable'],
            is_constructed=data['is_constructed'],
            start_line=data['start_line'],
            start_column=data['start_column'],
            length=data['length'],
            end_line=data['end_line'],
            end_column=data['end_column'],
            loading_failed=data.get('loading_failed', None)
        )

    if casing_strategy == 'camel':
        return css.CSSStyleSheetHeader(
            style_sheet_id=data['styleSheetId'],
            frame_id=data['frameId'],
            source_url=data['sourceURL'],
            source_map_url=data.get('sourceMapURL', None),
            origin=data['origin'],
            title=data['title'],
            owner_node=data.get('ownerNode', None),
            disabled=data['disabled'],
            has_source_url=data.get('hasSourceURL', None),
            is_inline=data['isInline'],
            is_mutable=data['isMutable'],
            is_constructed=data['isConstructed'],
            start_line=data['startLine'],
            start_column=data['startColumn'],
            length=data['length'],
            end_line=data['endLine'],
            end_column=data['endColumn'],
            loading_failed=data.get('loadingFailed', None)
        )

    if casing_strategy == 'pascal':
        return css.CSSStyleSheetHeader(
            style_sheet_id=data['StyleSheetId'],
            frame_id=data['FrameId'],
            source_url=data['SourceURL'],
            source_map_url=data.get('SourceMapURL', None),
            origin=data['Origin'],
            title=data['Title'],
            owner_node=data.get('OwnerNode', None),
            disabled=data['Disabled'],
            has_source_url=data.get('HasSourceURL', None),
            is_inline=data['IsInline'],
            is_mutable=data['IsMutable'],
            is_constructed=data['IsConstructed'],
            start_line=data['StartLine'],
            start_column=data['StartColumn'],
            length=data['Length'],
            end_line=data['EndLine'],
            end_column=data['EndColumn'],
            loading_failed=data.get('LoadingFailed', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_rule__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.CSSRule':

    if casing_strategy == 'snake':
        return css.CSSRule(
            style_sheet_id=data.get('style_sheet_id', None),
            selector_list=from_dict(
                css.SelectorList,
                data['selector_list'],
                casing_strategy
            ),
            nesting_selectors=data.get('nesting_selectors', []),
            origin=data['origin'],
            style=from_dict(
                css.CSSStyle,
                data['style'],
                casing_strategy
            ),
            media=[
                from_dict(css.CSSMedia, item, casing_strategy)
                for item in data.get('media', [])
            ],
            container_queries=[
                from_dict(css.CSSContainerQuery, item, casing_strategy)
                for item in data.get('container_queries', [])
            ],
            supports=[
                from_dict(css.CSSSupports, item, casing_strategy)
                for item in data.get('supports', [])
            ],
            layers=[
                from_dict(css.CSSLayer, item, casing_strategy)
                for item in data.get('layers', [])
            ],
            scopes=[
                from_dict(css.CSSScope, item, casing_strategy)
                for item in data.get('scopes', [])
            ],
            rule_types=data.get('rule_types', [])
        )

    if casing_strategy == 'camel':
        return css.CSSRule(
            style_sheet_id=data.get('styleSheetId', None),
            selector_list=from_dict(
                css.SelectorList,
                data['selectorList'],
                casing_strategy
            ),
            nesting_selectors=data.get('nestingSelectors', []),
            origin=data['origin'],
            style=from_dict(
                css.CSSStyle,
                data['style'],
                casing_strategy
            ),
            media=[
                from_dict(css.CSSMedia, item, casing_strategy)
                for item in data.get('media', [])
            ],
            container_queries=[
                from_dict(css.CSSContainerQuery, item, casing_strategy)
                for item in data.get('containerQueries', [])
            ],
            supports=[
                from_dict(css.CSSSupports, item, casing_strategy)
                for item in data.get('supports', [])
            ],
            layers=[
                from_dict(css.CSSLayer, item, casing_strategy)
                for item in data.get('layers', [])
            ],
            scopes=[
                from_dict(css.CSSScope, item, casing_strategy)
                for item in data.get('scopes', [])
            ],
            rule_types=data.get('ruleTypes', [])
        )

    if casing_strategy == 'pascal':
        return css.CSSRule(
            style_sheet_id=data.get('StyleSheetId', None),
            selector_list=from_dict(
                css.SelectorList,
                data['SelectorList'],
                casing_strategy
            ),
            nesting_selectors=data.get('NestingSelectors', []),
            origin=data['Origin'],
            style=from_dict(
                css.CSSStyle,
                data['Style'],
                casing_strategy
            ),
            media=[
                from_dict(css.CSSMedia, item, casing_strategy)
                for item in data.get('Media', [])
            ],
            container_queries=[
                from_dict(css.CSSContainerQuery, item, casing_strategy)
                for item in data.get('ContainerQueries', [])
            ],
            supports=[
                from_dict(css.CSSSupports, item, casing_strategy)
                for item in data.get('Supports', [])
            ],
            layers=[
                from_dict(css.CSSLayer, item, casing_strategy)
                for item in data.get('Layers', [])
            ],
            scopes=[
                from_dict(css.CSSScope, item, casing_strategy)
                for item in data.get('Scopes', [])
            ],
            rule_types=data.get('RuleTypes', [])
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__rule_usage__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.RuleUsage':

    if casing_strategy == 'snake':
        return css.RuleUsage(
            style_sheet_id=data['style_sheet_id'],
            start_offset=data['start_offset'],
            end_offset=data['end_offset'],
            used=data['used']
        )

    if casing_strategy == 'camel':
        return css.RuleUsage(
            style_sheet_id=data['styleSheetId'],
            start_offset=data['startOffset'],
            end_offset=data['endOffset'],
            used=data['used']
        )

    if casing_strategy == 'pascal':
        return css.RuleUsage(
            style_sheet_id=data['StyleSheetId'],
            start_offset=data['StartOffset'],
            end_offset=data['EndOffset'],
            used=data['Used']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__source_range__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.SourceRange':

    if casing_strategy == 'snake':
        return css.SourceRange(
            start_line=data['start_line'],
            start_column=data['start_column'],
            end_line=data['end_line'],
            end_column=data['end_column']
        )

    if casing_strategy == 'camel':
        return css.SourceRange(
            start_line=data['startLine'],
            start_column=data['startColumn'],
            end_line=data['endLine'],
            end_column=data['endColumn']
        )

    if casing_strategy == 'pascal':
        return css.SourceRange(
            start_line=data['StartLine'],
            start_column=data['StartColumn'],
            end_line=data['EndLine'],
            end_column=data['EndColumn']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__shorthand_entry__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.ShorthandEntry':

    if casing_strategy == 'snake':
        return css.ShorthandEntry(
            name=data['name'],
            value=data['value'],
            important=data.get('important', None)
        )

    if casing_strategy == 'camel':
        return css.ShorthandEntry(
            name=data['name'],
            value=data['value'],
            important=data.get('important', None)
        )

    if casing_strategy == 'pascal':
        return css.ShorthandEntry(
            name=data['Name'],
            value=data['Value'],
            important=data.get('Important', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_computed_style_property__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.CSSComputedStyleProperty':

    if casing_strategy == 'snake':
        return css.CSSComputedStyleProperty(
            name=data['name'],
            value=data['value']
        )

    if casing_strategy == 'camel':
        return css.CSSComputedStyleProperty(
            name=data['name'],
            value=data['value']
        )

    if casing_strategy == 'pascal':
        return css.CSSComputedStyleProperty(
            name=data['Name'],
            value=data['Value']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_style__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.CSSStyle':

    if casing_strategy == 'snake':
        return css.CSSStyle(
            style_sheet_id=data.get('style_sheet_id', None),
            css_properties=[
                from_dict(css.CSSProperty, item, casing_strategy)
                for item in data['css_properties']
            ],
            shorthand_entries=[
                from_dict(css.ShorthandEntry, item, casing_strategy)
                for item in data['shorthand_entries']
            ],
            css_text=data.get('css_text', None),
            range=from_dict(
                css.SourceRange,
                data.get('range', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return css.CSSStyle(
            style_sheet_id=data.get('styleSheetId', None),
            css_properties=[
                from_dict(css.CSSProperty, item, casing_strategy)
                for item in data['cssProperties']
            ],
            shorthand_entries=[
                from_dict(css.ShorthandEntry, item, casing_strategy)
                for item in data['shorthandEntries']
            ],
            css_text=data.get('cssText', None),
            range=from_dict(
                css.SourceRange,
                data.get('range', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return css.CSSStyle(
            style_sheet_id=data.get('StyleSheetId', None),
            css_properties=[
                from_dict(css.CSSProperty, item, casing_strategy)
                for item in data['CssProperties']
            ],
            shorthand_entries=[
                from_dict(css.ShorthandEntry, item, casing_strategy)
                for item in data['ShorthandEntries']
            ],
            css_text=data.get('CssText', None),
            range=from_dict(
                css.SourceRange,
                data.get('Range', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_property__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.CSSProperty':

    if casing_strategy == 'snake':
        return css.CSSProperty(
            name=data['name'],
            value=data['value'],
            important=data.get('important', None),
            implicit=data.get('implicit', None),
            text=data.get('text', None),
            parsed_ok=data.get('parsed_ok', None),
            disabled=data.get('disabled', None),
            range=from_dict(
                css.SourceRange,
                data.get('range', None),
                casing_strategy
            ),
            longhand_properties=[
                from_dict(css.CSSProperty, item, casing_strategy)
                for item in data.get('longhand_properties', [])
            ]
        )

    if casing_strategy == 'camel':
        return css.CSSProperty(
            name=data['name'],
            value=data['value'],
            important=data.get('important', None),
            implicit=data.get('implicit', None),
            text=data.get('text', None),
            parsed_ok=data.get('parsedOk', None),
            disabled=data.get('disabled', None),
            range=from_dict(
                css.SourceRange,
                data.get('range', None),
                casing_strategy
            ),
            longhand_properties=[
                from_dict(css.CSSProperty, item, casing_strategy)
                for item in data.get('longhandProperties', [])
            ]
        )

    if casing_strategy == 'pascal':
        return css.CSSProperty(
            name=data['Name'],
            value=data['Value'],
            important=data.get('Important', None),
            implicit=data.get('Implicit', None),
            text=data.get('Text', None),
            parsed_ok=data.get('ParsedOk', None),
            disabled=data.get('Disabled', None),
            range=from_dict(
                css.SourceRange,
                data.get('Range', None),
                casing_strategy
            ),
            longhand_properties=[
                from_dict(css.CSSProperty, item, casing_strategy)
                for item in data.get('LonghandProperties', [])
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_media__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.CSSMedia':

    if casing_strategy == 'snake':
        return css.CSSMedia(
            text=data['text'],
            source=data['source'],
            source_url=data.get('source_url', None),
            range=from_dict(
                css.SourceRange,
                data.get('range', None),
                casing_strategy
            ),
            style_sheet_id=data.get('style_sheet_id', None),
            media_list=[
                from_dict(css.MediaQuery, item, casing_strategy)
                for item in data.get('media_list', [])
            ]
        )

    if casing_strategy == 'camel':
        return css.CSSMedia(
            text=data['text'],
            source=data['source'],
            source_url=data.get('sourceURL', None),
            range=from_dict(
                css.SourceRange,
                data.get('range', None),
                casing_strategy
            ),
            style_sheet_id=data.get('styleSheetId', None),
            media_list=[
                from_dict(css.MediaQuery, item, casing_strategy)
                for item in data.get('mediaList', [])
            ]
        )

    if casing_strategy == 'pascal':
        return css.CSSMedia(
            text=data['Text'],
            source=data['Source'],
            source_url=data.get('SourceURL', None),
            range=from_dict(
                css.SourceRange,
                data.get('Range', None),
                casing_strategy
            ),
            style_sheet_id=data.get('StyleSheetId', None),
            media_list=[
                from_dict(css.MediaQuery, item, casing_strategy)
                for item in data.get('MediaList', [])
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__media_query__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.MediaQuery':

    if casing_strategy == 'snake':
        return css.MediaQuery(
            expressions=[
                from_dict(css.MediaQueryExpression, item, casing_strategy)
                for item in data['expressions']
            ],
            active=data['active']
        )

    if casing_strategy == 'camel':
        return css.MediaQuery(
            expressions=[
                from_dict(css.MediaQueryExpression, item, casing_strategy)
                for item in data['expressions']
            ],
            active=data['active']
        )

    if casing_strategy == 'pascal':
        return css.MediaQuery(
            expressions=[
                from_dict(css.MediaQueryExpression, item, casing_strategy)
                for item in data['Expressions']
            ],
            active=data['Active']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__media_query_expression__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.MediaQueryExpression':

    if casing_strategy == 'snake':
        return css.MediaQueryExpression(
            value=data['value'],
            unit=data['unit'],
            feature=data['feature'],
            value_range=from_dict(
                css.SourceRange,
                data.get('value_range', None),
                casing_strategy
            ),
            computed_length=data.get('computed_length', None)
        )

    if casing_strategy == 'camel':
        return css.MediaQueryExpression(
            value=data['value'],
            unit=data['unit'],
            feature=data['feature'],
            value_range=from_dict(
                css.SourceRange,
                data.get('valueRange', None),
                casing_strategy
            ),
            computed_length=data.get('computedLength', None)
        )

    if casing_strategy == 'pascal':
        return css.MediaQueryExpression(
            value=data['Value'],
            unit=data['Unit'],
            feature=data['Feature'],
            value_range=from_dict(
                css.SourceRange,
                data.get('ValueRange', None),
                casing_strategy
            ),
            computed_length=data.get('ComputedLength', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_container_query__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.CSSContainerQuery':

    if casing_strategy == 'snake':
        return css.CSSContainerQuery(
            text=data['text'],
            range=from_dict(
                css.SourceRange,
                data.get('range', None),
                casing_strategy
            ),
            style_sheet_id=data.get('style_sheet_id', None),
            name=data.get('name', None),
            physical_axes=data.get('physical_axes', None),
            logical_axes=data.get('logical_axes', None)
        )

    if casing_strategy == 'camel':
        return css.CSSContainerQuery(
            text=data['text'],
            range=from_dict(
                css.SourceRange,
                data.get('range', None),
                casing_strategy
            ),
            style_sheet_id=data.get('styleSheetId', None),
            name=data.get('name', None),
            physical_axes=data.get('physicalAxes', None),
            logical_axes=data.get('logicalAxes', None)
        )

    if casing_strategy == 'pascal':
        return css.CSSContainerQuery(
            text=data['Text'],
            range=from_dict(
                css.SourceRange,
                data.get('Range', None),
                casing_strategy
            ),
            style_sheet_id=data.get('StyleSheetId', None),
            name=data.get('Name', None),
            physical_axes=data.get('PhysicalAxes', None),
            logical_axes=data.get('LogicalAxes', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_supports__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.CSSSupports':

    if casing_strategy == 'snake':
        return css.CSSSupports(
            text=data['text'],
            active=data['active'],
            range=from_dict(
                css.SourceRange,
                data.get('range', None),
                casing_strategy
            ),
            style_sheet_id=data.get('style_sheet_id', None)
        )

    if casing_strategy == 'camel':
        return css.CSSSupports(
            text=data['text'],
            active=data['active'],
            range=from_dict(
                css.SourceRange,
                data.get('range', None),
                casing_strategy
            ),
            style_sheet_id=data.get('styleSheetId', None)
        )

    if casing_strategy == 'pascal':
        return css.CSSSupports(
            text=data['Text'],
            active=data['Active'],
            range=from_dict(
                css.SourceRange,
                data.get('Range', None),
                casing_strategy
            ),
            style_sheet_id=data.get('StyleSheetId', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_scope__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.CSSScope':

    if casing_strategy == 'snake':
        return css.CSSScope(
            text=data['text'],
            range=from_dict(
                css.SourceRange,
                data.get('range', None),
                casing_strategy
            ),
            style_sheet_id=data.get('style_sheet_id', None)
        )

    if casing_strategy == 'camel':
        return css.CSSScope(
            text=data['text'],
            range=from_dict(
                css.SourceRange,
                data.get('range', None),
                casing_strategy
            ),
            style_sheet_id=data.get('styleSheetId', None)
        )

    if casing_strategy == 'pascal':
        return css.CSSScope(
            text=data['Text'],
            range=from_dict(
                css.SourceRange,
                data.get('Range', None),
                casing_strategy
            ),
            style_sheet_id=data.get('StyleSheetId', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_layer__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.CSSLayer':

    if casing_strategy == 'snake':
        return css.CSSLayer(
            text=data['text'],
            range=from_dict(
                css.SourceRange,
                data.get('range', None),
                casing_strategy
            ),
            style_sheet_id=data.get('style_sheet_id', None)
        )

    if casing_strategy == 'camel':
        return css.CSSLayer(
            text=data['text'],
            range=from_dict(
                css.SourceRange,
                data.get('range', None),
                casing_strategy
            ),
            style_sheet_id=data.get('styleSheetId', None)
        )

    if casing_strategy == 'pascal':
        return css.CSSLayer(
            text=data['Text'],
            range=from_dict(
                css.SourceRange,
                data.get('Range', None),
                casing_strategy
            ),
            style_sheet_id=data.get('StyleSheetId', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_layer_data__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.CSSLayerData':

    if casing_strategy == 'snake':
        return css.CSSLayerData(
            name=data['name'],
            sub_layers=[
                from_dict(css.CSSLayerData, item, casing_strategy)
                for item in data.get('sub_layers', [])
            ],
            order=data['order']
        )

    if casing_strategy == 'camel':
        return css.CSSLayerData(
            name=data['name'],
            sub_layers=[
                from_dict(css.CSSLayerData, item, casing_strategy)
                for item in data.get('subLayers', [])
            ],
            order=data['order']
        )

    if casing_strategy == 'pascal':
        return css.CSSLayerData(
            name=data['Name'],
            sub_layers=[
                from_dict(css.CSSLayerData, item, casing_strategy)
                for item in data.get('SubLayers', [])
            ],
            order=data['Order']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__platform_font_usage__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.PlatformFontUsage':

    if casing_strategy == 'snake':
        return css.PlatformFontUsage(
            family_name=data['family_name'],
            is_custom_font=data['is_custom_font'],
            glyph_count=data['glyph_count']
        )

    if casing_strategy == 'camel':
        return css.PlatformFontUsage(
            family_name=data['familyName'],
            is_custom_font=data['isCustomFont'],
            glyph_count=data['glyphCount']
        )

    if casing_strategy == 'pascal':
        return css.PlatformFontUsage(
            family_name=data['FamilyName'],
            is_custom_font=data['IsCustomFont'],
            glyph_count=data['GlyphCount']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__font_variation_axis__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.FontVariationAxis':

    if casing_strategy == 'snake':
        return css.FontVariationAxis(
            tag=data['tag'],
            name=data['name'],
            min_value=data['min_value'],
            max_value=data['max_value'],
            default_value=data['default_value']
        )

    if casing_strategy == 'camel':
        return css.FontVariationAxis(
            tag=data['tag'],
            name=data['name'],
            min_value=data['minValue'],
            max_value=data['maxValue'],
            default_value=data['defaultValue']
        )

    if casing_strategy == 'pascal':
        return css.FontVariationAxis(
            tag=data['Tag'],
            name=data['Name'],
            min_value=data['MinValue'],
            max_value=data['MaxValue'],
            default_value=data['DefaultValue']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__font_face__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.FontFace':

    if casing_strategy == 'snake':
        return css.FontFace(
            font_family=data['font_family'],
            font_style=data['font_style'],
            font_variant=data['font_variant'],
            font_weight=data['font_weight'],
            font_stretch=data['font_stretch'],
            font_display=data['font_display'],
            unicode_range=data['unicode_range'],
            src=data['src'],
            platform_font_family=data['platform_font_family'],
            font_variation_axes=[
                from_dict(css.FontVariationAxis, item, casing_strategy)
                for item in data.get('font_variation_axes', [])
            ]
        )

    if casing_strategy == 'camel':
        return css.FontFace(
            font_family=data['fontFamily'],
            font_style=data['fontStyle'],
            font_variant=data['fontVariant'],
            font_weight=data['fontWeight'],
            font_stretch=data['fontStretch'],
            font_display=data['fontDisplay'],
            unicode_range=data['unicodeRange'],
            src=data['src'],
            platform_font_family=data['platformFontFamily'],
            font_variation_axes=[
                from_dict(css.FontVariationAxis, item, casing_strategy)
                for item in data.get('fontVariationAxes', [])
            ]
        )

    if casing_strategy == 'pascal':
        return css.FontFace(
            font_family=data['FontFamily'],
            font_style=data['FontStyle'],
            font_variant=data['FontVariant'],
            font_weight=data['FontWeight'],
            font_stretch=data['FontStretch'],
            font_display=data['FontDisplay'],
            unicode_range=data['UnicodeRange'],
            src=data['Src'],
            platform_font_family=data['PlatformFontFamily'],
            font_variation_axes=[
                from_dict(css.FontVariationAxis, item, casing_strategy)
                for item in data.get('FontVariationAxes', [])
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_try_rule__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.CSSTryRule':

    if casing_strategy == 'snake':
        return css.CSSTryRule(
            style_sheet_id=data.get('style_sheet_id', None),
            origin=data['origin'],
            style=from_dict(
                css.CSSStyle,
                data['style'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return css.CSSTryRule(
            style_sheet_id=data.get('styleSheetId', None),
            origin=data['origin'],
            style=from_dict(
                css.CSSStyle,
                data['style'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return css.CSSTryRule(
            style_sheet_id=data.get('StyleSheetId', None),
            origin=data['Origin'],
            style=from_dict(
                css.CSSStyle,
                data['Style'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_position_fallback_rule__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.CSSPositionFallbackRule':

    if casing_strategy == 'snake':
        return css.CSSPositionFallbackRule(
            name=from_dict(
                css.Value,
                data['name'],
                casing_strategy
            ),
            try_rules=[
                from_dict(css.CSSTryRule, item, casing_strategy)
                for item in data['try_rules']
            ]
        )

    if casing_strategy == 'camel':
        return css.CSSPositionFallbackRule(
            name=from_dict(
                css.Value,
                data['name'],
                casing_strategy
            ),
            try_rules=[
                from_dict(css.CSSTryRule, item, casing_strategy)
                for item in data['tryRules']
            ]
        )

    if casing_strategy == 'pascal':
        return css.CSSPositionFallbackRule(
            name=from_dict(
                css.Value,
                data['Name'],
                casing_strategy
            ),
            try_rules=[
                from_dict(css.CSSTryRule, item, casing_strategy)
                for item in data['TryRules']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_keyframes_rule__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.CSSKeyframesRule':

    if casing_strategy == 'snake':
        return css.CSSKeyframesRule(
            animation_name=from_dict(
                css.Value,
                data['animation_name'],
                casing_strategy
            ),
            keyframes=[
                from_dict(css.CSSKeyframeRule, item, casing_strategy)
                for item in data['keyframes']
            ]
        )

    if casing_strategy == 'camel':
        return css.CSSKeyframesRule(
            animation_name=from_dict(
                css.Value,
                data['animationName'],
                casing_strategy
            ),
            keyframes=[
                from_dict(css.CSSKeyframeRule, item, casing_strategy)
                for item in data['keyframes']
            ]
        )

    if casing_strategy == 'pascal':
        return css.CSSKeyframesRule(
            animation_name=from_dict(
                css.Value,
                data['AnimationName'],
                casing_strategy
            ),
            keyframes=[
                from_dict(css.CSSKeyframeRule, item, casing_strategy)
                for item in data['Keyframes']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_property_registration__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.CSSPropertyRegistration':

    if casing_strategy == 'snake':
        return css.CSSPropertyRegistration(
            property_name=data['property_name'],
            initial_value=from_dict(
                css.Value,
                data.get('initial_value', None),
                casing_strategy
            ),
            inherits=data['inherits'],
            syntax=data['syntax']
        )

    if casing_strategy == 'camel':
        return css.CSSPropertyRegistration(
            property_name=data['propertyName'],
            initial_value=from_dict(
                css.Value,
                data.get('initialValue', None),
                casing_strategy
            ),
            inherits=data['inherits'],
            syntax=data['syntax']
        )

    if casing_strategy == 'pascal':
        return css.CSSPropertyRegistration(
            property_name=data['PropertyName'],
            initial_value=from_dict(
                css.Value,
                data.get('InitialValue', None),
                casing_strategy
            ),
            inherits=data['Inherits'],
            syntax=data['Syntax']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_property_rule__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.CSSPropertyRule':

    if casing_strategy == 'snake':
        return css.CSSPropertyRule(
            style_sheet_id=data.get('style_sheet_id', None),
            origin=data['origin'],
            property_name=from_dict(
                css.Value,
                data['property_name'],
                casing_strategy
            ),
            style=from_dict(
                css.CSSStyle,
                data['style'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return css.CSSPropertyRule(
            style_sheet_id=data.get('styleSheetId', None),
            origin=data['origin'],
            property_name=from_dict(
                css.Value,
                data['propertyName'],
                casing_strategy
            ),
            style=from_dict(
                css.CSSStyle,
                data['style'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return css.CSSPropertyRule(
            style_sheet_id=data.get('StyleSheetId', None),
            origin=data['Origin'],
            property_name=from_dict(
                css.Value,
                data['PropertyName'],
                casing_strategy
            ),
            style=from_dict(
                css.CSSStyle,
                data['Style'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__css_keyframe_rule__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.CSSKeyframeRule':

    if casing_strategy == 'snake':
        return css.CSSKeyframeRule(
            style_sheet_id=data.get('style_sheet_id', None),
            origin=data['origin'],
            key_text=from_dict(
                css.Value,
                data['key_text'],
                casing_strategy
            ),
            style=from_dict(
                css.CSSStyle,
                data['style'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return css.CSSKeyframeRule(
            style_sheet_id=data.get('styleSheetId', None),
            origin=data['origin'],
            key_text=from_dict(
                css.Value,
                data['keyText'],
                casing_strategy
            ),
            style=from_dict(
                css.CSSStyle,
                data['style'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return css.CSSKeyframeRule(
            style_sheet_id=data.get('StyleSheetId', None),
            origin=data['Origin'],
            key_text=from_dict(
                css.Value,
                data['KeyText'],
                casing_strategy
            ),
            style=from_dict(
                css.CSSStyle,
                data['Style'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__style_declaration_edit__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.StyleDeclarationEdit':

    if casing_strategy == 'snake':
        return css.StyleDeclarationEdit(
            style_sheet_id=data['style_sheet_id'],
            range=from_dict(
                css.SourceRange,
                data['range'],
                casing_strategy
            ),
            text=data['text']
        )

    if casing_strategy == 'camel':
        return css.StyleDeclarationEdit(
            style_sheet_id=data['styleSheetId'],
            range=from_dict(
                css.SourceRange,
                data['range'],
                casing_strategy
            ),
            text=data['text']
        )

    if casing_strategy == 'pascal':
        return css.StyleDeclarationEdit(
            style_sheet_id=data['StyleSheetId'],
            range=from_dict(
                css.SourceRange,
                data['Range'],
                casing_strategy
            ),
            text=data['Text']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _cache_storage__data_entry__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'cache_storage.DataEntry':

    if casing_strategy == 'snake':
        return cache_storage.DataEntry(
            request_url=data['request_url'],
            request_method=data['request_method'],
            request_headers=[
                from_dict(cache_storage.Header, item, casing_strategy)
                for item in data['request_headers']
            ],
            response_time=data['response_time'],
            response_status=data['response_status'],
            response_status_text=data['response_status_text'],
            response_type=data['response_type'],
            response_headers=[
                from_dict(cache_storage.Header, item, casing_strategy)
                for item in data['response_headers']
            ]
        )

    if casing_strategy == 'camel':
        return cache_storage.DataEntry(
            request_url=data['requestURL'],
            request_method=data['requestMethod'],
            request_headers=[
                from_dict(cache_storage.Header, item, casing_strategy)
                for item in data['requestHeaders']
            ],
            response_time=data['responseTime'],
            response_status=data['responseStatus'],
            response_status_text=data['responseStatusText'],
            response_type=data['responseType'],
            response_headers=[
                from_dict(cache_storage.Header, item, casing_strategy)
                for item in data['responseHeaders']
            ]
        )

    if casing_strategy == 'pascal':
        return cache_storage.DataEntry(
            request_url=data['RequestURL'],
            request_method=data['RequestMethod'],
            request_headers=[
                from_dict(cache_storage.Header, item, casing_strategy)
                for item in data['RequestHeaders']
            ],
            response_time=data['ResponseTime'],
            response_status=data['ResponseStatus'],
            response_status_text=data['ResponseStatusText'],
            response_type=data['ResponseType'],
            response_headers=[
                from_dict(cache_storage.Header, item, casing_strategy)
                for item in data['ResponseHeaders']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _cache_storage__cache__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'cache_storage.Cache':

    if casing_strategy == 'snake':
        return cache_storage.Cache(
            cache_id=data['cache_id'],
            security_origin=data['security_origin'],
            storage_key=data['storage_key'],
            storage_bucket=from_dict(
                cache_storage.StorageBucket,
                data.get('storage_bucket', None),
                casing_strategy
            ),
            cache_name=data['cache_name']
        )

    if casing_strategy == 'camel':
        return cache_storage.Cache(
            cache_id=data['cacheId'],
            security_origin=data['securityOrigin'],
            storage_key=data['storageKey'],
            storage_bucket=from_dict(
                cache_storage.StorageBucket,
                data.get('storageBucket', None),
                casing_strategy
            ),
            cache_name=data['cacheName']
        )

    if casing_strategy == 'pascal':
        return cache_storage.Cache(
            cache_id=data['CacheId'],
            security_origin=data['SecurityOrigin'],
            storage_key=data['StorageKey'],
            storage_bucket=from_dict(
                cache_storage.StorageBucket,
                data.get('StorageBucket', None),
                casing_strategy
            ),
            cache_name=data['CacheName']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _cache_storage__header__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'cache_storage.Header':

    if casing_strategy == 'snake':
        return cache_storage.Header(
            name=data['name'],
            value=data['value']
        )

    if casing_strategy == 'camel':
        return cache_storage.Header(
            name=data['name'],
            value=data['value']
        )

    if casing_strategy == 'pascal':
        return cache_storage.Header(
            name=data['Name'],
            value=data['Value']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _cache_storage__cached_response__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'cache_storage.CachedResponse':

    if casing_strategy == 'snake':
        return cache_storage.CachedResponse(
            body=data['body']
        )

    if casing_strategy == 'camel':
        return cache_storage.CachedResponse(
            body=data['body']
        )

    if casing_strategy == 'pascal':
        return cache_storage.CachedResponse(
            body=data['Body']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _cast__sink__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'cast.Sink':

    if casing_strategy == 'snake':
        return cast.Sink(
            name=data['name'],
            id=data['id'],
            session=data.get('session', None)
        )

    if casing_strategy == 'camel':
        return cast.Sink(
            name=data['name'],
            id=data['id'],
            session=data.get('session', None)
        )

    if casing_strategy == 'pascal':
        return cast.Sink(
            name=data['Name'],
            id=data['Id'],
            session=data.get('Session', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__backend_node__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.BackendNode':

    if casing_strategy == 'snake':
        return dom.BackendNode(
            node_type=data['node_type'],
            node_name=data['node_name'],
            backend_node_id=data['backend_node_id']
        )

    if casing_strategy == 'camel':
        return dom.BackendNode(
            node_type=data['nodeType'],
            node_name=data['nodeName'],
            backend_node_id=data['backendNodeId']
        )

    if casing_strategy == 'pascal':
        return dom.BackendNode(
            node_type=data['NodeType'],
            node_name=data['NodeName'],
            backend_node_id=data['BackendNodeId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__node__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.Node':

    if casing_strategy == 'snake':
        return dom.Node(
            node_id=data['node_id'],
            parent_id=data.get('parent_id', None),
            backend_node_id=data['backend_node_id'],
            node_type=data['node_type'],
            node_name=data['node_name'],
            local_name=data['local_name'],
            node_value=data['node_value'],
            child_node_count=data.get('child_node_count', None),
            children=[
                from_dict(dom.Node, item, casing_strategy)
                for item in data.get('children', [])
            ],
            attributes=data.get('attributes', []),
            document_url=data.get('document_url', None),
            base_url=data.get('base_url', None),
            public_id=data.get('public_id', None),
            system_id=data.get('system_id', None),
            internal_subset=data.get('internal_subset', None),
            xml_version=data.get('xml_version', None),
            name=data.get('name', None),
            value=data.get('value', None),
            pseudo_type=data.get('pseudo_type', None),
            pseudo_identifier=data.get('pseudo_identifier', None),
            shadow_root_type=data.get('shadow_root_type', None),
            frame_id=data.get('frame_id', None),
            content_document=from_dict(
                dom.Node,
                data.get('content_document', None),
                casing_strategy
            ),
            shadow_roots=[
                from_dict(dom.Node, item, casing_strategy)
                for item in data.get('shadow_roots', [])
            ],
            template_content=from_dict(
                dom.Node,
                data.get('template_content', None),
                casing_strategy
            ),
            pseudo_elements=[
                from_dict(dom.Node, item, casing_strategy)
                for item in data.get('pseudo_elements', [])
            ],
            imported_document=from_dict(
                dom.Node,
                data.get('imported_document', None),
                casing_strategy
            ),
            distributed_nodes=[
                from_dict(dom.BackendNode, item, casing_strategy)
                for item in data.get('distributed_nodes', [])
            ],
            is_svg=data.get('is_svg', None),
            compatibility_mode=data.get('compatibility_mode', None),
            assigned_slot=from_dict(
                dom.BackendNode,
                data.get('assigned_slot', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return dom.Node(
            node_id=data['nodeId'],
            parent_id=data.get('parentId', None),
            backend_node_id=data['backendNodeId'],
            node_type=data['nodeType'],
            node_name=data['nodeName'],
            local_name=data['localName'],
            node_value=data['nodeValue'],
            child_node_count=data.get('childNodeCount', None),
            children=[
                from_dict(dom.Node, item, casing_strategy)
                for item in data.get('children', [])
            ],
            attributes=data.get('attributes', []),
            document_url=data.get('documentURL', None),
            base_url=data.get('baseURL', None),
            public_id=data.get('publicId', None),
            system_id=data.get('systemId', None),
            internal_subset=data.get('internalSubset', None),
            xml_version=data.get('xmlVersion', None),
            name=data.get('name', None),
            value=data.get('value', None),
            pseudo_type=data.get('pseudoType', None),
            pseudo_identifier=data.get('pseudoIdentifier', None),
            shadow_root_type=data.get('shadowRootType', None),
            frame_id=data.get('frameId', None),
            content_document=from_dict(
                dom.Node,
                data.get('contentDocument', None),
                casing_strategy
            ),
            shadow_roots=[
                from_dict(dom.Node, item, casing_strategy)
                for item in data.get('shadowRoots', [])
            ],
            template_content=from_dict(
                dom.Node,
                data.get('templateContent', None),
                casing_strategy
            ),
            pseudo_elements=[
                from_dict(dom.Node, item, casing_strategy)
                for item in data.get('pseudoElements', [])
            ],
            imported_document=from_dict(
                dom.Node,
                data.get('importedDocument', None),
                casing_strategy
            ),
            distributed_nodes=[
                from_dict(dom.BackendNode, item, casing_strategy)
                for item in data.get('distributedNodes', [])
            ],
            is_svg=data.get('isSVG', None),
            compatibility_mode=data.get('compatibilityMode', None),
            assigned_slot=from_dict(
                dom.BackendNode,
                data.get('assignedSlot', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return dom.Node(
            node_id=data['NodeId'],
            parent_id=data.get('ParentId', None),
            backend_node_id=data['BackendNodeId'],
            node_type=data['NodeType'],
            node_name=data['NodeName'],
            local_name=data['LocalName'],
            node_value=data['NodeValue'],
            child_node_count=data.get('ChildNodeCount', None),
            children=[
                from_dict(dom.Node, item, casing_strategy)
                for item in data.get('Children', [])
            ],
            attributes=data.get('Attributes', []),
            document_url=data.get('DocumentURL', None),
            base_url=data.get('BaseURL', None),
            public_id=data.get('PublicId', None),
            system_id=data.get('SystemId', None),
            internal_subset=data.get('InternalSubset', None),
            xml_version=data.get('XmlVersion', None),
            name=data.get('Name', None),
            value=data.get('Value', None),
            pseudo_type=data.get('PseudoType', None),
            pseudo_identifier=data.get('PseudoIdentifier', None),
            shadow_root_type=data.get('ShadowRootType', None),
            frame_id=data.get('FrameId', None),
            content_document=from_dict(
                dom.Node,
                data.get('ContentDocument', None),
                casing_strategy
            ),
            shadow_roots=[
                from_dict(dom.Node, item, casing_strategy)
                for item in data.get('ShadowRoots', [])
            ],
            template_content=from_dict(
                dom.Node,
                data.get('TemplateContent', None),
                casing_strategy
            ),
            pseudo_elements=[
                from_dict(dom.Node, item, casing_strategy)
                for item in data.get('PseudoElements', [])
            ],
            imported_document=from_dict(
                dom.Node,
                data.get('ImportedDocument', None),
                casing_strategy
            ),
            distributed_nodes=[
                from_dict(dom.BackendNode, item, casing_strategy)
                for item in data.get('DistributedNodes', [])
            ],
            is_svg=data.get('IsSVG', None),
            compatibility_mode=data.get('CompatibilityMode', None),
            assigned_slot=from_dict(
                dom.BackendNode,
                data.get('AssignedSlot', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__rgba__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.RGBA':

    if casing_strategy == 'snake':
        return dom.RGBA(
            r=data['r'],
            g=data['g'],
            b=data['b'],
            a=data.get('a', None)
        )

    if casing_strategy == 'camel':
        return dom.RGBA(
            r=data['r'],
            g=data['g'],
            b=data['b'],
            a=data.get('a', None)
        )

    if casing_strategy == 'pascal':
        return dom.RGBA(
            r=data['R'],
            g=data['G'],
            b=data['B'],
            a=data.get('A', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__box_model__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.BoxModel':

    if casing_strategy == 'snake':
        return dom.BoxModel(
            content=data['content'],
            padding=data['padding'],
            border=data['border'],
            margin=data['margin'],
            width=data['width'],
            height=data['height'],
            shape_outside=from_dict(
                dom.ShapeOutsideInfo,
                data.get('shape_outside', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return dom.BoxModel(
            content=data['content'],
            padding=data['padding'],
            border=data['border'],
            margin=data['margin'],
            width=data['width'],
            height=data['height'],
            shape_outside=from_dict(
                dom.ShapeOutsideInfo,
                data.get('shapeOutside', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return dom.BoxModel(
            content=data['Content'],
            padding=data['Padding'],
            border=data['Border'],
            margin=data['Margin'],
            width=data['Width'],
            height=data['Height'],
            shape_outside=from_dict(
                dom.ShapeOutsideInfo,
                data.get('ShapeOutside', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__shape_outside_info__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.ShapeOutsideInfo':

    if casing_strategy == 'snake':
        return dom.ShapeOutsideInfo(
            bounds=data['bounds'],
            shape=data['shape'],
            margin_shape=data['margin_shape']
        )

    if casing_strategy == 'camel':
        return dom.ShapeOutsideInfo(
            bounds=data['bounds'],
            shape=data['shape'],
            margin_shape=data['marginShape']
        )

    if casing_strategy == 'pascal':
        return dom.ShapeOutsideInfo(
            bounds=data['Bounds'],
            shape=data['Shape'],
            margin_shape=data['MarginShape']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__rect__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.Rect':

    if casing_strategy == 'snake':
        return dom.Rect(
            x=data['x'],
            y=data['y'],
            width=data['width'],
            height=data['height']
        )

    if casing_strategy == 'camel':
        return dom.Rect(
            x=data['x'],
            y=data['y'],
            width=data['width'],
            height=data['height']
        )

    if casing_strategy == 'pascal':
        return dom.Rect(
            x=data['X'],
            y=data['Y'],
            width=data['Width'],
            height=data['Height']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__css_computed_style_property__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.CSSComputedStyleProperty':

    if casing_strategy == 'snake':
        return dom.CSSComputedStyleProperty(
            name=data['name'],
            value=data['value']
        )

    if casing_strategy == 'camel':
        return dom.CSSComputedStyleProperty(
            name=data['name'],
            value=data['value']
        )

    if casing_strategy == 'pascal':
        return dom.CSSComputedStyleProperty(
            name=data['Name'],
            value=data['Value']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_debugger__event_listener__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom_debugger.EventListener':

    if casing_strategy == 'snake':
        return dom_debugger.EventListener(
            type=data['type'],
            use_capture=data['use_capture'],
            passive=data['passive'],
            once=data['once'],
            script_id=data['script_id'],
            line_number=data['line_number'],
            column_number=data['column_number'],
            handler=from_dict(
                dom_debugger.RemoteObject,
                data.get('handler', None),
                casing_strategy
            ),
            original_handler=from_dict(
                dom_debugger.RemoteObject,
                data.get('original_handler', None),
                casing_strategy
            ),
            backend_node_id=data.get('backend_node_id', None)
        )

    if casing_strategy == 'camel':
        return dom_debugger.EventListener(
            type=data['type'],
            use_capture=data['useCapture'],
            passive=data['passive'],
            once=data['once'],
            script_id=data['scriptId'],
            line_number=data['lineNumber'],
            column_number=data['columnNumber'],
            handler=from_dict(
                dom_debugger.RemoteObject,
                data.get('handler', None),
                casing_strategy
            ),
            original_handler=from_dict(
                dom_debugger.RemoteObject,
                data.get('originalHandler', None),
                casing_strategy
            ),
            backend_node_id=data.get('backendNodeId', None)
        )

    if casing_strategy == 'pascal':
        return dom_debugger.EventListener(
            type=data['Type'],
            use_capture=data['UseCapture'],
            passive=data['Passive'],
            once=data['Once'],
            script_id=data['ScriptId'],
            line_number=data['LineNumber'],
            column_number=data['ColumnNumber'],
            handler=from_dict(
                dom_debugger.RemoteObject,
                data.get('Handler', None),
                casing_strategy
            ),
            original_handler=from_dict(
                dom_debugger.RemoteObject,
                data.get('OriginalHandler', None),
                casing_strategy
            ),
            backend_node_id=data.get('BackendNodeId', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__dom_node__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom_snapshot.DOMNode':

    if casing_strategy == 'snake':
        return dom_snapshot.DOMNode(
            node_type=data['node_type'],
            node_name=data['node_name'],
            node_value=data['node_value'],
            text_value=data.get('text_value', None),
            input_value=data.get('input_value', None),
            input_checked=data.get('input_checked', None),
            option_selected=data.get('option_selected', None),
            backend_node_id=data['backend_node_id'],
            child_node_indexes=data.get('child_node_indexes', []),
            attributes=[
                from_dict(dom_snapshot.NameValue, item, casing_strategy)
                for item in data.get('attributes', [])
            ],
            pseudo_element_indexes=data.get('pseudo_element_indexes', []),
            layout_node_index=data.get('layout_node_index', None),
            document_url=data.get('document_url', None),
            base_url=data.get('base_url', None),
            content_language=data.get('content_language', None),
            document_encoding=data.get('document_encoding', None),
            public_id=data.get('public_id', None),
            system_id=data.get('system_id', None),
            frame_id=data.get('frame_id', None),
            content_document_index=data.get('content_document_index', None),
            pseudo_type=data.get('pseudo_type', None),
            shadow_root_type=data.get('shadow_root_type', None),
            is_clickable=data.get('is_clickable', None),
            event_listeners=[
                from_dict(dom_snapshot.EventListener, item, casing_strategy)
                for item in data.get('event_listeners', [])
            ],
            current_source_url=data.get('current_source_url', None),
            origin_url=data.get('origin_url', None),
            scroll_offset_x=data.get('scroll_offset_x', None),
            scroll_offset_y=data.get('scroll_offset_y', None)
        )

    if casing_strategy == 'camel':
        return dom_snapshot.DOMNode(
            node_type=data['nodeType'],
            node_name=data['nodeName'],
            node_value=data['nodeValue'],
            text_value=data.get('textValue', None),
            input_value=data.get('inputValue', None),
            input_checked=data.get('inputChecked', None),
            option_selected=data.get('optionSelected', None),
            backend_node_id=data['backendNodeId'],
            child_node_indexes=data.get('childNodeIndexes', []),
            attributes=[
                from_dict(dom_snapshot.NameValue, item, casing_strategy)
                for item in data.get('attributes', [])
            ],
            pseudo_element_indexes=data.get('pseudoElementIndexes', []),
            layout_node_index=data.get('layoutNodeIndex', None),
            document_url=data.get('documentURL', None),
            base_url=data.get('baseURL', None),
            content_language=data.get('contentLanguage', None),
            document_encoding=data.get('documentEncoding', None),
            public_id=data.get('publicId', None),
            system_id=data.get('systemId', None),
            frame_id=data.get('frameId', None),
            content_document_index=data.get('contentDocumentIndex', None),
            pseudo_type=data.get('pseudoType', None),
            shadow_root_type=data.get('shadowRootType', None),
            is_clickable=data.get('isClickable', None),
            event_listeners=[
                from_dict(dom_snapshot.EventListener, item, casing_strategy)
                for item in data.get('eventListeners', [])
            ],
            current_source_url=data.get('currentSourceURL', None),
            origin_url=data.get('originURL', None),
            scroll_offset_x=data.get('scrollOffsetX', None),
            scroll_offset_y=data.get('scrollOffsetY', None)
        )

    if casing_strategy == 'pascal':
        return dom_snapshot.DOMNode(
            node_type=data['NodeType'],
            node_name=data['NodeName'],
            node_value=data['NodeValue'],
            text_value=data.get('TextValue', None),
            input_value=data.get('InputValue', None),
            input_checked=data.get('InputChecked', None),
            option_selected=data.get('OptionSelected', None),
            backend_node_id=data['BackendNodeId'],
            child_node_indexes=data.get('ChildNodeIndexes', []),
            attributes=[
                from_dict(dom_snapshot.NameValue, item, casing_strategy)
                for item in data.get('Attributes', [])
            ],
            pseudo_element_indexes=data.get('PseudoElementIndexes', []),
            layout_node_index=data.get('LayoutNodeIndex', None),
            document_url=data.get('DocumentURL', None),
            base_url=data.get('BaseURL', None),
            content_language=data.get('ContentLanguage', None),
            document_encoding=data.get('DocumentEncoding', None),
            public_id=data.get('PublicId', None),
            system_id=data.get('SystemId', None),
            frame_id=data.get('FrameId', None),
            content_document_index=data.get('ContentDocumentIndex', None),
            pseudo_type=data.get('PseudoType', None),
            shadow_root_type=data.get('ShadowRootType', None),
            is_clickable=data.get('IsClickable', None),
            event_listeners=[
                from_dict(dom_snapshot.EventListener, item, casing_strategy)
                for item in data.get('EventListeners', [])
            ],
            current_source_url=data.get('CurrentSourceURL', None),
            origin_url=data.get('OriginURL', None),
            scroll_offset_x=data.get('ScrollOffsetX', None),
            scroll_offset_y=data.get('ScrollOffsetY', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__inline_text_box__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom_snapshot.InlineTextBox':

    if casing_strategy == 'snake':
        return dom_snapshot.InlineTextBox(
            bounding_box=from_dict(
                dom_snapshot.Rect,
                data['bounding_box'],
                casing_strategy
            ),
            start_character_index=data['start_character_index'],
            num_characters=data['num_characters']
        )

    if casing_strategy == 'camel':
        return dom_snapshot.InlineTextBox(
            bounding_box=from_dict(
                dom_snapshot.Rect,
                data['boundingBox'],
                casing_strategy
            ),
            start_character_index=data['startCharacterIndex'],
            num_characters=data['numCharacters']
        )

    if casing_strategy == 'pascal':
        return dom_snapshot.InlineTextBox(
            bounding_box=from_dict(
                dom_snapshot.Rect,
                data['BoundingBox'],
                casing_strategy
            ),
            start_character_index=data['StartCharacterIndex'],
            num_characters=data['NumCharacters']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__layout_tree_node__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom_snapshot.LayoutTreeNode':

    if casing_strategy == 'snake':
        return dom_snapshot.LayoutTreeNode(
            dom_node_index=data['dom_node_index'],
            bounding_box=from_dict(
                dom_snapshot.Rect,
                data['bounding_box'],
                casing_strategy
            ),
            layout_text=data.get('layout_text', None),
            inline_text_nodes=[
                from_dict(dom_snapshot.InlineTextBox, item, casing_strategy)
                for item in data.get('inline_text_nodes', [])
            ],
            style_index=data.get('style_index', None),
            paint_order=data.get('paint_order', None),
            is_stacking_context=data.get('is_stacking_context', None)
        )

    if casing_strategy == 'camel':
        return dom_snapshot.LayoutTreeNode(
            dom_node_index=data['domNodeIndex'],
            bounding_box=from_dict(
                dom_snapshot.Rect,
                data['boundingBox'],
                casing_strategy
            ),
            layout_text=data.get('layoutText', None),
            inline_text_nodes=[
                from_dict(dom_snapshot.InlineTextBox, item, casing_strategy)
                for item in data.get('inlineTextNodes', [])
            ],
            style_index=data.get('styleIndex', None),
            paint_order=data.get('paintOrder', None),
            is_stacking_context=data.get('isStackingContext', None)
        )

    if casing_strategy == 'pascal':
        return dom_snapshot.LayoutTreeNode(
            dom_node_index=data['DomNodeIndex'],
            bounding_box=from_dict(
                dom_snapshot.Rect,
                data['BoundingBox'],
                casing_strategy
            ),
            layout_text=data.get('LayoutText', None),
            inline_text_nodes=[
                from_dict(dom_snapshot.InlineTextBox, item, casing_strategy)
                for item in data.get('InlineTextNodes', [])
            ],
            style_index=data.get('StyleIndex', None),
            paint_order=data.get('PaintOrder', None),
            is_stacking_context=data.get('IsStackingContext', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__computed_style__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom_snapshot.ComputedStyle':

    if casing_strategy == 'snake':
        return dom_snapshot.ComputedStyle(
            properties=[
                from_dict(dom_snapshot.NameValue, item, casing_strategy)
                for item in data['properties']
            ]
        )

    if casing_strategy == 'camel':
        return dom_snapshot.ComputedStyle(
            properties=[
                from_dict(dom_snapshot.NameValue, item, casing_strategy)
                for item in data['properties']
            ]
        )

    if casing_strategy == 'pascal':
        return dom_snapshot.ComputedStyle(
            properties=[
                from_dict(dom_snapshot.NameValue, item, casing_strategy)
                for item in data['Properties']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__name_value__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom_snapshot.NameValue':

    if casing_strategy == 'snake':
        return dom_snapshot.NameValue(
            name=data['name'],
            value=data['value']
        )

    if casing_strategy == 'camel':
        return dom_snapshot.NameValue(
            name=data['name'],
            value=data['value']
        )

    if casing_strategy == 'pascal':
        return dom_snapshot.NameValue(
            name=data['Name'],
            value=data['Value']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__rare_string_data__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom_snapshot.RareStringData':

    if casing_strategy == 'snake':
        return dom_snapshot.RareStringData(
            index=data['index'],
            value=data['value']
        )

    if casing_strategy == 'camel':
        return dom_snapshot.RareStringData(
            index=data['index'],
            value=data['value']
        )

    if casing_strategy == 'pascal':
        return dom_snapshot.RareStringData(
            index=data['Index'],
            value=data['Value']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__rare_boolean_data__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom_snapshot.RareBooleanData':

    if casing_strategy == 'snake':
        return dom_snapshot.RareBooleanData(
            index=data['index']
        )

    if casing_strategy == 'camel':
        return dom_snapshot.RareBooleanData(
            index=data['index']
        )

    if casing_strategy == 'pascal':
        return dom_snapshot.RareBooleanData(
            index=data['Index']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__rare_integer_data__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom_snapshot.RareIntegerData':

    if casing_strategy == 'snake':
        return dom_snapshot.RareIntegerData(
            index=data['index'],
            value=data['value']
        )

    if casing_strategy == 'camel':
        return dom_snapshot.RareIntegerData(
            index=data['index'],
            value=data['value']
        )

    if casing_strategy == 'pascal':
        return dom_snapshot.RareIntegerData(
            index=data['Index'],
            value=data['Value']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__document_snapshot__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom_snapshot.DocumentSnapshot':

    if casing_strategy == 'snake':
        return dom_snapshot.DocumentSnapshot(
            document_url=data['document_url'],
            title=data['title'],
            base_url=data['base_url'],
            content_language=data['content_language'],
            encoding_name=data['encoding_name'],
            public_id=data['public_id'],
            system_id=data['system_id'],
            frame_id=data['frame_id'],
            nodes=from_dict(
                dom_snapshot.NodeTreeSnapshot,
                data['nodes'],
                casing_strategy
            ),
            layout=from_dict(
                dom_snapshot.LayoutTreeSnapshot,
                data['layout'],
                casing_strategy
            ),
            text_boxes=from_dict(
                dom_snapshot.TextBoxSnapshot,
                data['text_boxes'],
                casing_strategy
            ),
            scroll_offset_x=data.get('scroll_offset_x', None),
            scroll_offset_y=data.get('scroll_offset_y', None),
            content_width=data.get('content_width', None),
            content_height=data.get('content_height', None)
        )

    if casing_strategy == 'camel':
        return dom_snapshot.DocumentSnapshot(
            document_url=data['documentURL'],
            title=data['title'],
            base_url=data['baseURL'],
            content_language=data['contentLanguage'],
            encoding_name=data['encodingName'],
            public_id=data['publicId'],
            system_id=data['systemId'],
            frame_id=data['frameId'],
            nodes=from_dict(
                dom_snapshot.NodeTreeSnapshot,
                data['nodes'],
                casing_strategy
            ),
            layout=from_dict(
                dom_snapshot.LayoutTreeSnapshot,
                data['layout'],
                casing_strategy
            ),
            text_boxes=from_dict(
                dom_snapshot.TextBoxSnapshot,
                data['textBoxes'],
                casing_strategy
            ),
            scroll_offset_x=data.get('scrollOffsetX', None),
            scroll_offset_y=data.get('scrollOffsetY', None),
            content_width=data.get('contentWidth', None),
            content_height=data.get('contentHeight', None)
        )

    if casing_strategy == 'pascal':
        return dom_snapshot.DocumentSnapshot(
            document_url=data['DocumentURL'],
            title=data['Title'],
            base_url=data['BaseURL'],
            content_language=data['ContentLanguage'],
            encoding_name=data['EncodingName'],
            public_id=data['PublicId'],
            system_id=data['SystemId'],
            frame_id=data['FrameId'],
            nodes=from_dict(
                dom_snapshot.NodeTreeSnapshot,
                data['Nodes'],
                casing_strategy
            ),
            layout=from_dict(
                dom_snapshot.LayoutTreeSnapshot,
                data['Layout'],
                casing_strategy
            ),
            text_boxes=from_dict(
                dom_snapshot.TextBoxSnapshot,
                data['TextBoxes'],
                casing_strategy
            ),
            scroll_offset_x=data.get('ScrollOffsetX', None),
            scroll_offset_y=data.get('ScrollOffsetY', None),
            content_width=data.get('ContentWidth', None),
            content_height=data.get('ContentHeight', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__node_tree_snapshot__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom_snapshot.NodeTreeSnapshot':

    if casing_strategy == 'snake':
        return dom_snapshot.NodeTreeSnapshot(
            parent_index=data.get('parent_index', []),
            node_type=data.get('node_type', []),
            shadow_root_type=from_dict(
                dom_snapshot.RareStringData,
                data.get('shadow_root_type', None),
                casing_strategy
            ),
            node_name=data.get('node_name', []),
            node_value=data.get('node_value', []),
            backend_node_id=data.get('backend_node_id', []),
            attributes=data.get('attributes', []),
            text_value=from_dict(
                dom_snapshot.RareStringData,
                data.get('text_value', None),
                casing_strategy
            ),
            input_value=from_dict(
                dom_snapshot.RareStringData,
                data.get('input_value', None),
                casing_strategy
            ),
            input_checked=from_dict(
                dom_snapshot.RareBooleanData,
                data.get('input_checked', None),
                casing_strategy
            ),
            option_selected=from_dict(
                dom_snapshot.RareBooleanData,
                data.get('option_selected', None),
                casing_strategy
            ),
            content_document_index=from_dict(
                dom_snapshot.RareIntegerData,
                data.get('content_document_index', None),
                casing_strategy
            ),
            pseudo_type=from_dict(
                dom_snapshot.RareStringData,
                data.get('pseudo_type', None),
                casing_strategy
            ),
            pseudo_identifier=from_dict(
                dom_snapshot.RareStringData,
                data.get('pseudo_identifier', None),
                casing_strategy
            ),
            is_clickable=from_dict(
                dom_snapshot.RareBooleanData,
                data.get('is_clickable', None),
                casing_strategy
            ),
            current_source_url=from_dict(
                dom_snapshot.RareStringData,
                data.get('current_source_url', None),
                casing_strategy
            ),
            origin_url=from_dict(
                dom_snapshot.RareStringData,
                data.get('origin_url', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return dom_snapshot.NodeTreeSnapshot(
            parent_index=data.get('parentIndex', []),
            node_type=data.get('nodeType', []),
            shadow_root_type=from_dict(
                dom_snapshot.RareStringData,
                data.get('shadowRootType', None),
                casing_strategy
            ),
            node_name=data.get('nodeName', []),
            node_value=data.get('nodeValue', []),
            backend_node_id=data.get('backendNodeId', []),
            attributes=data.get('attributes', []),
            text_value=from_dict(
                dom_snapshot.RareStringData,
                data.get('textValue', None),
                casing_strategy
            ),
            input_value=from_dict(
                dom_snapshot.RareStringData,
                data.get('inputValue', None),
                casing_strategy
            ),
            input_checked=from_dict(
                dom_snapshot.RareBooleanData,
                data.get('inputChecked', None),
                casing_strategy
            ),
            option_selected=from_dict(
                dom_snapshot.RareBooleanData,
                data.get('optionSelected', None),
                casing_strategy
            ),
            content_document_index=from_dict(
                dom_snapshot.RareIntegerData,
                data.get('contentDocumentIndex', None),
                casing_strategy
            ),
            pseudo_type=from_dict(
                dom_snapshot.RareStringData,
                data.get('pseudoType', None),
                casing_strategy
            ),
            pseudo_identifier=from_dict(
                dom_snapshot.RareStringData,
                data.get('pseudoIdentifier', None),
                casing_strategy
            ),
            is_clickable=from_dict(
                dom_snapshot.RareBooleanData,
                data.get('isClickable', None),
                casing_strategy
            ),
            current_source_url=from_dict(
                dom_snapshot.RareStringData,
                data.get('currentSourceURL', None),
                casing_strategy
            ),
            origin_url=from_dict(
                dom_snapshot.RareStringData,
                data.get('originURL', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return dom_snapshot.NodeTreeSnapshot(
            parent_index=data.get('ParentIndex', []),
            node_type=data.get('NodeType', []),
            shadow_root_type=from_dict(
                dom_snapshot.RareStringData,
                data.get('ShadowRootType', None),
                casing_strategy
            ),
            node_name=data.get('NodeName', []),
            node_value=data.get('NodeValue', []),
            backend_node_id=data.get('BackendNodeId', []),
            attributes=data.get('Attributes', []),
            text_value=from_dict(
                dom_snapshot.RareStringData,
                data.get('TextValue', None),
                casing_strategy
            ),
            input_value=from_dict(
                dom_snapshot.RareStringData,
                data.get('InputValue', None),
                casing_strategy
            ),
            input_checked=from_dict(
                dom_snapshot.RareBooleanData,
                data.get('InputChecked', None),
                casing_strategy
            ),
            option_selected=from_dict(
                dom_snapshot.RareBooleanData,
                data.get('OptionSelected', None),
                casing_strategy
            ),
            content_document_index=from_dict(
                dom_snapshot.RareIntegerData,
                data.get('ContentDocumentIndex', None),
                casing_strategy
            ),
            pseudo_type=from_dict(
                dom_snapshot.RareStringData,
                data.get('PseudoType', None),
                casing_strategy
            ),
            pseudo_identifier=from_dict(
                dom_snapshot.RareStringData,
                data.get('PseudoIdentifier', None),
                casing_strategy
            ),
            is_clickable=from_dict(
                dom_snapshot.RareBooleanData,
                data.get('IsClickable', None),
                casing_strategy
            ),
            current_source_url=from_dict(
                dom_snapshot.RareStringData,
                data.get('CurrentSourceURL', None),
                casing_strategy
            ),
            origin_url=from_dict(
                dom_snapshot.RareStringData,
                data.get('OriginURL', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__layout_tree_snapshot__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom_snapshot.LayoutTreeSnapshot':

    if casing_strategy == 'snake':
        return dom_snapshot.LayoutTreeSnapshot(
            node_index=data['node_index'],
            styles=data['styles'],
            bounds=data['bounds'],
            text=data['text'],
            stacking_contexts=from_dict(
                dom_snapshot.RareBooleanData,
                data['stacking_contexts'],
                casing_strategy
            ),
            paint_orders=data.get('paint_orders', []),
            offset_rects=data.get('offset_rects', []),
            scroll_rects=data.get('scroll_rects', []),
            client_rects=data.get('client_rects', []),
            blended_background_colors=data.get('blended_background_colors', []),
            text_color_opacities=data.get('text_color_opacities', [])
        )

    if casing_strategy == 'camel':
        return dom_snapshot.LayoutTreeSnapshot(
            node_index=data['nodeIndex'],
            styles=data['styles'],
            bounds=data['bounds'],
            text=data['text'],
            stacking_contexts=from_dict(
                dom_snapshot.RareBooleanData,
                data['stackingContexts'],
                casing_strategy
            ),
            paint_orders=data.get('paintOrders', []),
            offset_rects=data.get('offsetRects', []),
            scroll_rects=data.get('scrollRects', []),
            client_rects=data.get('clientRects', []),
            blended_background_colors=data.get('blendedBackgroundColors', []),
            text_color_opacities=data.get('textColorOpacities', [])
        )

    if casing_strategy == 'pascal':
        return dom_snapshot.LayoutTreeSnapshot(
            node_index=data['NodeIndex'],
            styles=data['Styles'],
            bounds=data['Bounds'],
            text=data['Text'],
            stacking_contexts=from_dict(
                dom_snapshot.RareBooleanData,
                data['StackingContexts'],
                casing_strategy
            ),
            paint_orders=data.get('PaintOrders', []),
            offset_rects=data.get('OffsetRects', []),
            scroll_rects=data.get('ScrollRects', []),
            client_rects=data.get('ClientRects', []),
            blended_background_colors=data.get('BlendedBackgroundColors', []),
            text_color_opacities=data.get('TextColorOpacities', [])
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__text_box_snapshot__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom_snapshot.TextBoxSnapshot':

    if casing_strategy == 'snake':
        return dom_snapshot.TextBoxSnapshot(
            layout_index=data['layout_index'],
            bounds=data['bounds'],
            start=data['start'],
            length=data['length']
        )

    if casing_strategy == 'camel':
        return dom_snapshot.TextBoxSnapshot(
            layout_index=data['layoutIndex'],
            bounds=data['bounds'],
            start=data['start'],
            length=data['length']
        )

    if casing_strategy == 'pascal':
        return dom_snapshot.TextBoxSnapshot(
            layout_index=data['LayoutIndex'],
            bounds=data['Bounds'],
            start=data['Start'],
            length=data['Length']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_storage__storage_id__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom_storage.StorageId':

    if casing_strategy == 'snake':
        return dom_storage.StorageId(
            security_origin=data.get('security_origin', None),
            storage_key=data.get('storage_key', None),
            is_local_storage=data['is_local_storage']
        )

    if casing_strategy == 'camel':
        return dom_storage.StorageId(
            security_origin=data.get('securityOrigin', None),
            storage_key=data.get('storageKey', None),
            is_local_storage=data['isLocalStorage']
        )

    if casing_strategy == 'pascal':
        return dom_storage.StorageId(
            security_origin=data.get('SecurityOrigin', None),
            storage_key=data.get('StorageKey', None),
            is_local_storage=data['IsLocalStorage']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _database__database__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'database.Database':

    if casing_strategy == 'snake':
        return database.Database(
            id=data['id'],
            domain=data['domain'],
            name=data['name'],
            version=data['version']
        )

    if casing_strategy == 'camel':
        return database.Database(
            id=data['id'],
            domain=data['domain'],
            name=data['name'],
            version=data['version']
        )

    if casing_strategy == 'pascal':
        return database.Database(
            id=data['Id'],
            domain=data['Domain'],
            name=data['Name'],
            version=data['Version']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _database__error__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'database.Error':

    if casing_strategy == 'snake':
        return database.Error(
            message=data['message'],
            code=data['code']
        )

    if casing_strategy == 'camel':
        return database.Error(
            message=data['message'],
            code=data['code']
        )

    if casing_strategy == 'pascal':
        return database.Error(
            message=data['Message'],
            code=data['Code']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _emulation__screen_orientation__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'emulation.ScreenOrientation':

    if casing_strategy == 'snake':
        return emulation.ScreenOrientation(
            type=data['type'],
            angle=data['angle']
        )

    if casing_strategy == 'camel':
        return emulation.ScreenOrientation(
            type=data['type'],
            angle=data['angle']
        )

    if casing_strategy == 'pascal':
        return emulation.ScreenOrientation(
            type=data['Type'],
            angle=data['Angle']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _emulation__display_feature__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'emulation.DisplayFeature':

    if casing_strategy == 'snake':
        return emulation.DisplayFeature(
            orientation=data['orientation'],
            offset=data['offset'],
            mask_length=data['mask_length']
        )

    if casing_strategy == 'camel':
        return emulation.DisplayFeature(
            orientation=data['orientation'],
            offset=data['offset'],
            mask_length=data['maskLength']
        )

    if casing_strategy == 'pascal':
        return emulation.DisplayFeature(
            orientation=data['Orientation'],
            offset=data['Offset'],
            mask_length=data['MaskLength']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _emulation__media_feature__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'emulation.MediaFeature':

    if casing_strategy == 'snake':
        return emulation.MediaFeature(
            name=data['name'],
            value=data['value']
        )

    if casing_strategy == 'camel':
        return emulation.MediaFeature(
            name=data['name'],
            value=data['value']
        )

    if casing_strategy == 'pascal':
        return emulation.MediaFeature(
            name=data['Name'],
            value=data['Value']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _emulation__user_agent_brand_version__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'emulation.UserAgentBrandVersion':

    if casing_strategy == 'snake':
        return emulation.UserAgentBrandVersion(
            brand=data['brand'],
            version=data['version']
        )

    if casing_strategy == 'camel':
        return emulation.UserAgentBrandVersion(
            brand=data['brand'],
            version=data['version']
        )

    if casing_strategy == 'pascal':
        return emulation.UserAgentBrandVersion(
            brand=data['Brand'],
            version=data['Version']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _emulation__user_agent_metadata__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'emulation.UserAgentMetadata':

    if casing_strategy == 'snake':
        return emulation.UserAgentMetadata(
            brands=[
                from_dict(emulation.UserAgentBrandVersion, item, casing_strategy)
                for item in data.get('brands', [])
            ],
            full_version_list=[
                from_dict(emulation.UserAgentBrandVersion, item, casing_strategy)
                for item in data.get('full_version_list', [])
            ],
            full_version=data.get('full_version', None),
            platform=data['platform'],
            platform_version=data['platform_version'],
            architecture=data['architecture'],
            model=data['model'],
            mobile=data['mobile'],
            bitness=data.get('bitness', None),
            wow64=data.get('wow64', None)
        )

    if casing_strategy == 'camel':
        return emulation.UserAgentMetadata(
            brands=[
                from_dict(emulation.UserAgentBrandVersion, item, casing_strategy)
                for item in data.get('brands', [])
            ],
            full_version_list=[
                from_dict(emulation.UserAgentBrandVersion, item, casing_strategy)
                for item in data.get('fullVersionList', [])
            ],
            full_version=data.get('fullVersion', None),
            platform=data['platform'],
            platform_version=data['platformVersion'],
            architecture=data['architecture'],
            model=data['model'],
            mobile=data['mobile'],
            bitness=data.get('bitness', None),
            wow64=data.get('wow64', None)
        )

    if casing_strategy == 'pascal':
        return emulation.UserAgentMetadata(
            brands=[
                from_dict(emulation.UserAgentBrandVersion, item, casing_strategy)
                for item in data.get('Brands', [])
            ],
            full_version_list=[
                from_dict(emulation.UserAgentBrandVersion, item, casing_strategy)
                for item in data.get('FullVersionList', [])
            ],
            full_version=data.get('FullVersion', None),
            platform=data['Platform'],
            platform_version=data['PlatformVersion'],
            architecture=data['Architecture'],
            model=data['Model'],
            mobile=data['Mobile'],
            bitness=data.get('Bitness', None),
            wow64=data.get('Wow64', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _headless_experimental__screenshot_params__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'headless_experimental.ScreenshotParams':

    if casing_strategy == 'snake':
        return headless_experimental.ScreenshotParams(
            format=data.get('format', None),
            quality=data.get('quality', None),
            optimize_for_speed=data.get('optimize_for_speed', None)
        )

    if casing_strategy == 'camel':
        return headless_experimental.ScreenshotParams(
            format=data.get('format', None),
            quality=data.get('quality', None),
            optimize_for_speed=data.get('optimizeForSpeed', None)
        )

    if casing_strategy == 'pascal':
        return headless_experimental.ScreenshotParams(
            format=data.get('Format', None),
            quality=data.get('Quality', None),
            optimize_for_speed=data.get('OptimizeForSpeed', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _indexed_db__database_with_object_stores__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'indexed_db.DatabaseWithObjectStores':

    if casing_strategy == 'snake':
        return indexed_db.DatabaseWithObjectStores(
            name=data['name'],
            version=data['version'],
            object_stores=[
                from_dict(indexed_db.ObjectStore, item, casing_strategy)
                for item in data['object_stores']
            ]
        )

    if casing_strategy == 'camel':
        return indexed_db.DatabaseWithObjectStores(
            name=data['name'],
            version=data['version'],
            object_stores=[
                from_dict(indexed_db.ObjectStore, item, casing_strategy)
                for item in data['objectStores']
            ]
        )

    if casing_strategy == 'pascal':
        return indexed_db.DatabaseWithObjectStores(
            name=data['Name'],
            version=data['Version'],
            object_stores=[
                from_dict(indexed_db.ObjectStore, item, casing_strategy)
                for item in data['ObjectStores']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _indexed_db__object_store__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'indexed_db.ObjectStore':

    if casing_strategy == 'snake':
        return indexed_db.ObjectStore(
            name=data['name'],
            key_path=from_dict(
                indexed_db.KeyPath,
                data['key_path'],
                casing_strategy
            ),
            auto_increment=data['auto_increment'],
            indexes=[
                from_dict(indexed_db.ObjectStoreIndex, item, casing_strategy)
                for item in data['indexes']
            ]
        )

    if casing_strategy == 'camel':
        return indexed_db.ObjectStore(
            name=data['name'],
            key_path=from_dict(
                indexed_db.KeyPath,
                data['keyPath'],
                casing_strategy
            ),
            auto_increment=data['autoIncrement'],
            indexes=[
                from_dict(indexed_db.ObjectStoreIndex, item, casing_strategy)
                for item in data['indexes']
            ]
        )

    if casing_strategy == 'pascal':
        return indexed_db.ObjectStore(
            name=data['Name'],
            key_path=from_dict(
                indexed_db.KeyPath,
                data['KeyPath'],
                casing_strategy
            ),
            auto_increment=data['AutoIncrement'],
            indexes=[
                from_dict(indexed_db.ObjectStoreIndex, item, casing_strategy)
                for item in data['Indexes']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _indexed_db__object_store_index__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'indexed_db.ObjectStoreIndex':

    if casing_strategy == 'snake':
        return indexed_db.ObjectStoreIndex(
            name=data['name'],
            key_path=from_dict(
                indexed_db.KeyPath,
                data['key_path'],
                casing_strategy
            ),
            unique=data['unique'],
            multi_entry=data['multi_entry']
        )

    if casing_strategy == 'camel':
        return indexed_db.ObjectStoreIndex(
            name=data['name'],
            key_path=from_dict(
                indexed_db.KeyPath,
                data['keyPath'],
                casing_strategy
            ),
            unique=data['unique'],
            multi_entry=data['multiEntry']
        )

    if casing_strategy == 'pascal':
        return indexed_db.ObjectStoreIndex(
            name=data['Name'],
            key_path=from_dict(
                indexed_db.KeyPath,
                data['KeyPath'],
                casing_strategy
            ),
            unique=data['Unique'],
            multi_entry=data['MultiEntry']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _indexed_db__key__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'indexed_db.Key':

    if casing_strategy == 'snake':
        return indexed_db.Key(
            type=data['type'],
            number=data.get('number', None),
            string=data.get('string', None),
            date=data.get('date', None),
            array=[
                from_dict(indexed_db.Key, item, casing_strategy)
                for item in data.get('array', [])
            ]
        )

    if casing_strategy == 'camel':
        return indexed_db.Key(
            type=data['type'],
            number=data.get('number', None),
            string=data.get('string', None),
            date=data.get('date', None),
            array=[
                from_dict(indexed_db.Key, item, casing_strategy)
                for item in data.get('array', [])
            ]
        )

    if casing_strategy == 'pascal':
        return indexed_db.Key(
            type=data['Type'],
            number=data.get('Number', None),
            string=data.get('String', None),
            date=data.get('Date', None),
            array=[
                from_dict(indexed_db.Key, item, casing_strategy)
                for item in data.get('Array', [])
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _indexed_db__key_range__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'indexed_db.KeyRange':

    if casing_strategy == 'snake':
        return indexed_db.KeyRange(
            lower=from_dict(
                indexed_db.Key,
                data.get('lower', None),
                casing_strategy
            ),
            upper=from_dict(
                indexed_db.Key,
                data.get('upper', None),
                casing_strategy
            ),
            lower_open=data['lower_open'],
            upper_open=data['upper_open']
        )

    if casing_strategy == 'camel':
        return indexed_db.KeyRange(
            lower=from_dict(
                indexed_db.Key,
                data.get('lower', None),
                casing_strategy
            ),
            upper=from_dict(
                indexed_db.Key,
                data.get('upper', None),
                casing_strategy
            ),
            lower_open=data['lowerOpen'],
            upper_open=data['upperOpen']
        )

    if casing_strategy == 'pascal':
        return indexed_db.KeyRange(
            lower=from_dict(
                indexed_db.Key,
                data.get('Lower', None),
                casing_strategy
            ),
            upper=from_dict(
                indexed_db.Key,
                data.get('Upper', None),
                casing_strategy
            ),
            lower_open=data['LowerOpen'],
            upper_open=data['UpperOpen']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _indexed_db__data_entry__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'indexed_db.DataEntry':

    if casing_strategy == 'snake':
        return indexed_db.DataEntry(
            key=from_dict(
                indexed_db.RemoteObject,
                data['key'],
                casing_strategy
            ),
            primary_key=from_dict(
                indexed_db.RemoteObject,
                data['primary_key'],
                casing_strategy
            ),
            value=from_dict(
                indexed_db.RemoteObject,
                data['value'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return indexed_db.DataEntry(
            key=from_dict(
                indexed_db.RemoteObject,
                data['key'],
                casing_strategy
            ),
            primary_key=from_dict(
                indexed_db.RemoteObject,
                data['primaryKey'],
                casing_strategy
            ),
            value=from_dict(
                indexed_db.RemoteObject,
                data['value'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return indexed_db.DataEntry(
            key=from_dict(
                indexed_db.RemoteObject,
                data['Key'],
                casing_strategy
            ),
            primary_key=from_dict(
                indexed_db.RemoteObject,
                data['PrimaryKey'],
                casing_strategy
            ),
            value=from_dict(
                indexed_db.RemoteObject,
                data['Value'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _indexed_db__key_path__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'indexed_db.KeyPath':

    if casing_strategy == 'snake':
        return indexed_db.KeyPath(
            type=data['type'],
            string=data.get('string', None),
            array=data.get('array', [])
        )

    if casing_strategy == 'camel':
        return indexed_db.KeyPath(
            type=data['type'],
            string=data.get('string', None),
            array=data.get('array', [])
        )

    if casing_strategy == 'pascal':
        return indexed_db.KeyPath(
            type=data['Type'],
            string=data.get('String', None),
            array=data.get('Array', [])
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _input__touch_point__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'input_.TouchPoint':

    if casing_strategy == 'snake':
        return input_.TouchPoint(
            x=data['x'],
            y=data['y'],
            radius_x=data.get('radius_x', None),
            radius_y=data.get('radius_y', None),
            rotation_angle=data.get('rotation_angle', None),
            force=data.get('force', None),
            tangential_pressure=data.get('tangential_pressure', None),
            tilt_x=data.get('tilt_x', None),
            tilt_y=data.get('tilt_y', None),
            twist=data.get('twist', None),
            id=data.get('id', None)
        )

    if casing_strategy == 'camel':
        return input_.TouchPoint(
            x=data['x'],
            y=data['y'],
            radius_x=data.get('radiusX', None),
            radius_y=data.get('radiusY', None),
            rotation_angle=data.get('rotationAngle', None),
            force=data.get('force', None),
            tangential_pressure=data.get('tangentialPressure', None),
            tilt_x=data.get('tiltX', None),
            tilt_y=data.get('tiltY', None),
            twist=data.get('twist', None),
            id=data.get('id', None)
        )

    if casing_strategy == 'pascal':
        return input_.TouchPoint(
            x=data['X'],
            y=data['Y'],
            radius_x=data.get('RadiusX', None),
            radius_y=data.get('RadiusY', None),
            rotation_angle=data.get('RotationAngle', None),
            force=data.get('Force', None),
            tangential_pressure=data.get('TangentialPressure', None),
            tilt_x=data.get('TiltX', None),
            tilt_y=data.get('TiltY', None),
            twist=data.get('Twist', None),
            id=data.get('Id', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _input__drag_data_item__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'input_.DragDataItem':

    if casing_strategy == 'snake':
        return input_.DragDataItem(
            mime_type=data['mime_type'],
            data=data['data'],
            title=data.get('title', None),
            base_url=data.get('base_url', None)
        )

    if casing_strategy == 'camel':
        return input_.DragDataItem(
            mime_type=data['mimeType'],
            data=data['data'],
            title=data.get('title', None),
            base_url=data.get('baseURL', None)
        )

    if casing_strategy == 'pascal':
        return input_.DragDataItem(
            mime_type=data['MimeType'],
            data=data['Data'],
            title=data.get('Title', None),
            base_url=data.get('BaseURL', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _input__drag_data__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'input_.DragData':

    if casing_strategy == 'snake':
        return input_.DragData(
            items=[
                from_dict(input_.DragDataItem, item, casing_strategy)
                for item in data['items']
            ],
            files=data.get('files', []),
            drag_operations_mask=data['drag_operations_mask']
        )

    if casing_strategy == 'camel':
        return input_.DragData(
            items=[
                from_dict(input_.DragDataItem, item, casing_strategy)
                for item in data['items']
            ],
            files=data.get('files', []),
            drag_operations_mask=data['dragOperationsMask']
        )

    if casing_strategy == 'pascal':
        return input_.DragData(
            items=[
                from_dict(input_.DragDataItem, item, casing_strategy)
                for item in data['Items']
            ],
            files=data.get('Files', []),
            drag_operations_mask=data['DragOperationsMask']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _layer_tree__scroll_rect__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'layer_tree.ScrollRect':

    if casing_strategy == 'snake':
        return layer_tree.ScrollRect(
            rect=from_dict(
                layer_tree.Rect,
                data['rect'],
                casing_strategy
            ),
            type=data['type']
        )

    if casing_strategy == 'camel':
        return layer_tree.ScrollRect(
            rect=from_dict(
                layer_tree.Rect,
                data['rect'],
                casing_strategy
            ),
            type=data['type']
        )

    if casing_strategy == 'pascal':
        return layer_tree.ScrollRect(
            rect=from_dict(
                layer_tree.Rect,
                data['Rect'],
                casing_strategy
            ),
            type=data['Type']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _layer_tree__sticky_position_constraint__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'layer_tree.StickyPositionConstraint':

    if casing_strategy == 'snake':
        return layer_tree.StickyPositionConstraint(
            sticky_box_rect=from_dict(
                layer_tree.Rect,
                data['sticky_box_rect'],
                casing_strategy
            ),
            containing_block_rect=from_dict(
                layer_tree.Rect,
                data['containing_block_rect'],
                casing_strategy
            ),
            nearest_layer_shifting_sticky_box=data.get('nearest_layer_shifting_sticky_box', None),
            nearest_layer_shifting_containing_block=data.get('nearest_layer_shifting_containing_block', None)
        )

    if casing_strategy == 'camel':
        return layer_tree.StickyPositionConstraint(
            sticky_box_rect=from_dict(
                layer_tree.Rect,
                data['stickyBoxRect'],
                casing_strategy
            ),
            containing_block_rect=from_dict(
                layer_tree.Rect,
                data['containingBlockRect'],
                casing_strategy
            ),
            nearest_layer_shifting_sticky_box=data.get('nearestLayerShiftingStickyBox', None),
            nearest_layer_shifting_containing_block=data.get('nearestLayerShiftingContainingBlock', None)
        )

    if casing_strategy == 'pascal':
        return layer_tree.StickyPositionConstraint(
            sticky_box_rect=from_dict(
                layer_tree.Rect,
                data['StickyBoxRect'],
                casing_strategy
            ),
            containing_block_rect=from_dict(
                layer_tree.Rect,
                data['ContainingBlockRect'],
                casing_strategy
            ),
            nearest_layer_shifting_sticky_box=data.get('NearestLayerShiftingStickyBox', None),
            nearest_layer_shifting_containing_block=data.get('NearestLayerShiftingContainingBlock', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _layer_tree__picture_tile__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'layer_tree.PictureTile':

    if casing_strategy == 'snake':
        return layer_tree.PictureTile(
            x=data['x'],
            y=data['y'],
            picture=data['picture']
        )

    if casing_strategy == 'camel':
        return layer_tree.PictureTile(
            x=data['x'],
            y=data['y'],
            picture=data['picture']
        )

    if casing_strategy == 'pascal':
        return layer_tree.PictureTile(
            x=data['X'],
            y=data['Y'],
            picture=data['Picture']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _layer_tree__layer__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'layer_tree.Layer':

    if casing_strategy == 'snake':
        return layer_tree.Layer(
            layer_id=data['layer_id'],
            parent_layer_id=data.get('parent_layer_id', None),
            backend_node_id=data.get('backend_node_id', None),
            offset_x=data['offset_x'],
            offset_y=data['offset_y'],
            width=data['width'],
            height=data['height'],
            transform=data.get('transform', []),
            anchor_x=data.get('anchor_x', None),
            anchor_y=data.get('anchor_y', None),
            anchor_z=data.get('anchor_z', None),
            paint_count=data['paint_count'],
            draws_content=data['draws_content'],
            invisible=data.get('invisible', None),
            scroll_rects=[
                from_dict(layer_tree.ScrollRect, item, casing_strategy)
                for item in data.get('scroll_rects', [])
            ],
            sticky_position_constraint=from_dict(
                layer_tree.StickyPositionConstraint,
                data.get('sticky_position_constraint', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return layer_tree.Layer(
            layer_id=data['layerId'],
            parent_layer_id=data.get('parentLayerId', None),
            backend_node_id=data.get('backendNodeId', None),
            offset_x=data['offsetX'],
            offset_y=data['offsetY'],
            width=data['width'],
            height=data['height'],
            transform=data.get('transform', []),
            anchor_x=data.get('anchorX', None),
            anchor_y=data.get('anchorY', None),
            anchor_z=data.get('anchorZ', None),
            paint_count=data['paintCount'],
            draws_content=data['drawsContent'],
            invisible=data.get('invisible', None),
            scroll_rects=[
                from_dict(layer_tree.ScrollRect, item, casing_strategy)
                for item in data.get('scrollRects', [])
            ],
            sticky_position_constraint=from_dict(
                layer_tree.StickyPositionConstraint,
                data.get('stickyPositionConstraint', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return layer_tree.Layer(
            layer_id=data['LayerId'],
            parent_layer_id=data.get('ParentLayerId', None),
            backend_node_id=data.get('BackendNodeId', None),
            offset_x=data['OffsetX'],
            offset_y=data['OffsetY'],
            width=data['Width'],
            height=data['Height'],
            transform=data.get('Transform', []),
            anchor_x=data.get('AnchorX', None),
            anchor_y=data.get('AnchorY', None),
            anchor_z=data.get('AnchorZ', None),
            paint_count=data['PaintCount'],
            draws_content=data['DrawsContent'],
            invisible=data.get('Invisible', None),
            scroll_rects=[
                from_dict(layer_tree.ScrollRect, item, casing_strategy)
                for item in data.get('ScrollRects', [])
            ],
            sticky_position_constraint=from_dict(
                layer_tree.StickyPositionConstraint,
                data.get('StickyPositionConstraint', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _log__log_entry__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'log.LogEntry':

    if casing_strategy == 'snake':
        return log.LogEntry(
            source=data['source'],
            level=data['level'],
            text=data['text'],
            category=data.get('category', None),
            timestamp=data['timestamp'],
            url=data.get('url', None),
            line_number=data.get('line_number', None),
            stack_trace=from_dict(
                log.StackTrace,
                data.get('stack_trace', None),
                casing_strategy
            ),
            network_request_id=data.get('network_request_id', None),
            worker_id=data.get('worker_id', None),
            args=[
                from_dict(log.RemoteObject, item, casing_strategy)
                for item in data.get('args', [])
            ]
        )

    if casing_strategy == 'camel':
        return log.LogEntry(
            source=data['source'],
            level=data['level'],
            text=data['text'],
            category=data.get('category', None),
            timestamp=data['timestamp'],
            url=data.get('url', None),
            line_number=data.get('lineNumber', None),
            stack_trace=from_dict(
                log.StackTrace,
                data.get('stackTrace', None),
                casing_strategy
            ),
            network_request_id=data.get('networkRequestId', None),
            worker_id=data.get('workerId', None),
            args=[
                from_dict(log.RemoteObject, item, casing_strategy)
                for item in data.get('args', [])
            ]
        )

    if casing_strategy == 'pascal':
        return log.LogEntry(
            source=data['Source'],
            level=data['Level'],
            text=data['Text'],
            category=data.get('Category', None),
            timestamp=data['Timestamp'],
            url=data.get('Url', None),
            line_number=data.get('LineNumber', None),
            stack_trace=from_dict(
                log.StackTrace,
                data.get('StackTrace', None),
                casing_strategy
            ),
            network_request_id=data.get('NetworkRequestId', None),
            worker_id=data.get('WorkerId', None),
            args=[
                from_dict(log.RemoteObject, item, casing_strategy)
                for item in data.get('Args', [])
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _log__violation_setting__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'log.ViolationSetting':

    if casing_strategy == 'snake':
        return log.ViolationSetting(
            name=data['name'],
            threshold=data['threshold']
        )

    if casing_strategy == 'camel':
        return log.ViolationSetting(
            name=data['name'],
            threshold=data['threshold']
        )

    if casing_strategy == 'pascal':
        return log.ViolationSetting(
            name=data['Name'],
            threshold=data['Threshold']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _memory__sampling_profile_node__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'memory.SamplingProfileNode':

    if casing_strategy == 'snake':
        return memory.SamplingProfileNode(
            size=data['size'],
            total=data['total'],
            stack=data['stack']
        )

    if casing_strategy == 'camel':
        return memory.SamplingProfileNode(
            size=data['size'],
            total=data['total'],
            stack=data['stack']
        )

    if casing_strategy == 'pascal':
        return memory.SamplingProfileNode(
            size=data['Size'],
            total=data['Total'],
            stack=data['Stack']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _memory__sampling_profile__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'memory.SamplingProfile':

    if casing_strategy == 'snake':
        return memory.SamplingProfile(
            samples=[
                from_dict(memory.SamplingProfileNode, item, casing_strategy)
                for item in data['samples']
            ],
            modules=[
                from_dict(memory.Module, item, casing_strategy)
                for item in data['modules']
            ]
        )

    if casing_strategy == 'camel':
        return memory.SamplingProfile(
            samples=[
                from_dict(memory.SamplingProfileNode, item, casing_strategy)
                for item in data['samples']
            ],
            modules=[
                from_dict(memory.Module, item, casing_strategy)
                for item in data['modules']
            ]
        )

    if casing_strategy == 'pascal':
        return memory.SamplingProfile(
            samples=[
                from_dict(memory.SamplingProfileNode, item, casing_strategy)
                for item in data['Samples']
            ],
            modules=[
                from_dict(memory.Module, item, casing_strategy)
                for item in data['Modules']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _memory__module__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'memory.Module':

    if casing_strategy == 'snake':
        return memory.Module(
            name=data['name'],
            uuid=data['uuid'],
            base_address=data['base_address'],
            size=data['size']
        )

    if casing_strategy == 'camel':
        return memory.Module(
            name=data['name'],
            uuid=data['uuid'],
            base_address=data['baseAddress'],
            size=data['size']
        )

    if casing_strategy == 'pascal':
        return memory.Module(
            name=data['Name'],
            uuid=data['Uuid'],
            base_address=data['BaseAddress'],
            size=data['Size']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__resource_timing__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.ResourceTiming':

    if casing_strategy == 'snake':
        return network.ResourceTiming(
            request_time=data['request_time'],
            proxy_start=data['proxy_start'],
            proxy_end=data['proxy_end'],
            dns_start=data['dns_start'],
            dns_end=data['dns_end'],
            connect_start=data['connect_start'],
            connect_end=data['connect_end'],
            ssl_start=data['ssl_start'],
            ssl_end=data['ssl_end'],
            worker_start=data['worker_start'],
            worker_ready=data['worker_ready'],
            worker_fetch_start=data['worker_fetch_start'],
            worker_respond_with_settled=data['worker_respond_with_settled'],
            send_start=data['send_start'],
            send_end=data['send_end'],
            push_start=data['push_start'],
            push_end=data['push_end'],
            receive_headers_start=data['receive_headers_start'],
            receive_headers_end=data['receive_headers_end']
        )

    if casing_strategy == 'camel':
        return network.ResourceTiming(
            request_time=data['requestTime'],
            proxy_start=data['proxyStart'],
            proxy_end=data['proxyEnd'],
            dns_start=data['dnsStart'],
            dns_end=data['dnsEnd'],
            connect_start=data['connectStart'],
            connect_end=data['connectEnd'],
            ssl_start=data['sslStart'],
            ssl_end=data['sslEnd'],
            worker_start=data['workerStart'],
            worker_ready=data['workerReady'],
            worker_fetch_start=data['workerFetchStart'],
            worker_respond_with_settled=data['workerRespondWithSettled'],
            send_start=data['sendStart'],
            send_end=data['sendEnd'],
            push_start=data['pushStart'],
            push_end=data['pushEnd'],
            receive_headers_start=data['receiveHeadersStart'],
            receive_headers_end=data['receiveHeadersEnd']
        )

    if casing_strategy == 'pascal':
        return network.ResourceTiming(
            request_time=data['RequestTime'],
            proxy_start=data['ProxyStart'],
            proxy_end=data['ProxyEnd'],
            dns_start=data['DnsStart'],
            dns_end=data['DnsEnd'],
            connect_start=data['ConnectStart'],
            connect_end=data['ConnectEnd'],
            ssl_start=data['SslStart'],
            ssl_end=data['SslEnd'],
            worker_start=data['WorkerStart'],
            worker_ready=data['WorkerReady'],
            worker_fetch_start=data['WorkerFetchStart'],
            worker_respond_with_settled=data['WorkerRespondWithSettled'],
            send_start=data['SendStart'],
            send_end=data['SendEnd'],
            push_start=data['PushStart'],
            push_end=data['PushEnd'],
            receive_headers_start=data['ReceiveHeadersStart'],
            receive_headers_end=data['ReceiveHeadersEnd']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__post_data_entry__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.PostDataEntry':

    if casing_strategy == 'snake':
        return network.PostDataEntry(
            bytes=data.get('bytes', None)
        )

    if casing_strategy == 'camel':
        return network.PostDataEntry(
            bytes=data.get('bytes', None)
        )

    if casing_strategy == 'pascal':
        return network.PostDataEntry(
            bytes=data.get('Bytes', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__request__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.Request':

    if casing_strategy == 'snake':
        return network.Request(
            url=data['url'],
            url_fragment=data.get('url_fragment', None),
            method=data['method'],
            headers=data['headers'],
            post_data=data.get('post_data', None),
            has_post_data=data.get('has_post_data', None),
            post_data_entries=[
                from_dict(network.PostDataEntry, item, casing_strategy)
                for item in data.get('post_data_entries', [])
            ],
            mixed_content_type=data.get('mixed_content_type', None),
            initial_priority=data['initial_priority'],
            referrer_policy=data['referrer_policy'],
            is_link_preload=data.get('is_link_preload', None),
            trust_token_params=from_dict(
                network.TrustTokenParams,
                data.get('trust_token_params', None),
                casing_strategy
            ),
            is_same_site=data.get('is_same_site', None)
        )

    if casing_strategy == 'camel':
        return network.Request(
            url=data['url'],
            url_fragment=data.get('urlFragment', None),
            method=data['method'],
            headers=data['headers'],
            post_data=data.get('postData', None),
            has_post_data=data.get('hasPostData', None),
            post_data_entries=[
                from_dict(network.PostDataEntry, item, casing_strategy)
                for item in data.get('postDataEntries', [])
            ],
            mixed_content_type=data.get('mixedContentType', None),
            initial_priority=data['initialPriority'],
            referrer_policy=data['referrerPolicy'],
            is_link_preload=data.get('isLinkPreload', None),
            trust_token_params=from_dict(
                network.TrustTokenParams,
                data.get('trustTokenParams', None),
                casing_strategy
            ),
            is_same_site=data.get('isSameSite', None)
        )

    if casing_strategy == 'pascal':
        return network.Request(
            url=data['Url'],
            url_fragment=data.get('UrlFragment', None),
            method=data['Method'],
            headers=data['Headers'],
            post_data=data.get('PostData', None),
            has_post_data=data.get('HasPostData', None),
            post_data_entries=[
                from_dict(network.PostDataEntry, item, casing_strategy)
                for item in data.get('PostDataEntries', [])
            ],
            mixed_content_type=data.get('MixedContentType', None),
            initial_priority=data['InitialPriority'],
            referrer_policy=data['ReferrerPolicy'],
            is_link_preload=data.get('IsLinkPreload', None),
            trust_token_params=from_dict(
                network.TrustTokenParams,
                data.get('TrustTokenParams', None),
                casing_strategy
            ),
            is_same_site=data.get('IsSameSite', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__signed_certificate_timestamp__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.SignedCertificateTimestamp':

    if casing_strategy == 'snake':
        return network.SignedCertificateTimestamp(
            status=data['status'],
            origin=data['origin'],
            log_description=data['log_description'],
            log_id=data['log_id'],
            timestamp=data['timestamp'],
            hash_algorithm=data['hash_algorithm'],
            signature_algorithm=data['signature_algorithm'],
            signature_data=data['signature_data']
        )

    if casing_strategy == 'camel':
        return network.SignedCertificateTimestamp(
            status=data['status'],
            origin=data['origin'],
            log_description=data['logDescription'],
            log_id=data['logId'],
            timestamp=data['timestamp'],
            hash_algorithm=data['hashAlgorithm'],
            signature_algorithm=data['signatureAlgorithm'],
            signature_data=data['signatureData']
        )

    if casing_strategy == 'pascal':
        return network.SignedCertificateTimestamp(
            status=data['Status'],
            origin=data['Origin'],
            log_description=data['LogDescription'],
            log_id=data['LogId'],
            timestamp=data['Timestamp'],
            hash_algorithm=data['HashAlgorithm'],
            signature_algorithm=data['SignatureAlgorithm'],
            signature_data=data['SignatureData']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__security_details__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.SecurityDetails':

    if casing_strategy == 'snake':
        return network.SecurityDetails(
            protocol=data['protocol'],
            key_exchange=data['key_exchange'],
            key_exchange_group=data.get('key_exchange_group', None),
            cipher=data['cipher'],
            mac=data.get('mac', None),
            certificate_id=data['certificate_id'],
            subject_name=data['subject_name'],
            san_list=data['san_list'],
            issuer=data['issuer'],
            valid_from=data['valid_from'],
            valid_to=data['valid_to'],
            signed_certificate_timestamp_list=[
                from_dict(network.SignedCertificateTimestamp, item, casing_strategy)
                for item in data['signed_certificate_timestamp_list']
            ],
            certificate_transparency_compliance=data['certificate_transparency_compliance'],
            server_signature_algorithm=data.get('server_signature_algorithm', None),
            encrypted_client_hello=data['encrypted_client_hello']
        )

    if casing_strategy == 'camel':
        return network.SecurityDetails(
            protocol=data['protocol'],
            key_exchange=data['keyExchange'],
            key_exchange_group=data.get('keyExchangeGroup', None),
            cipher=data['cipher'],
            mac=data.get('mac', None),
            certificate_id=data['certificateId'],
            subject_name=data['subjectName'],
            san_list=data['sanList'],
            issuer=data['issuer'],
            valid_from=data['validFrom'],
            valid_to=data['validTo'],
            signed_certificate_timestamp_list=[
                from_dict(network.SignedCertificateTimestamp, item, casing_strategy)
                for item in data['signedCertificateTimestampList']
            ],
            certificate_transparency_compliance=data['certificateTransparencyCompliance'],
            server_signature_algorithm=data.get('serverSignatureAlgorithm', None),
            encrypted_client_hello=data['encryptedClientHello']
        )

    if casing_strategy == 'pascal':
        return network.SecurityDetails(
            protocol=data['Protocol'],
            key_exchange=data['KeyExchange'],
            key_exchange_group=data.get('KeyExchangeGroup', None),
            cipher=data['Cipher'],
            mac=data.get('Mac', None),
            certificate_id=data['CertificateId'],
            subject_name=data['SubjectName'],
            san_list=data['SanList'],
            issuer=data['Issuer'],
            valid_from=data['ValidFrom'],
            valid_to=data['ValidTo'],
            signed_certificate_timestamp_list=[
                from_dict(network.SignedCertificateTimestamp, item, casing_strategy)
                for item in data['SignedCertificateTimestampList']
            ],
            certificate_transparency_compliance=data['CertificateTransparencyCompliance'],
            server_signature_algorithm=data.get('ServerSignatureAlgorithm', None),
            encrypted_client_hello=data['EncryptedClientHello']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__cors_error_status__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.CorsErrorStatus':

    if casing_strategy == 'snake':
        return network.CorsErrorStatus(
            cors_error=data['cors_error'],
            failed_parameter=data['failed_parameter']
        )

    if casing_strategy == 'camel':
        return network.CorsErrorStatus(
            cors_error=data['corsError'],
            failed_parameter=data['failedParameter']
        )

    if casing_strategy == 'pascal':
        return network.CorsErrorStatus(
            cors_error=data['CorsError'],
            failed_parameter=data['FailedParameter']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__trust_token_params__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.TrustTokenParams':

    if casing_strategy == 'snake':
        return network.TrustTokenParams(
            operation=data['operation'],
            refresh_policy=data['refresh_policy'],
            issuers=data.get('issuers', [])
        )

    if casing_strategy == 'camel':
        return network.TrustTokenParams(
            operation=data['operation'],
            refresh_policy=data['refreshPolicy'],
            issuers=data.get('issuers', [])
        )

    if casing_strategy == 'pascal':
        return network.TrustTokenParams(
            operation=data['Operation'],
            refresh_policy=data['RefreshPolicy'],
            issuers=data.get('Issuers', [])
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__response__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.Response':

    if casing_strategy == 'snake':
        return network.Response(
            url=data['url'],
            status=data['status'],
            status_text=data['status_text'],
            headers=data['headers'],
            headers_text=data.get('headers_text', None),
            mime_type=data['mime_type'],
            request_headers=data.get('request_headers', None),
            request_headers_text=data.get('request_headers_text', None),
            connection_reused=data['connection_reused'],
            connection_id=data['connection_id'],
            remote_ip_address=data.get('remote_ip_address', None),
            remote_port=data.get('remote_port', None),
            from_disk_cache=data.get('from_disk_cache', None),
            from_service_worker=data.get('from_service_worker', None),
            from_prefetch_cache=data.get('from_prefetch_cache', None),
            encoded_data_length=data['encoded_data_length'],
            timing=from_dict(
                network.ResourceTiming,
                data.get('timing', None),
                casing_strategy
            ),
            service_worker_response_source=data.get('service_worker_response_source', None),
            response_time=data.get('response_time', None),
            cache_storage_cache_name=data.get('cache_storage_cache_name', None),
            protocol=data.get('protocol', None),
            alternate_protocol_usage=data.get('alternate_protocol_usage', None),
            security_state=data['security_state'],
            security_details=from_dict(
                network.SecurityDetails,
                data.get('security_details', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return network.Response(
            url=data['url'],
            status=data['status'],
            status_text=data['statusText'],
            headers=data['headers'],
            headers_text=data.get('headersText', None),
            mime_type=data['mimeType'],
            request_headers=data.get('requestHeaders', None),
            request_headers_text=data.get('requestHeadersText', None),
            connection_reused=data['connectionReused'],
            connection_id=data['connectionId'],
            remote_ip_address=data.get('remoteIPAddress', None),
            remote_port=data.get('remotePort', None),
            from_disk_cache=data.get('fromDiskCache', None),
            from_service_worker=data.get('fromServiceWorker', None),
            from_prefetch_cache=data.get('fromPrefetchCache', None),
            encoded_data_length=data['encodedDataLength'],
            timing=from_dict(
                network.ResourceTiming,
                data.get('timing', None),
                casing_strategy
            ),
            service_worker_response_source=data.get('serviceWorkerResponseSource', None),
            response_time=data.get('responseTime', None),
            cache_storage_cache_name=data.get('cacheStorageCacheName', None),
            protocol=data.get('protocol', None),
            alternate_protocol_usage=data.get('alternateProtocolUsage', None),
            security_state=data['securityState'],
            security_details=from_dict(
                network.SecurityDetails,
                data.get('securityDetails', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return network.Response(
            url=data['Url'],
            status=data['Status'],
            status_text=data['StatusText'],
            headers=data['Headers'],
            headers_text=data.get('HeadersText', None),
            mime_type=data['MimeType'],
            request_headers=data.get('RequestHeaders', None),
            request_headers_text=data.get('RequestHeadersText', None),
            connection_reused=data['ConnectionReused'],
            connection_id=data['ConnectionId'],
            remote_ip_address=data.get('RemoteIPAddress', None),
            remote_port=data.get('RemotePort', None),
            from_disk_cache=data.get('FromDiskCache', None),
            from_service_worker=data.get('FromServiceWorker', None),
            from_prefetch_cache=data.get('FromPrefetchCache', None),
            encoded_data_length=data['EncodedDataLength'],
            timing=from_dict(
                network.ResourceTiming,
                data.get('Timing', None),
                casing_strategy
            ),
            service_worker_response_source=data.get('ServiceWorkerResponseSource', None),
            response_time=data.get('ResponseTime', None),
            cache_storage_cache_name=data.get('CacheStorageCacheName', None),
            protocol=data.get('Protocol', None),
            alternate_protocol_usage=data.get('AlternateProtocolUsage', None),
            security_state=data['SecurityState'],
            security_details=from_dict(
                network.SecurityDetails,
                data.get('SecurityDetails', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__web_socket_request__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.WebSocketRequest':

    if casing_strategy == 'snake':
        return network.WebSocketRequest(
            headers=data['headers']
        )

    if casing_strategy == 'camel':
        return network.WebSocketRequest(
            headers=data['headers']
        )

    if casing_strategy == 'pascal':
        return network.WebSocketRequest(
            headers=data['Headers']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__web_socket_response__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.WebSocketResponse':

    if casing_strategy == 'snake':
        return network.WebSocketResponse(
            status=data['status'],
            status_text=data['status_text'],
            headers=data['headers'],
            headers_text=data.get('headers_text', None),
            request_headers=data.get('request_headers', None),
            request_headers_text=data.get('request_headers_text', None)
        )

    if casing_strategy == 'camel':
        return network.WebSocketResponse(
            status=data['status'],
            status_text=data['statusText'],
            headers=data['headers'],
            headers_text=data.get('headersText', None),
            request_headers=data.get('requestHeaders', None),
            request_headers_text=data.get('requestHeadersText', None)
        )

    if casing_strategy == 'pascal':
        return network.WebSocketResponse(
            status=data['Status'],
            status_text=data['StatusText'],
            headers=data['Headers'],
            headers_text=data.get('HeadersText', None),
            request_headers=data.get('RequestHeaders', None),
            request_headers_text=data.get('RequestHeadersText', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__web_socket_frame__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.WebSocketFrame':

    if casing_strategy == 'snake':
        return network.WebSocketFrame(
            opcode=data['opcode'],
            mask=data['mask'],
            payload_data=data['payload_data']
        )

    if casing_strategy == 'camel':
        return network.WebSocketFrame(
            opcode=data['opcode'],
            mask=data['mask'],
            payload_data=data['payloadData']
        )

    if casing_strategy == 'pascal':
        return network.WebSocketFrame(
            opcode=data['Opcode'],
            mask=data['Mask'],
            payload_data=data['PayloadData']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__cached_resource__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.CachedResource':

    if casing_strategy == 'snake':
        return network.CachedResource(
            url=data['url'],
            type=data['type'],
            response=from_dict(
                network.Response,
                data.get('response', None),
                casing_strategy
            ),
            body_size=data['body_size']
        )

    if casing_strategy == 'camel':
        return network.CachedResource(
            url=data['url'],
            type=data['type'],
            response=from_dict(
                network.Response,
                data.get('response', None),
                casing_strategy
            ),
            body_size=data['bodySize']
        )

    if casing_strategy == 'pascal':
        return network.CachedResource(
            url=data['Url'],
            type=data['Type'],
            response=from_dict(
                network.Response,
                data.get('Response', None),
                casing_strategy
            ),
            body_size=data['BodySize']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__initiator__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.Initiator':

    if casing_strategy == 'snake':
        return network.Initiator(
            type=data['type'],
            stack=from_dict(
                network.StackTrace,
                data.get('stack', None),
                casing_strategy
            ),
            url=data.get('url', None),
            line_number=data.get('line_number', None),
            column_number=data.get('column_number', None),
            request_id=data.get('request_id', None)
        )

    if casing_strategy == 'camel':
        return network.Initiator(
            type=data['type'],
            stack=from_dict(
                network.StackTrace,
                data.get('stack', None),
                casing_strategy
            ),
            url=data.get('url', None),
            line_number=data.get('lineNumber', None),
            column_number=data.get('columnNumber', None),
            request_id=data.get('requestId', None)
        )

    if casing_strategy == 'pascal':
        return network.Initiator(
            type=data['Type'],
            stack=from_dict(
                network.StackTrace,
                data.get('Stack', None),
                casing_strategy
            ),
            url=data.get('Url', None),
            line_number=data.get('LineNumber', None),
            column_number=data.get('ColumnNumber', None),
            request_id=data.get('RequestId', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__cookie__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.Cookie':

    if casing_strategy == 'snake':
        return network.Cookie(
            name=data['name'],
            value=data['value'],
            domain=data['domain'],
            path=data['path'],
            expires=data['expires'],
            size=data['size'],
            http_only=data['http_only'],
            secure=data['secure'],
            session=data['session'],
            same_site=data.get('same_site', None),
            priority=data['priority'],
            same_party=data['same_party'],
            source_scheme=data['source_scheme'],
            source_port=data['source_port'],
            partition_key=data.get('partition_key', None),
            partition_key_opaque=data.get('partition_key_opaque', None)
        )

    if casing_strategy == 'camel':
        return network.Cookie(
            name=data['name'],
            value=data['value'],
            domain=data['domain'],
            path=data['path'],
            expires=data['expires'],
            size=data['size'],
            http_only=data['httpOnly'],
            secure=data['secure'],
            session=data['session'],
            same_site=data.get('sameSite', None),
            priority=data['priority'],
            same_party=data['sameParty'],
            source_scheme=data['sourceScheme'],
            source_port=data['sourcePort'],
            partition_key=data.get('partitionKey', None),
            partition_key_opaque=data.get('partitionKeyOpaque', None)
        )

    if casing_strategy == 'pascal':
        return network.Cookie(
            name=data['Name'],
            value=data['Value'],
            domain=data['Domain'],
            path=data['Path'],
            expires=data['Expires'],
            size=data['Size'],
            http_only=data['HttpOnly'],
            secure=data['Secure'],
            session=data['Session'],
            same_site=data.get('SameSite', None),
            priority=data['Priority'],
            same_party=data['SameParty'],
            source_scheme=data['SourceScheme'],
            source_port=data['SourcePort'],
            partition_key=data.get('PartitionKey', None),
            partition_key_opaque=data.get('PartitionKeyOpaque', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__blocked_set_cookie_with_reason__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.BlockedSetCookieWithReason':

    if casing_strategy == 'snake':
        return network.BlockedSetCookieWithReason(
            blocked_reasons=data['blocked_reasons'],
            cookie_line=data['cookie_line'],
            cookie=from_dict(
                network.Cookie,
                data.get('cookie', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return network.BlockedSetCookieWithReason(
            blocked_reasons=data['blockedReasons'],
            cookie_line=data['cookieLine'],
            cookie=from_dict(
                network.Cookie,
                data.get('cookie', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return network.BlockedSetCookieWithReason(
            blocked_reasons=data['BlockedReasons'],
            cookie_line=data['CookieLine'],
            cookie=from_dict(
                network.Cookie,
                data.get('Cookie', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__blocked_cookie_with_reason__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.BlockedCookieWithReason':

    if casing_strategy == 'snake':
        return network.BlockedCookieWithReason(
            blocked_reasons=data['blocked_reasons'],
            cookie=from_dict(
                network.Cookie,
                data['cookie'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return network.BlockedCookieWithReason(
            blocked_reasons=data['blockedReasons'],
            cookie=from_dict(
                network.Cookie,
                data['cookie'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return network.BlockedCookieWithReason(
            blocked_reasons=data['BlockedReasons'],
            cookie=from_dict(
                network.Cookie,
                data['Cookie'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__cookie_param__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.CookieParam':

    if casing_strategy == 'snake':
        return network.CookieParam(
            name=data['name'],
            value=data['value'],
            url=data.get('url', None),
            domain=data.get('domain', None),
            path=data.get('path', None),
            secure=data.get('secure', None),
            http_only=data.get('http_only', None),
            same_site=data.get('same_site', None),
            expires=data.get('expires', None),
            priority=data.get('priority', None),
            same_party=data.get('same_party', None),
            source_scheme=data.get('source_scheme', None),
            source_port=data.get('source_port', None),
            partition_key=data.get('partition_key', None)
        )

    if casing_strategy == 'camel':
        return network.CookieParam(
            name=data['name'],
            value=data['value'],
            url=data.get('url', None),
            domain=data.get('domain', None),
            path=data.get('path', None),
            secure=data.get('secure', None),
            http_only=data.get('httpOnly', None),
            same_site=data.get('sameSite', None),
            expires=data.get('expires', None),
            priority=data.get('priority', None),
            same_party=data.get('sameParty', None),
            source_scheme=data.get('sourceScheme', None),
            source_port=data.get('sourcePort', None),
            partition_key=data.get('partitionKey', None)
        )

    if casing_strategy == 'pascal':
        return network.CookieParam(
            name=data['Name'],
            value=data['Value'],
            url=data.get('Url', None),
            domain=data.get('Domain', None),
            path=data.get('Path', None),
            secure=data.get('Secure', None),
            http_only=data.get('HttpOnly', None),
            same_site=data.get('SameSite', None),
            expires=data.get('Expires', None),
            priority=data.get('Priority', None),
            same_party=data.get('SameParty', None),
            source_scheme=data.get('SourceScheme', None),
            source_port=data.get('SourcePort', None),
            partition_key=data.get('PartitionKey', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__auth_challenge__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.AuthChallenge':

    if casing_strategy == 'snake':
        return network.AuthChallenge(
            source=data.get('source', None),
            origin=data['origin'],
            scheme=data['scheme'],
            realm=data['realm']
        )

    if casing_strategy == 'camel':
        return network.AuthChallenge(
            source=data.get('source', None),
            origin=data['origin'],
            scheme=data['scheme'],
            realm=data['realm']
        )

    if casing_strategy == 'pascal':
        return network.AuthChallenge(
            source=data.get('Source', None),
            origin=data['Origin'],
            scheme=data['Scheme'],
            realm=data['Realm']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__auth_challenge_response__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.AuthChallengeResponse':

    if casing_strategy == 'snake':
        return network.AuthChallengeResponse(
            response=data['response'],
            username=data.get('username', None),
            password=data.get('password', None)
        )

    if casing_strategy == 'camel':
        return network.AuthChallengeResponse(
            response=data['response'],
            username=data.get('username', None),
            password=data.get('password', None)
        )

    if casing_strategy == 'pascal':
        return network.AuthChallengeResponse(
            response=data['Response'],
            username=data.get('Username', None),
            password=data.get('Password', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__request_pattern__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.RequestPattern':

    if casing_strategy == 'snake':
        return network.RequestPattern(
            url_pattern=data.get('url_pattern', None),
            resource_type=data.get('resource_type', None),
            interception_stage=data.get('interception_stage', None)
        )

    if casing_strategy == 'camel':
        return network.RequestPattern(
            url_pattern=data.get('urlPattern', None),
            resource_type=data.get('resourceType', None),
            interception_stage=data.get('interceptionStage', None)
        )

    if casing_strategy == 'pascal':
        return network.RequestPattern(
            url_pattern=data.get('UrlPattern', None),
            resource_type=data.get('ResourceType', None),
            interception_stage=data.get('InterceptionStage', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__signed_exchange_signature__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.SignedExchangeSignature':

    if casing_strategy == 'snake':
        return network.SignedExchangeSignature(
            label=data['label'],
            signature=data['signature'],
            integrity=data['integrity'],
            cert_url=data.get('cert_url', None),
            cert_sha256=data.get('cert_sha256', None),
            validity_url=data['validity_url'],
            date=data['date'],
            expires=data['expires'],
            certificates=data.get('certificates', [])
        )

    if casing_strategy == 'camel':
        return network.SignedExchangeSignature(
            label=data['label'],
            signature=data['signature'],
            integrity=data['integrity'],
            cert_url=data.get('certUrl', None),
            cert_sha256=data.get('certSha256', None),
            validity_url=data['validityUrl'],
            date=data['date'],
            expires=data['expires'],
            certificates=data.get('certificates', [])
        )

    if casing_strategy == 'pascal':
        return network.SignedExchangeSignature(
            label=data['Label'],
            signature=data['Signature'],
            integrity=data['Integrity'],
            cert_url=data.get('CertUrl', None),
            cert_sha256=data.get('CertSha256', None),
            validity_url=data['ValidityUrl'],
            date=data['Date'],
            expires=data['Expires'],
            certificates=data.get('Certificates', [])
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__signed_exchange_header__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.SignedExchangeHeader':

    if casing_strategy == 'snake':
        return network.SignedExchangeHeader(
            request_url=data['request_url'],
            response_code=data['response_code'],
            response_headers=data['response_headers'],
            signatures=[
                from_dict(network.SignedExchangeSignature, item, casing_strategy)
                for item in data['signatures']
            ],
            header_integrity=data['header_integrity']
        )

    if casing_strategy == 'camel':
        return network.SignedExchangeHeader(
            request_url=data['requestUrl'],
            response_code=data['responseCode'],
            response_headers=data['responseHeaders'],
            signatures=[
                from_dict(network.SignedExchangeSignature, item, casing_strategy)
                for item in data['signatures']
            ],
            header_integrity=data['headerIntegrity']
        )

    if casing_strategy == 'pascal':
        return network.SignedExchangeHeader(
            request_url=data['RequestUrl'],
            response_code=data['ResponseCode'],
            response_headers=data['ResponseHeaders'],
            signatures=[
                from_dict(network.SignedExchangeSignature, item, casing_strategy)
                for item in data['Signatures']
            ],
            header_integrity=data['HeaderIntegrity']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__signed_exchange_error__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.SignedExchangeError':

    if casing_strategy == 'snake':
        return network.SignedExchangeError(
            message=data['message'],
            signature_index=data.get('signature_index', None),
            error_field=data.get('error_field', None)
        )

    if casing_strategy == 'camel':
        return network.SignedExchangeError(
            message=data['message'],
            signature_index=data.get('signatureIndex', None),
            error_field=data.get('errorField', None)
        )

    if casing_strategy == 'pascal':
        return network.SignedExchangeError(
            message=data['Message'],
            signature_index=data.get('SignatureIndex', None),
            error_field=data.get('ErrorField', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__signed_exchange_info__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.SignedExchangeInfo':

    if casing_strategy == 'snake':
        return network.SignedExchangeInfo(
            outer_response=from_dict(
                network.Response,
                data['outer_response'],
                casing_strategy
            ),
            header=from_dict(
                network.SignedExchangeHeader,
                data.get('header', None),
                casing_strategy
            ),
            security_details=from_dict(
                network.SecurityDetails,
                data.get('security_details', None),
                casing_strategy
            ),
            errors=[
                from_dict(network.SignedExchangeError, item, casing_strategy)
                for item in data.get('errors', [])
            ]
        )

    if casing_strategy == 'camel':
        return network.SignedExchangeInfo(
            outer_response=from_dict(
                network.Response,
                data['outerResponse'],
                casing_strategy
            ),
            header=from_dict(
                network.SignedExchangeHeader,
                data.get('header', None),
                casing_strategy
            ),
            security_details=from_dict(
                network.SecurityDetails,
                data.get('securityDetails', None),
                casing_strategy
            ),
            errors=[
                from_dict(network.SignedExchangeError, item, casing_strategy)
                for item in data.get('errors', [])
            ]
        )

    if casing_strategy == 'pascal':
        return network.SignedExchangeInfo(
            outer_response=from_dict(
                network.Response,
                data['OuterResponse'],
                casing_strategy
            ),
            header=from_dict(
                network.SignedExchangeHeader,
                data.get('Header', None),
                casing_strategy
            ),
            security_details=from_dict(
                network.SecurityDetails,
                data.get('SecurityDetails', None),
                casing_strategy
            ),
            errors=[
                from_dict(network.SignedExchangeError, item, casing_strategy)
                for item in data.get('Errors', [])
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__connect_timing__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.ConnectTiming':

    if casing_strategy == 'snake':
        return network.ConnectTiming(
            request_time=data['request_time']
        )

    if casing_strategy == 'camel':
        return network.ConnectTiming(
            request_time=data['requestTime']
        )

    if casing_strategy == 'pascal':
        return network.ConnectTiming(
            request_time=data['RequestTime']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__client_security_state__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.ClientSecurityState':

    if casing_strategy == 'snake':
        return network.ClientSecurityState(
            initiator_is_secure_context=data['initiator_is_secure_context'],
            initiator_ip_address_space=data['initiator_ip_address_space'],
            private_network_request_policy=data['private_network_request_policy']
        )

    if casing_strategy == 'camel':
        return network.ClientSecurityState(
            initiator_is_secure_context=data['initiatorIsSecureContext'],
            initiator_ip_address_space=data['initiatorIPAddressSpace'],
            private_network_request_policy=data['privateNetworkRequestPolicy']
        )

    if casing_strategy == 'pascal':
        return network.ClientSecurityState(
            initiator_is_secure_context=data['InitiatorIsSecureContext'],
            initiator_ip_address_space=data['InitiatorIPAddressSpace'],
            private_network_request_policy=data['PrivateNetworkRequestPolicy']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__cross_origin_opener_policy_status__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.CrossOriginOpenerPolicyStatus':

    if casing_strategy == 'snake':
        return network.CrossOriginOpenerPolicyStatus(
            value=data['value'],
            report_only_value=data['report_only_value'],
            reporting_endpoint=data.get('reporting_endpoint', None),
            report_only_reporting_endpoint=data.get('report_only_reporting_endpoint', None)
        )

    if casing_strategy == 'camel':
        return network.CrossOriginOpenerPolicyStatus(
            value=data['value'],
            report_only_value=data['reportOnlyValue'],
            reporting_endpoint=data.get('reportingEndpoint', None),
            report_only_reporting_endpoint=data.get('reportOnlyReportingEndpoint', None)
        )

    if casing_strategy == 'pascal':
        return network.CrossOriginOpenerPolicyStatus(
            value=data['Value'],
            report_only_value=data['ReportOnlyValue'],
            reporting_endpoint=data.get('ReportingEndpoint', None),
            report_only_reporting_endpoint=data.get('ReportOnlyReportingEndpoint', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__cross_origin_embedder_policy_status__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.CrossOriginEmbedderPolicyStatus':

    if casing_strategy == 'snake':
        return network.CrossOriginEmbedderPolicyStatus(
            value=data['value'],
            report_only_value=data['report_only_value'],
            reporting_endpoint=data.get('reporting_endpoint', None),
            report_only_reporting_endpoint=data.get('report_only_reporting_endpoint', None)
        )

    if casing_strategy == 'camel':
        return network.CrossOriginEmbedderPolicyStatus(
            value=data['value'],
            report_only_value=data['reportOnlyValue'],
            reporting_endpoint=data.get('reportingEndpoint', None),
            report_only_reporting_endpoint=data.get('reportOnlyReportingEndpoint', None)
        )

    if casing_strategy == 'pascal':
        return network.CrossOriginEmbedderPolicyStatus(
            value=data['Value'],
            report_only_value=data['ReportOnlyValue'],
            reporting_endpoint=data.get('ReportingEndpoint', None),
            report_only_reporting_endpoint=data.get('ReportOnlyReportingEndpoint', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__content_security_policy_status__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.ContentSecurityPolicyStatus':

    if casing_strategy == 'snake':
        return network.ContentSecurityPolicyStatus(
            effective_directives=data['effective_directives'],
            is_enforced=data['is_enforced'],
            source=data['source']
        )

    if casing_strategy == 'camel':
        return network.ContentSecurityPolicyStatus(
            effective_directives=data['effectiveDirectives'],
            is_enforced=data['isEnforced'],
            source=data['source']
        )

    if casing_strategy == 'pascal':
        return network.ContentSecurityPolicyStatus(
            effective_directives=data['EffectiveDirectives'],
            is_enforced=data['IsEnforced'],
            source=data['Source']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__security_isolation_status__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.SecurityIsolationStatus':

    if casing_strategy == 'snake':
        return network.SecurityIsolationStatus(
            coop=from_dict(
                network.CrossOriginOpenerPolicyStatus,
                data.get('coop', None),
                casing_strategy
            ),
            coep=from_dict(
                network.CrossOriginEmbedderPolicyStatus,
                data.get('coep', None),
                casing_strategy
            ),
            csp=[
                from_dict(network.ContentSecurityPolicyStatus, item, casing_strategy)
                for item in data.get('csp', [])
            ]
        )

    if casing_strategy == 'camel':
        return network.SecurityIsolationStatus(
            coop=from_dict(
                network.CrossOriginOpenerPolicyStatus,
                data.get('coop', None),
                casing_strategy
            ),
            coep=from_dict(
                network.CrossOriginEmbedderPolicyStatus,
                data.get('coep', None),
                casing_strategy
            ),
            csp=[
                from_dict(network.ContentSecurityPolicyStatus, item, casing_strategy)
                for item in data.get('csp', [])
            ]
        )

    if casing_strategy == 'pascal':
        return network.SecurityIsolationStatus(
            coop=from_dict(
                network.CrossOriginOpenerPolicyStatus,
                data.get('Coop', None),
                casing_strategy
            ),
            coep=from_dict(
                network.CrossOriginEmbedderPolicyStatus,
                data.get('Coep', None),
                casing_strategy
            ),
            csp=[
                from_dict(network.ContentSecurityPolicyStatus, item, casing_strategy)
                for item in data.get('Csp', [])
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__reporting_api_report__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.ReportingApiReport':

    if casing_strategy == 'snake':
        return network.ReportingApiReport(
            id=data['id'],
            initiator_url=data['initiator_url'],
            destination=data['destination'],
            type=data['type'],
            timestamp=data['timestamp'],
            depth=data['depth'],
            completed_attempts=data['completed_attempts'],
            body=data['body'],
            status=data['status']
        )

    if casing_strategy == 'camel':
        return network.ReportingApiReport(
            id=data['id'],
            initiator_url=data['initiatorUrl'],
            destination=data['destination'],
            type=data['type'],
            timestamp=data['timestamp'],
            depth=data['depth'],
            completed_attempts=data['completedAttempts'],
            body=data['body'],
            status=data['status']
        )

    if casing_strategy == 'pascal':
        return network.ReportingApiReport(
            id=data['Id'],
            initiator_url=data['InitiatorUrl'],
            destination=data['Destination'],
            type=data['Type'],
            timestamp=data['Timestamp'],
            depth=data['Depth'],
            completed_attempts=data['CompletedAttempts'],
            body=data['Body'],
            status=data['Status']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__reporting_api_endpoint__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.ReportingApiEndpoint':

    if casing_strategy == 'snake':
        return network.ReportingApiEndpoint(
            url=data['url'],
            group_name=data['group_name']
        )

    if casing_strategy == 'camel':
        return network.ReportingApiEndpoint(
            url=data['url'],
            group_name=data['groupName']
        )

    if casing_strategy == 'pascal':
        return network.ReportingApiEndpoint(
            url=data['Url'],
            group_name=data['GroupName']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__load_network_resource_page_result__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.LoadNetworkResourcePageResult':

    if casing_strategy == 'snake':
        return network.LoadNetworkResourcePageResult(
            success=data['success'],
            net_error=data.get('net_error', None),
            net_error_name=data.get('net_error_name', None),
            http_status_code=data.get('http_status_code', None),
            stream=data.get('stream', None),
            headers=data.get('headers', None)
        )

    if casing_strategy == 'camel':
        return network.LoadNetworkResourcePageResult(
            success=data['success'],
            net_error=data.get('netError', None),
            net_error_name=data.get('netErrorName', None),
            http_status_code=data.get('httpStatusCode', None),
            stream=data.get('stream', None),
            headers=data.get('headers', None)
        )

    if casing_strategy == 'pascal':
        return network.LoadNetworkResourcePageResult(
            success=data['Success'],
            net_error=data.get('NetError', None),
            net_error_name=data.get('NetErrorName', None),
            http_status_code=data.get('HttpStatusCode', None),
            stream=data.get('Stream', None),
            headers=data.get('Headers', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__load_network_resource_options__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.LoadNetworkResourceOptions':

    if casing_strategy == 'snake':
        return network.LoadNetworkResourceOptions(
            disable_cache=data['disable_cache'],
            include_credentials=data['include_credentials']
        )

    if casing_strategy == 'camel':
        return network.LoadNetworkResourceOptions(
            disable_cache=data['disableCache'],
            include_credentials=data['includeCredentials']
        )

    if casing_strategy == 'pascal':
        return network.LoadNetworkResourceOptions(
            disable_cache=data['DisableCache'],
            include_credentials=data['IncludeCredentials']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__source_order_config__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'overlay.SourceOrderConfig':

    if casing_strategy == 'snake':
        return overlay.SourceOrderConfig(
            parent_outline_color=from_dict(
                overlay.RGBA,
                data['parent_outline_color'],
                casing_strategy
            ),
            child_outline_color=from_dict(
                overlay.RGBA,
                data['child_outline_color'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return overlay.SourceOrderConfig(
            parent_outline_color=from_dict(
                overlay.RGBA,
                data['parentOutlineColor'],
                casing_strategy
            ),
            child_outline_color=from_dict(
                overlay.RGBA,
                data['childOutlineColor'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return overlay.SourceOrderConfig(
            parent_outline_color=from_dict(
                overlay.RGBA,
                data['ParentOutlineColor'],
                casing_strategy
            ),
            child_outline_color=from_dict(
                overlay.RGBA,
                data['ChildOutlineColor'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__grid_highlight_config__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'overlay.GridHighlightConfig':

    if casing_strategy == 'snake':
        return overlay.GridHighlightConfig(
            show_grid_extension_lines=data.get('show_grid_extension_lines', None),
            show_positive_line_numbers=data.get('show_positive_line_numbers', None),
            show_negative_line_numbers=data.get('show_negative_line_numbers', None),
            show_area_names=data.get('show_area_names', None),
            show_line_names=data.get('show_line_names', None),
            show_track_sizes=data.get('show_track_sizes', None),
            grid_border_color=from_dict(
                overlay.RGBA,
                data.get('grid_border_color', None),
                casing_strategy
            ),
            cell_border_color=from_dict(
                overlay.RGBA,
                data.get('cell_border_color', None),
                casing_strategy
            ),
            row_line_color=from_dict(
                overlay.RGBA,
                data.get('row_line_color', None),
                casing_strategy
            ),
            column_line_color=from_dict(
                overlay.RGBA,
                data.get('column_line_color', None),
                casing_strategy
            ),
            grid_border_dash=data.get('grid_border_dash', None),
            cell_border_dash=data.get('cell_border_dash', None),
            row_line_dash=data.get('row_line_dash', None),
            column_line_dash=data.get('column_line_dash', None),
            row_gap_color=from_dict(
                overlay.RGBA,
                data.get('row_gap_color', None),
                casing_strategy
            ),
            row_hatch_color=from_dict(
                overlay.RGBA,
                data.get('row_hatch_color', None),
                casing_strategy
            ),
            column_gap_color=from_dict(
                overlay.RGBA,
                data.get('column_gap_color', None),
                casing_strategy
            ),
            column_hatch_color=from_dict(
                overlay.RGBA,
                data.get('column_hatch_color', None),
                casing_strategy
            ),
            area_border_color=from_dict(
                overlay.RGBA,
                data.get('area_border_color', None),
                casing_strategy
            ),
            grid_background_color=from_dict(
                overlay.RGBA,
                data.get('grid_background_color', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return overlay.GridHighlightConfig(
            show_grid_extension_lines=data.get('showGridExtensionLines', None),
            show_positive_line_numbers=data.get('showPositiveLineNumbers', None),
            show_negative_line_numbers=data.get('showNegativeLineNumbers', None),
            show_area_names=data.get('showAreaNames', None),
            show_line_names=data.get('showLineNames', None),
            show_track_sizes=data.get('showTrackSizes', None),
            grid_border_color=from_dict(
                overlay.RGBA,
                data.get('gridBorderColor', None),
                casing_strategy
            ),
            cell_border_color=from_dict(
                overlay.RGBA,
                data.get('cellBorderColor', None),
                casing_strategy
            ),
            row_line_color=from_dict(
                overlay.RGBA,
                data.get('rowLineColor', None),
                casing_strategy
            ),
            column_line_color=from_dict(
                overlay.RGBA,
                data.get('columnLineColor', None),
                casing_strategy
            ),
            grid_border_dash=data.get('gridBorderDash', None),
            cell_border_dash=data.get('cellBorderDash', None),
            row_line_dash=data.get('rowLineDash', None),
            column_line_dash=data.get('columnLineDash', None),
            row_gap_color=from_dict(
                overlay.RGBA,
                data.get('rowGapColor', None),
                casing_strategy
            ),
            row_hatch_color=from_dict(
                overlay.RGBA,
                data.get('rowHatchColor', None),
                casing_strategy
            ),
            column_gap_color=from_dict(
                overlay.RGBA,
                data.get('columnGapColor', None),
                casing_strategy
            ),
            column_hatch_color=from_dict(
                overlay.RGBA,
                data.get('columnHatchColor', None),
                casing_strategy
            ),
            area_border_color=from_dict(
                overlay.RGBA,
                data.get('areaBorderColor', None),
                casing_strategy
            ),
            grid_background_color=from_dict(
                overlay.RGBA,
                data.get('gridBackgroundColor', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return overlay.GridHighlightConfig(
            show_grid_extension_lines=data.get('ShowGridExtensionLines', None),
            show_positive_line_numbers=data.get('ShowPositiveLineNumbers', None),
            show_negative_line_numbers=data.get('ShowNegativeLineNumbers', None),
            show_area_names=data.get('ShowAreaNames', None),
            show_line_names=data.get('ShowLineNames', None),
            show_track_sizes=data.get('ShowTrackSizes', None),
            grid_border_color=from_dict(
                overlay.RGBA,
                data.get('GridBorderColor', None),
                casing_strategy
            ),
            cell_border_color=from_dict(
                overlay.RGBA,
                data.get('CellBorderColor', None),
                casing_strategy
            ),
            row_line_color=from_dict(
                overlay.RGBA,
                data.get('RowLineColor', None),
                casing_strategy
            ),
            column_line_color=from_dict(
                overlay.RGBA,
                data.get('ColumnLineColor', None),
                casing_strategy
            ),
            grid_border_dash=data.get('GridBorderDash', None),
            cell_border_dash=data.get('CellBorderDash', None),
            row_line_dash=data.get('RowLineDash', None),
            column_line_dash=data.get('ColumnLineDash', None),
            row_gap_color=from_dict(
                overlay.RGBA,
                data.get('RowGapColor', None),
                casing_strategy
            ),
            row_hatch_color=from_dict(
                overlay.RGBA,
                data.get('RowHatchColor', None),
                casing_strategy
            ),
            column_gap_color=from_dict(
                overlay.RGBA,
                data.get('ColumnGapColor', None),
                casing_strategy
            ),
            column_hatch_color=from_dict(
                overlay.RGBA,
                data.get('ColumnHatchColor', None),
                casing_strategy
            ),
            area_border_color=from_dict(
                overlay.RGBA,
                data.get('AreaBorderColor', None),
                casing_strategy
            ),
            grid_background_color=from_dict(
                overlay.RGBA,
                data.get('GridBackgroundColor', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__flex_container_highlight_config__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'overlay.FlexContainerHighlightConfig':

    if casing_strategy == 'snake':
        return overlay.FlexContainerHighlightConfig(
            container_border=from_dict(
                overlay.LineStyle,
                data.get('container_border', None),
                casing_strategy
            ),
            line_separator=from_dict(
                overlay.LineStyle,
                data.get('line_separator', None),
                casing_strategy
            ),
            item_separator=from_dict(
                overlay.LineStyle,
                data.get('item_separator', None),
                casing_strategy
            ),
            main_distributed_space=from_dict(
                overlay.BoxStyle,
                data.get('main_distributed_space', None),
                casing_strategy
            ),
            cross_distributed_space=from_dict(
                overlay.BoxStyle,
                data.get('cross_distributed_space', None),
                casing_strategy
            ),
            row_gap_space=from_dict(
                overlay.BoxStyle,
                data.get('row_gap_space', None),
                casing_strategy
            ),
            column_gap_space=from_dict(
                overlay.BoxStyle,
                data.get('column_gap_space', None),
                casing_strategy
            ),
            cross_alignment=from_dict(
                overlay.LineStyle,
                data.get('cross_alignment', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return overlay.FlexContainerHighlightConfig(
            container_border=from_dict(
                overlay.LineStyle,
                data.get('containerBorder', None),
                casing_strategy
            ),
            line_separator=from_dict(
                overlay.LineStyle,
                data.get('lineSeparator', None),
                casing_strategy
            ),
            item_separator=from_dict(
                overlay.LineStyle,
                data.get('itemSeparator', None),
                casing_strategy
            ),
            main_distributed_space=from_dict(
                overlay.BoxStyle,
                data.get('mainDistributedSpace', None),
                casing_strategy
            ),
            cross_distributed_space=from_dict(
                overlay.BoxStyle,
                data.get('crossDistributedSpace', None),
                casing_strategy
            ),
            row_gap_space=from_dict(
                overlay.BoxStyle,
                data.get('rowGapSpace', None),
                casing_strategy
            ),
            column_gap_space=from_dict(
                overlay.BoxStyle,
                data.get('columnGapSpace', None),
                casing_strategy
            ),
            cross_alignment=from_dict(
                overlay.LineStyle,
                data.get('crossAlignment', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return overlay.FlexContainerHighlightConfig(
            container_border=from_dict(
                overlay.LineStyle,
                data.get('ContainerBorder', None),
                casing_strategy
            ),
            line_separator=from_dict(
                overlay.LineStyle,
                data.get('LineSeparator', None),
                casing_strategy
            ),
            item_separator=from_dict(
                overlay.LineStyle,
                data.get('ItemSeparator', None),
                casing_strategy
            ),
            main_distributed_space=from_dict(
                overlay.BoxStyle,
                data.get('MainDistributedSpace', None),
                casing_strategy
            ),
            cross_distributed_space=from_dict(
                overlay.BoxStyle,
                data.get('CrossDistributedSpace', None),
                casing_strategy
            ),
            row_gap_space=from_dict(
                overlay.BoxStyle,
                data.get('RowGapSpace', None),
                casing_strategy
            ),
            column_gap_space=from_dict(
                overlay.BoxStyle,
                data.get('ColumnGapSpace', None),
                casing_strategy
            ),
            cross_alignment=from_dict(
                overlay.LineStyle,
                data.get('CrossAlignment', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__flex_item_highlight_config__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'overlay.FlexItemHighlightConfig':

    if casing_strategy == 'snake':
        return overlay.FlexItemHighlightConfig(
            base_size_box=from_dict(
                overlay.BoxStyle,
                data.get('base_size_box', None),
                casing_strategy
            ),
            base_size_border=from_dict(
                overlay.LineStyle,
                data.get('base_size_border', None),
                casing_strategy
            ),
            flexibility_arrow=from_dict(
                overlay.LineStyle,
                data.get('flexibility_arrow', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return overlay.FlexItemHighlightConfig(
            base_size_box=from_dict(
                overlay.BoxStyle,
                data.get('baseSizeBox', None),
                casing_strategy
            ),
            base_size_border=from_dict(
                overlay.LineStyle,
                data.get('baseSizeBorder', None),
                casing_strategy
            ),
            flexibility_arrow=from_dict(
                overlay.LineStyle,
                data.get('flexibilityArrow', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return overlay.FlexItemHighlightConfig(
            base_size_box=from_dict(
                overlay.BoxStyle,
                data.get('BaseSizeBox', None),
                casing_strategy
            ),
            base_size_border=from_dict(
                overlay.LineStyle,
                data.get('BaseSizeBorder', None),
                casing_strategy
            ),
            flexibility_arrow=from_dict(
                overlay.LineStyle,
                data.get('FlexibilityArrow', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__line_style__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'overlay.LineStyle':

    if casing_strategy == 'snake':
        return overlay.LineStyle(
            color=from_dict(
                overlay.RGBA,
                data.get('color', None),
                casing_strategy
            ),
            pattern=data.get('pattern', None)
        )

    if casing_strategy == 'camel':
        return overlay.LineStyle(
            color=from_dict(
                overlay.RGBA,
                data.get('color', None),
                casing_strategy
            ),
            pattern=data.get('pattern', None)
        )

    if casing_strategy == 'pascal':
        return overlay.LineStyle(
            color=from_dict(
                overlay.RGBA,
                data.get('Color', None),
                casing_strategy
            ),
            pattern=data.get('Pattern', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__box_style__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'overlay.BoxStyle':

    if casing_strategy == 'snake':
        return overlay.BoxStyle(
            fill_color=from_dict(
                overlay.RGBA,
                data.get('fill_color', None),
                casing_strategy
            ),
            hatch_color=from_dict(
                overlay.RGBA,
                data.get('hatch_color', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return overlay.BoxStyle(
            fill_color=from_dict(
                overlay.RGBA,
                data.get('fillColor', None),
                casing_strategy
            ),
            hatch_color=from_dict(
                overlay.RGBA,
                data.get('hatchColor', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return overlay.BoxStyle(
            fill_color=from_dict(
                overlay.RGBA,
                data.get('FillColor', None),
                casing_strategy
            ),
            hatch_color=from_dict(
                overlay.RGBA,
                data.get('HatchColor', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__highlight_config__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'overlay.HighlightConfig':

    if casing_strategy == 'snake':
        return overlay.HighlightConfig(
            show_info=data.get('show_info', None),
            show_styles=data.get('show_styles', None),
            show_rulers=data.get('show_rulers', None),
            show_accessibility_info=data.get('show_accessibility_info', None),
            show_extension_lines=data.get('show_extension_lines', None),
            content_color=from_dict(
                overlay.RGBA,
                data.get('content_color', None),
                casing_strategy
            ),
            padding_color=from_dict(
                overlay.RGBA,
                data.get('padding_color', None),
                casing_strategy
            ),
            border_color=from_dict(
                overlay.RGBA,
                data.get('border_color', None),
                casing_strategy
            ),
            margin_color=from_dict(
                overlay.RGBA,
                data.get('margin_color', None),
                casing_strategy
            ),
            event_target_color=from_dict(
                overlay.RGBA,
                data.get('event_target_color', None),
                casing_strategy
            ),
            shape_color=from_dict(
                overlay.RGBA,
                data.get('shape_color', None),
                casing_strategy
            ),
            shape_margin_color=from_dict(
                overlay.RGBA,
                data.get('shape_margin_color', None),
                casing_strategy
            ),
            css_grid_color=from_dict(
                overlay.RGBA,
                data.get('css_grid_color', None),
                casing_strategy
            ),
            color_format=data.get('color_format', None),
            grid_highlight_config=from_dict(
                overlay.GridHighlightConfig,
                data.get('grid_highlight_config', None),
                casing_strategy
            ),
            flex_container_highlight_config=from_dict(
                overlay.FlexContainerHighlightConfig,
                data.get('flex_container_highlight_config', None),
                casing_strategy
            ),
            flex_item_highlight_config=from_dict(
                overlay.FlexItemHighlightConfig,
                data.get('flex_item_highlight_config', None),
                casing_strategy
            ),
            contrast_algorithm=data.get('contrast_algorithm', None),
            container_query_container_highlight_config=from_dict(
                overlay.ContainerQueryContainerHighlightConfig,
                data.get('container_query_container_highlight_config', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return overlay.HighlightConfig(
            show_info=data.get('showInfo', None),
            show_styles=data.get('showStyles', None),
            show_rulers=data.get('showRulers', None),
            show_accessibility_info=data.get('showAccessibilityInfo', None),
            show_extension_lines=data.get('showExtensionLines', None),
            content_color=from_dict(
                overlay.RGBA,
                data.get('contentColor', None),
                casing_strategy
            ),
            padding_color=from_dict(
                overlay.RGBA,
                data.get('paddingColor', None),
                casing_strategy
            ),
            border_color=from_dict(
                overlay.RGBA,
                data.get('borderColor', None),
                casing_strategy
            ),
            margin_color=from_dict(
                overlay.RGBA,
                data.get('marginColor', None),
                casing_strategy
            ),
            event_target_color=from_dict(
                overlay.RGBA,
                data.get('eventTargetColor', None),
                casing_strategy
            ),
            shape_color=from_dict(
                overlay.RGBA,
                data.get('shapeColor', None),
                casing_strategy
            ),
            shape_margin_color=from_dict(
                overlay.RGBA,
                data.get('shapeMarginColor', None),
                casing_strategy
            ),
            css_grid_color=from_dict(
                overlay.RGBA,
                data.get('cssGridColor', None),
                casing_strategy
            ),
            color_format=data.get('colorFormat', None),
            grid_highlight_config=from_dict(
                overlay.GridHighlightConfig,
                data.get('gridHighlightConfig', None),
                casing_strategy
            ),
            flex_container_highlight_config=from_dict(
                overlay.FlexContainerHighlightConfig,
                data.get('flexContainerHighlightConfig', None),
                casing_strategy
            ),
            flex_item_highlight_config=from_dict(
                overlay.FlexItemHighlightConfig,
                data.get('flexItemHighlightConfig', None),
                casing_strategy
            ),
            contrast_algorithm=data.get('contrastAlgorithm', None),
            container_query_container_highlight_config=from_dict(
                overlay.ContainerQueryContainerHighlightConfig,
                data.get('containerQueryContainerHighlightConfig', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return overlay.HighlightConfig(
            show_info=data.get('ShowInfo', None),
            show_styles=data.get('ShowStyles', None),
            show_rulers=data.get('ShowRulers', None),
            show_accessibility_info=data.get('ShowAccessibilityInfo', None),
            show_extension_lines=data.get('ShowExtensionLines', None),
            content_color=from_dict(
                overlay.RGBA,
                data.get('ContentColor', None),
                casing_strategy
            ),
            padding_color=from_dict(
                overlay.RGBA,
                data.get('PaddingColor', None),
                casing_strategy
            ),
            border_color=from_dict(
                overlay.RGBA,
                data.get('BorderColor', None),
                casing_strategy
            ),
            margin_color=from_dict(
                overlay.RGBA,
                data.get('MarginColor', None),
                casing_strategy
            ),
            event_target_color=from_dict(
                overlay.RGBA,
                data.get('EventTargetColor', None),
                casing_strategy
            ),
            shape_color=from_dict(
                overlay.RGBA,
                data.get('ShapeColor', None),
                casing_strategy
            ),
            shape_margin_color=from_dict(
                overlay.RGBA,
                data.get('ShapeMarginColor', None),
                casing_strategy
            ),
            css_grid_color=from_dict(
                overlay.RGBA,
                data.get('CssGridColor', None),
                casing_strategy
            ),
            color_format=data.get('ColorFormat', None),
            grid_highlight_config=from_dict(
                overlay.GridHighlightConfig,
                data.get('GridHighlightConfig', None),
                casing_strategy
            ),
            flex_container_highlight_config=from_dict(
                overlay.FlexContainerHighlightConfig,
                data.get('FlexContainerHighlightConfig', None),
                casing_strategy
            ),
            flex_item_highlight_config=from_dict(
                overlay.FlexItemHighlightConfig,
                data.get('FlexItemHighlightConfig', None),
                casing_strategy
            ),
            contrast_algorithm=data.get('ContrastAlgorithm', None),
            container_query_container_highlight_config=from_dict(
                overlay.ContainerQueryContainerHighlightConfig,
                data.get('ContainerQueryContainerHighlightConfig', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__grid_node_highlight_config__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'overlay.GridNodeHighlightConfig':

    if casing_strategy == 'snake':
        return overlay.GridNodeHighlightConfig(
            grid_highlight_config=from_dict(
                overlay.GridHighlightConfig,
                data['grid_highlight_config'],
                casing_strategy
            ),
            node_id=data['node_id']
        )

    if casing_strategy == 'camel':
        return overlay.GridNodeHighlightConfig(
            grid_highlight_config=from_dict(
                overlay.GridHighlightConfig,
                data['gridHighlightConfig'],
                casing_strategy
            ),
            node_id=data['nodeId']
        )

    if casing_strategy == 'pascal':
        return overlay.GridNodeHighlightConfig(
            grid_highlight_config=from_dict(
                overlay.GridHighlightConfig,
                data['GridHighlightConfig'],
                casing_strategy
            ),
            node_id=data['NodeId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__flex_node_highlight_config__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'overlay.FlexNodeHighlightConfig':

    if casing_strategy == 'snake':
        return overlay.FlexNodeHighlightConfig(
            flex_container_highlight_config=from_dict(
                overlay.FlexContainerHighlightConfig,
                data['flex_container_highlight_config'],
                casing_strategy
            ),
            node_id=data['node_id']
        )

    if casing_strategy == 'camel':
        return overlay.FlexNodeHighlightConfig(
            flex_container_highlight_config=from_dict(
                overlay.FlexContainerHighlightConfig,
                data['flexContainerHighlightConfig'],
                casing_strategy
            ),
            node_id=data['nodeId']
        )

    if casing_strategy == 'pascal':
        return overlay.FlexNodeHighlightConfig(
            flex_container_highlight_config=from_dict(
                overlay.FlexContainerHighlightConfig,
                data['FlexContainerHighlightConfig'],
                casing_strategy
            ),
            node_id=data['NodeId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__scroll_snap_container_highlight_config__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'overlay.ScrollSnapContainerHighlightConfig':

    if casing_strategy == 'snake':
        return overlay.ScrollSnapContainerHighlightConfig(
            snapport_border=from_dict(
                overlay.LineStyle,
                data.get('snapport_border', None),
                casing_strategy
            ),
            snap_area_border=from_dict(
                overlay.LineStyle,
                data.get('snap_area_border', None),
                casing_strategy
            ),
            scroll_margin_color=from_dict(
                overlay.RGBA,
                data.get('scroll_margin_color', None),
                casing_strategy
            ),
            scroll_padding_color=from_dict(
                overlay.RGBA,
                data.get('scroll_padding_color', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return overlay.ScrollSnapContainerHighlightConfig(
            snapport_border=from_dict(
                overlay.LineStyle,
                data.get('snapportBorder', None),
                casing_strategy
            ),
            snap_area_border=from_dict(
                overlay.LineStyle,
                data.get('snapAreaBorder', None),
                casing_strategy
            ),
            scroll_margin_color=from_dict(
                overlay.RGBA,
                data.get('scrollMarginColor', None),
                casing_strategy
            ),
            scroll_padding_color=from_dict(
                overlay.RGBA,
                data.get('scrollPaddingColor', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return overlay.ScrollSnapContainerHighlightConfig(
            snapport_border=from_dict(
                overlay.LineStyle,
                data.get('SnapportBorder', None),
                casing_strategy
            ),
            snap_area_border=from_dict(
                overlay.LineStyle,
                data.get('SnapAreaBorder', None),
                casing_strategy
            ),
            scroll_margin_color=from_dict(
                overlay.RGBA,
                data.get('ScrollMarginColor', None),
                casing_strategy
            ),
            scroll_padding_color=from_dict(
                overlay.RGBA,
                data.get('ScrollPaddingColor', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__scroll_snap_highlight_config__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'overlay.ScrollSnapHighlightConfig':

    if casing_strategy == 'snake':
        return overlay.ScrollSnapHighlightConfig(
            scroll_snap_container_highlight_config=from_dict(
                overlay.ScrollSnapContainerHighlightConfig,
                data['scroll_snap_container_highlight_config'],
                casing_strategy
            ),
            node_id=data['node_id']
        )

    if casing_strategy == 'camel':
        return overlay.ScrollSnapHighlightConfig(
            scroll_snap_container_highlight_config=from_dict(
                overlay.ScrollSnapContainerHighlightConfig,
                data['scrollSnapContainerHighlightConfig'],
                casing_strategy
            ),
            node_id=data['nodeId']
        )

    if casing_strategy == 'pascal':
        return overlay.ScrollSnapHighlightConfig(
            scroll_snap_container_highlight_config=from_dict(
                overlay.ScrollSnapContainerHighlightConfig,
                data['ScrollSnapContainerHighlightConfig'],
                casing_strategy
            ),
            node_id=data['NodeId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__hinge_config__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'overlay.HingeConfig':

    if casing_strategy == 'snake':
        return overlay.HingeConfig(
            rect=from_dict(
                overlay.Rect,
                data['rect'],
                casing_strategy
            ),
            content_color=from_dict(
                overlay.RGBA,
                data.get('content_color', None),
                casing_strategy
            ),
            outline_color=from_dict(
                overlay.RGBA,
                data.get('outline_color', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return overlay.HingeConfig(
            rect=from_dict(
                overlay.Rect,
                data['rect'],
                casing_strategy
            ),
            content_color=from_dict(
                overlay.RGBA,
                data.get('contentColor', None),
                casing_strategy
            ),
            outline_color=from_dict(
                overlay.RGBA,
                data.get('outlineColor', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return overlay.HingeConfig(
            rect=from_dict(
                overlay.Rect,
                data['Rect'],
                casing_strategy
            ),
            content_color=from_dict(
                overlay.RGBA,
                data.get('ContentColor', None),
                casing_strategy
            ),
            outline_color=from_dict(
                overlay.RGBA,
                data.get('OutlineColor', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__container_query_highlight_config__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'overlay.ContainerQueryHighlightConfig':

    if casing_strategy == 'snake':
        return overlay.ContainerQueryHighlightConfig(
            container_query_container_highlight_config=from_dict(
                overlay.ContainerQueryContainerHighlightConfig,
                data['container_query_container_highlight_config'],
                casing_strategy
            ),
            node_id=data['node_id']
        )

    if casing_strategy == 'camel':
        return overlay.ContainerQueryHighlightConfig(
            container_query_container_highlight_config=from_dict(
                overlay.ContainerQueryContainerHighlightConfig,
                data['containerQueryContainerHighlightConfig'],
                casing_strategy
            ),
            node_id=data['nodeId']
        )

    if casing_strategy == 'pascal':
        return overlay.ContainerQueryHighlightConfig(
            container_query_container_highlight_config=from_dict(
                overlay.ContainerQueryContainerHighlightConfig,
                data['ContainerQueryContainerHighlightConfig'],
                casing_strategy
            ),
            node_id=data['NodeId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__container_query_container_highlight_config__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'overlay.ContainerQueryContainerHighlightConfig':

    if casing_strategy == 'snake':
        return overlay.ContainerQueryContainerHighlightConfig(
            container_border=from_dict(
                overlay.LineStyle,
                data.get('container_border', None),
                casing_strategy
            ),
            descendant_border=from_dict(
                overlay.LineStyle,
                data.get('descendant_border', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return overlay.ContainerQueryContainerHighlightConfig(
            container_border=from_dict(
                overlay.LineStyle,
                data.get('containerBorder', None),
                casing_strategy
            ),
            descendant_border=from_dict(
                overlay.LineStyle,
                data.get('descendantBorder', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return overlay.ContainerQueryContainerHighlightConfig(
            container_border=from_dict(
                overlay.LineStyle,
                data.get('ContainerBorder', None),
                casing_strategy
            ),
            descendant_border=from_dict(
                overlay.LineStyle,
                data.get('DescendantBorder', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__isolated_element_highlight_config__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'overlay.IsolatedElementHighlightConfig':

    if casing_strategy == 'snake':
        return overlay.IsolatedElementHighlightConfig(
            isolation_mode_highlight_config=from_dict(
                overlay.IsolationModeHighlightConfig,
                data['isolation_mode_highlight_config'],
                casing_strategy
            ),
            node_id=data['node_id']
        )

    if casing_strategy == 'camel':
        return overlay.IsolatedElementHighlightConfig(
            isolation_mode_highlight_config=from_dict(
                overlay.IsolationModeHighlightConfig,
                data['isolationModeHighlightConfig'],
                casing_strategy
            ),
            node_id=data['nodeId']
        )

    if casing_strategy == 'pascal':
        return overlay.IsolatedElementHighlightConfig(
            isolation_mode_highlight_config=from_dict(
                overlay.IsolationModeHighlightConfig,
                data['IsolationModeHighlightConfig'],
                casing_strategy
            ),
            node_id=data['NodeId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__isolation_mode_highlight_config__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'overlay.IsolationModeHighlightConfig':

    if casing_strategy == 'snake':
        return overlay.IsolationModeHighlightConfig(
            resizer_color=from_dict(
                overlay.RGBA,
                data.get('resizer_color', None),
                casing_strategy
            ),
            resizer_handle_color=from_dict(
                overlay.RGBA,
                data.get('resizer_handle_color', None),
                casing_strategy
            ),
            mask_color=from_dict(
                overlay.RGBA,
                data.get('mask_color', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return overlay.IsolationModeHighlightConfig(
            resizer_color=from_dict(
                overlay.RGBA,
                data.get('resizerColor', None),
                casing_strategy
            ),
            resizer_handle_color=from_dict(
                overlay.RGBA,
                data.get('resizerHandleColor', None),
                casing_strategy
            ),
            mask_color=from_dict(
                overlay.RGBA,
                data.get('maskColor', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return overlay.IsolationModeHighlightConfig(
            resizer_color=from_dict(
                overlay.RGBA,
                data.get('ResizerColor', None),
                casing_strategy
            ),
            resizer_handle_color=from_dict(
                overlay.RGBA,
                data.get('ResizerHandleColor', None),
                casing_strategy
            ),
            mask_color=from_dict(
                overlay.RGBA,
                data.get('MaskColor', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__ad_frame_status__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.AdFrameStatus':

    if casing_strategy == 'snake':
        return page.AdFrameStatus(
            ad_frame_type=data['ad_frame_type'],
            explanations=data.get('explanations', [])
        )

    if casing_strategy == 'camel':
        return page.AdFrameStatus(
            ad_frame_type=data['adFrameType'],
            explanations=data.get('explanations', [])
        )

    if casing_strategy == 'pascal':
        return page.AdFrameStatus(
            ad_frame_type=data['AdFrameType'],
            explanations=data.get('Explanations', [])
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__ad_script_id__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.AdScriptId':

    if casing_strategy == 'snake':
        return page.AdScriptId(
            script_id=data['script_id'],
            debugger_id=data['debugger_id']
        )

    if casing_strategy == 'camel':
        return page.AdScriptId(
            script_id=data['scriptId'],
            debugger_id=data['debuggerId']
        )

    if casing_strategy == 'pascal':
        return page.AdScriptId(
            script_id=data['ScriptId'],
            debugger_id=data['DebuggerId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__permissions_policy_block_locator__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.PermissionsPolicyBlockLocator':

    if casing_strategy == 'snake':
        return page.PermissionsPolicyBlockLocator(
            frame_id=data['frame_id'],
            block_reason=data['block_reason']
        )

    if casing_strategy == 'camel':
        return page.PermissionsPolicyBlockLocator(
            frame_id=data['frameId'],
            block_reason=data['blockReason']
        )

    if casing_strategy == 'pascal':
        return page.PermissionsPolicyBlockLocator(
            frame_id=data['FrameId'],
            block_reason=data['BlockReason']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__permissions_policy_feature_state__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.PermissionsPolicyFeatureState':

    if casing_strategy == 'snake':
        return page.PermissionsPolicyFeatureState(
            feature=data['feature'],
            allowed=data['allowed'],
            locator=from_dict(
                page.PermissionsPolicyBlockLocator,
                data.get('locator', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return page.PermissionsPolicyFeatureState(
            feature=data['feature'],
            allowed=data['allowed'],
            locator=from_dict(
                page.PermissionsPolicyBlockLocator,
                data.get('locator', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return page.PermissionsPolicyFeatureState(
            feature=data['Feature'],
            allowed=data['Allowed'],
            locator=from_dict(
                page.PermissionsPolicyBlockLocator,
                data.get('Locator', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__origin_trial_token__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.OriginTrialToken':

    if casing_strategy == 'snake':
        return page.OriginTrialToken(
            origin=data['origin'],
            match_sub_domains=data['match_sub_domains'],
            trial_name=data['trial_name'],
            expiry_time=data['expiry_time'],
            is_third_party=data['is_third_party'],
            usage_restriction=data['usage_restriction']
        )

    if casing_strategy == 'camel':
        return page.OriginTrialToken(
            origin=data['origin'],
            match_sub_domains=data['matchSubDomains'],
            trial_name=data['trialName'],
            expiry_time=data['expiryTime'],
            is_third_party=data['isThirdParty'],
            usage_restriction=data['usageRestriction']
        )

    if casing_strategy == 'pascal':
        return page.OriginTrialToken(
            origin=data['Origin'],
            match_sub_domains=data['MatchSubDomains'],
            trial_name=data['TrialName'],
            expiry_time=data['ExpiryTime'],
            is_third_party=data['IsThirdParty'],
            usage_restriction=data['UsageRestriction']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__origin_trial_token_with_status__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.OriginTrialTokenWithStatus':

    if casing_strategy == 'snake':
        return page.OriginTrialTokenWithStatus(
            raw_token_text=data['raw_token_text'],
            parsed_token=from_dict(
                page.OriginTrialToken,
                data.get('parsed_token', None),
                casing_strategy
            ),
            status=data['status']
        )

    if casing_strategy == 'camel':
        return page.OriginTrialTokenWithStatus(
            raw_token_text=data['rawTokenText'],
            parsed_token=from_dict(
                page.OriginTrialToken,
                data.get('parsedToken', None),
                casing_strategy
            ),
            status=data['status']
        )

    if casing_strategy == 'pascal':
        return page.OriginTrialTokenWithStatus(
            raw_token_text=data['RawTokenText'],
            parsed_token=from_dict(
                page.OriginTrialToken,
                data.get('ParsedToken', None),
                casing_strategy
            ),
            status=data['Status']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__origin_trial__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.OriginTrial':

    if casing_strategy == 'snake':
        return page.OriginTrial(
            trial_name=data['trial_name'],
            status=data['status'],
            tokens_with_status=[
                from_dict(page.OriginTrialTokenWithStatus, item, casing_strategy)
                for item in data['tokens_with_status']
            ]
        )

    if casing_strategy == 'camel':
        return page.OriginTrial(
            trial_name=data['trialName'],
            status=data['status'],
            tokens_with_status=[
                from_dict(page.OriginTrialTokenWithStatus, item, casing_strategy)
                for item in data['tokensWithStatus']
            ]
        )

    if casing_strategy == 'pascal':
        return page.OriginTrial(
            trial_name=data['TrialName'],
            status=data['Status'],
            tokens_with_status=[
                from_dict(page.OriginTrialTokenWithStatus, item, casing_strategy)
                for item in data['TokensWithStatus']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__frame__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.Frame':

    if casing_strategy == 'snake':
        return page.Frame(
            id=data['id'],
            parent_id=data.get('parent_id', None),
            loader_id=data['loader_id'],
            name=data.get('name', None),
            url=data['url'],
            url_fragment=data.get('url_fragment', None),
            domain_and_registry=data['domain_and_registry'],
            security_origin=data['security_origin'],
            mime_type=data['mime_type'],
            unreachable_url=data.get('unreachable_url', None),
            ad_frame_status=from_dict(
                page.AdFrameStatus,
                data.get('ad_frame_status', None),
                casing_strategy
            ),
            secure_context_type=data['secure_context_type'],
            cross_origin_isolated_context_type=data['cross_origin_isolated_context_type'],
            gated_api_features=data['gated_api_features']
        )

    if casing_strategy == 'camel':
        return page.Frame(
            id=data['id'],
            parent_id=data.get('parentId', None),
            loader_id=data['loaderId'],
            name=data.get('name', None),
            url=data['url'],
            url_fragment=data.get('urlFragment', None),
            domain_and_registry=data['domainAndRegistry'],
            security_origin=data['securityOrigin'],
            mime_type=data['mimeType'],
            unreachable_url=data.get('unreachableUrl', None),
            ad_frame_status=from_dict(
                page.AdFrameStatus,
                data.get('adFrameStatus', None),
                casing_strategy
            ),
            secure_context_type=data['secureContextType'],
            cross_origin_isolated_context_type=data['crossOriginIsolatedContextType'],
            gated_api_features=data['gatedAPIFeatures']
        )

    if casing_strategy == 'pascal':
        return page.Frame(
            id=data['Id'],
            parent_id=data.get('ParentId', None),
            loader_id=data['LoaderId'],
            name=data.get('Name', None),
            url=data['Url'],
            url_fragment=data.get('UrlFragment', None),
            domain_and_registry=data['DomainAndRegistry'],
            security_origin=data['SecurityOrigin'],
            mime_type=data['MimeType'],
            unreachable_url=data.get('UnreachableUrl', None),
            ad_frame_status=from_dict(
                page.AdFrameStatus,
                data.get('AdFrameStatus', None),
                casing_strategy
            ),
            secure_context_type=data['SecureContextType'],
            cross_origin_isolated_context_type=data['CrossOriginIsolatedContextType'],
            gated_api_features=data['GatedAPIFeatures']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__frame_resource__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.FrameResource':

    if casing_strategy == 'snake':
        return page.FrameResource(
            url=data['url'],
            type=data['type'],
            mime_type=data['mime_type'],
            last_modified=data.get('last_modified', None),
            content_size=data.get('content_size', None),
            failed=data.get('failed', None),
            canceled=data.get('canceled', None)
        )

    if casing_strategy == 'camel':
        return page.FrameResource(
            url=data['url'],
            type=data['type'],
            mime_type=data['mimeType'],
            last_modified=data.get('lastModified', None),
            content_size=data.get('contentSize', None),
            failed=data.get('failed', None),
            canceled=data.get('canceled', None)
        )

    if casing_strategy == 'pascal':
        return page.FrameResource(
            url=data['Url'],
            type=data['Type'],
            mime_type=data['MimeType'],
            last_modified=data.get('LastModified', None),
            content_size=data.get('ContentSize', None),
            failed=data.get('Failed', None),
            canceled=data.get('Canceled', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__frame_resource_tree__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.FrameResourceTree':

    if casing_strategy == 'snake':
        return page.FrameResourceTree(
            frame=from_dict(
                page.Frame,
                data['frame'],
                casing_strategy
            ),
            child_frames=[
                from_dict(page.FrameResourceTree, item, casing_strategy)
                for item in data.get('child_frames', [])
            ],
            resources=[
                from_dict(page.FrameResource, item, casing_strategy)
                for item in data['resources']
            ]
        )

    if casing_strategy == 'camel':
        return page.FrameResourceTree(
            frame=from_dict(
                page.Frame,
                data['frame'],
                casing_strategy
            ),
            child_frames=[
                from_dict(page.FrameResourceTree, item, casing_strategy)
                for item in data.get('childFrames', [])
            ],
            resources=[
                from_dict(page.FrameResource, item, casing_strategy)
                for item in data['resources']
            ]
        )

    if casing_strategy == 'pascal':
        return page.FrameResourceTree(
            frame=from_dict(
                page.Frame,
                data['Frame'],
                casing_strategy
            ),
            child_frames=[
                from_dict(page.FrameResourceTree, item, casing_strategy)
                for item in data.get('ChildFrames', [])
            ],
            resources=[
                from_dict(page.FrameResource, item, casing_strategy)
                for item in data['Resources']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__frame_tree__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.FrameTree':

    if casing_strategy == 'snake':
        return page.FrameTree(
            frame=from_dict(
                page.Frame,
                data['frame'],
                casing_strategy
            ),
            child_frames=[
                from_dict(page.FrameTree, item, casing_strategy)
                for item in data.get('child_frames', [])
            ]
        )

    if casing_strategy == 'camel':
        return page.FrameTree(
            frame=from_dict(
                page.Frame,
                data['frame'],
                casing_strategy
            ),
            child_frames=[
                from_dict(page.FrameTree, item, casing_strategy)
                for item in data.get('childFrames', [])
            ]
        )

    if casing_strategy == 'pascal':
        return page.FrameTree(
            frame=from_dict(
                page.Frame,
                data['Frame'],
                casing_strategy
            ),
            child_frames=[
                from_dict(page.FrameTree, item, casing_strategy)
                for item in data.get('ChildFrames', [])
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__navigation_entry__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.NavigationEntry':

    if casing_strategy == 'snake':
        return page.NavigationEntry(
            id=data['id'],
            url=data['url'],
            user_typed_url=data['user_typed_url'],
            title=data['title'],
            transition_type=data['transition_type']
        )

    if casing_strategy == 'camel':
        return page.NavigationEntry(
            id=data['id'],
            url=data['url'],
            user_typed_url=data['userTypedURL'],
            title=data['title'],
            transition_type=data['transitionType']
        )

    if casing_strategy == 'pascal':
        return page.NavigationEntry(
            id=data['Id'],
            url=data['Url'],
            user_typed_url=data['UserTypedURL'],
            title=data['Title'],
            transition_type=data['TransitionType']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__screencast_frame_metadata__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.ScreencastFrameMetadata':

    if casing_strategy == 'snake':
        return page.ScreencastFrameMetadata(
            offset_top=data['offset_top'],
            page_scale_factor=data['page_scale_factor'],
            device_width=data['device_width'],
            device_height=data['device_height'],
            scroll_offset_x=data['scroll_offset_x'],
            scroll_offset_y=data['scroll_offset_y'],
            timestamp=data.get('timestamp', None)
        )

    if casing_strategy == 'camel':
        return page.ScreencastFrameMetadata(
            offset_top=data['offsetTop'],
            page_scale_factor=data['pageScaleFactor'],
            device_width=data['deviceWidth'],
            device_height=data['deviceHeight'],
            scroll_offset_x=data['scrollOffsetX'],
            scroll_offset_y=data['scrollOffsetY'],
            timestamp=data.get('timestamp', None)
        )

    if casing_strategy == 'pascal':
        return page.ScreencastFrameMetadata(
            offset_top=data['OffsetTop'],
            page_scale_factor=data['PageScaleFactor'],
            device_width=data['DeviceWidth'],
            device_height=data['DeviceHeight'],
            scroll_offset_x=data['ScrollOffsetX'],
            scroll_offset_y=data['ScrollOffsetY'],
            timestamp=data.get('Timestamp', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__app_manifest_error__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.AppManifestError':

    if casing_strategy == 'snake':
        return page.AppManifestError(
            message=data['message'],
            critical=data['critical'],
            line=data['line'],
            column=data['column']
        )

    if casing_strategy == 'camel':
        return page.AppManifestError(
            message=data['message'],
            critical=data['critical'],
            line=data['line'],
            column=data['column']
        )

    if casing_strategy == 'pascal':
        return page.AppManifestError(
            message=data['Message'],
            critical=data['Critical'],
            line=data['Line'],
            column=data['Column']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__app_manifest_parsed_properties__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.AppManifestParsedProperties':

    if casing_strategy == 'snake':
        return page.AppManifestParsedProperties(
            scope=data['scope']
        )

    if casing_strategy == 'camel':
        return page.AppManifestParsedProperties(
            scope=data['scope']
        )

    if casing_strategy == 'pascal':
        return page.AppManifestParsedProperties(
            scope=data['Scope']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__layout_viewport__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.LayoutViewport':

    if casing_strategy == 'snake':
        return page.LayoutViewport(
            page_x=data['page_x'],
            page_y=data['page_y'],
            client_width=data['client_width'],
            client_height=data['client_height']
        )

    if casing_strategy == 'camel':
        return page.LayoutViewport(
            page_x=data['pageX'],
            page_y=data['pageY'],
            client_width=data['clientWidth'],
            client_height=data['clientHeight']
        )

    if casing_strategy == 'pascal':
        return page.LayoutViewport(
            page_x=data['PageX'],
            page_y=data['PageY'],
            client_width=data['ClientWidth'],
            client_height=data['ClientHeight']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__visual_viewport__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.VisualViewport':

    if casing_strategy == 'snake':
        return page.VisualViewport(
            offset_x=data['offset_x'],
            offset_y=data['offset_y'],
            page_x=data['page_x'],
            page_y=data['page_y'],
            client_width=data['client_width'],
            client_height=data['client_height'],
            scale=data['scale'],
            zoom=data.get('zoom', None)
        )

    if casing_strategy == 'camel':
        return page.VisualViewport(
            offset_x=data['offsetX'],
            offset_y=data['offsetY'],
            page_x=data['pageX'],
            page_y=data['pageY'],
            client_width=data['clientWidth'],
            client_height=data['clientHeight'],
            scale=data['scale'],
            zoom=data.get('zoom', None)
        )

    if casing_strategy == 'pascal':
        return page.VisualViewport(
            offset_x=data['OffsetX'],
            offset_y=data['OffsetY'],
            page_x=data['PageX'],
            page_y=data['PageY'],
            client_width=data['ClientWidth'],
            client_height=data['ClientHeight'],
            scale=data['Scale'],
            zoom=data.get('Zoom', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__viewport__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.Viewport':

    if casing_strategy == 'snake':
        return page.Viewport(
            x=data['x'],
            y=data['y'],
            width=data['width'],
            height=data['height'],
            scale=data['scale']
        )

    if casing_strategy == 'camel':
        return page.Viewport(
            x=data['x'],
            y=data['y'],
            width=data['width'],
            height=data['height'],
            scale=data['scale']
        )

    if casing_strategy == 'pascal':
        return page.Viewport(
            x=data['X'],
            y=data['Y'],
            width=data['Width'],
            height=data['Height'],
            scale=data['Scale']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__font_families__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.FontFamilies':

    if casing_strategy == 'snake':
        return page.FontFamilies(
            standard=data.get('standard', None),
            fixed=data.get('fixed', None),
            serif=data.get('serif', None),
            sans_serif=data.get('sans_serif', None),
            cursive=data.get('cursive', None),
            fantasy=data.get('fantasy', None),
            math=data.get('math', None)
        )

    if casing_strategy == 'camel':
        return page.FontFamilies(
            standard=data.get('standard', None),
            fixed=data.get('fixed', None),
            serif=data.get('serif', None),
            sans_serif=data.get('sansSerif', None),
            cursive=data.get('cursive', None),
            fantasy=data.get('fantasy', None),
            math=data.get('math', None)
        )

    if casing_strategy == 'pascal':
        return page.FontFamilies(
            standard=data.get('Standard', None),
            fixed=data.get('Fixed', None),
            serif=data.get('Serif', None),
            sans_serif=data.get('SansSerif', None),
            cursive=data.get('Cursive', None),
            fantasy=data.get('Fantasy', None),
            math=data.get('Math', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__script_font_families__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.ScriptFontFamilies':

    if casing_strategy == 'snake':
        return page.ScriptFontFamilies(
            script=data['script'],
            font_families=from_dict(
                page.FontFamilies,
                data['font_families'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return page.ScriptFontFamilies(
            script=data['script'],
            font_families=from_dict(
                page.FontFamilies,
                data['fontFamilies'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return page.ScriptFontFamilies(
            script=data['Script'],
            font_families=from_dict(
                page.FontFamilies,
                data['FontFamilies'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__font_sizes__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.FontSizes':

    if casing_strategy == 'snake':
        return page.FontSizes(
            standard=data.get('standard', None),
            fixed=data.get('fixed', None)
        )

    if casing_strategy == 'camel':
        return page.FontSizes(
            standard=data.get('standard', None),
            fixed=data.get('fixed', None)
        )

    if casing_strategy == 'pascal':
        return page.FontSizes(
            standard=data.get('Standard', None),
            fixed=data.get('Fixed', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__installability_error_argument__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.InstallabilityErrorArgument':

    if casing_strategy == 'snake':
        return page.InstallabilityErrorArgument(
            name=data['name'],
            value=data['value']
        )

    if casing_strategy == 'camel':
        return page.InstallabilityErrorArgument(
            name=data['name'],
            value=data['value']
        )

    if casing_strategy == 'pascal':
        return page.InstallabilityErrorArgument(
            name=data['Name'],
            value=data['Value']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__installability_error__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.InstallabilityError':

    if casing_strategy == 'snake':
        return page.InstallabilityError(
            error_id=data['error_id'],
            error_arguments=[
                from_dict(page.InstallabilityErrorArgument, item, casing_strategy)
                for item in data['error_arguments']
            ]
        )

    if casing_strategy == 'camel':
        return page.InstallabilityError(
            error_id=data['errorId'],
            error_arguments=[
                from_dict(page.InstallabilityErrorArgument, item, casing_strategy)
                for item in data['errorArguments']
            ]
        )

    if casing_strategy == 'pascal':
        return page.InstallabilityError(
            error_id=data['ErrorId'],
            error_arguments=[
                from_dict(page.InstallabilityErrorArgument, item, casing_strategy)
                for item in data['ErrorArguments']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__compilation_cache_params__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.CompilationCacheParams':

    if casing_strategy == 'snake':
        return page.CompilationCacheParams(
            url=data['url'],
            eager=data.get('eager', None)
        )

    if casing_strategy == 'camel':
        return page.CompilationCacheParams(
            url=data['url'],
            eager=data.get('eager', None)
        )

    if casing_strategy == 'pascal':
        return page.CompilationCacheParams(
            url=data['Url'],
            eager=data.get('Eager', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__back_forward_cache_not_restored_explanation__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.BackForwardCacheNotRestoredExplanation':

    if casing_strategy == 'snake':
        return page.BackForwardCacheNotRestoredExplanation(
            type=data['type'],
            reason=data['reason'],
            context=data.get('context', None)
        )

    if casing_strategy == 'camel':
        return page.BackForwardCacheNotRestoredExplanation(
            type=data['type'],
            reason=data['reason'],
            context=data.get('context', None)
        )

    if casing_strategy == 'pascal':
        return page.BackForwardCacheNotRestoredExplanation(
            type=data['Type'],
            reason=data['Reason'],
            context=data.get('Context', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__back_forward_cache_not_restored_explanation_tree__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.BackForwardCacheNotRestoredExplanationTree':

    if casing_strategy == 'snake':
        return page.BackForwardCacheNotRestoredExplanationTree(
            url=data['url'],
            explanations=[
                from_dict(page.BackForwardCacheNotRestoredExplanation, item, casing_strategy)
                for item in data['explanations']
            ],
            children=[
                from_dict(page.BackForwardCacheNotRestoredExplanationTree, item, casing_strategy)
                for item in data['children']
            ]
        )

    if casing_strategy == 'camel':
        return page.BackForwardCacheNotRestoredExplanationTree(
            url=data['url'],
            explanations=[
                from_dict(page.BackForwardCacheNotRestoredExplanation, item, casing_strategy)
                for item in data['explanations']
            ],
            children=[
                from_dict(page.BackForwardCacheNotRestoredExplanationTree, item, casing_strategy)
                for item in data['children']
            ]
        )

    if casing_strategy == 'pascal':
        return page.BackForwardCacheNotRestoredExplanationTree(
            url=data['Url'],
            explanations=[
                from_dict(page.BackForwardCacheNotRestoredExplanation, item, casing_strategy)
                for item in data['Explanations']
            ],
            children=[
                from_dict(page.BackForwardCacheNotRestoredExplanationTree, item, casing_strategy)
                for item in data['Children']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _performance__metric__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'performance.Metric':

    if casing_strategy == 'snake':
        return performance.Metric(
            name=data['name'],
            value=data['value']
        )

    if casing_strategy == 'camel':
        return performance.Metric(
            name=data['name'],
            value=data['value']
        )

    if casing_strategy == 'pascal':
        return performance.Metric(
            name=data['Name'],
            value=data['Value']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _performance_timeline__largest_contentful_paint__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'performance_timeline.LargestContentfulPaint':

    if casing_strategy == 'snake':
        return performance_timeline.LargestContentfulPaint(
            render_time=data['render_time'],
            load_time=data['load_time'],
            size=data['size'],
            element_id=data.get('element_id', None),
            url=data.get('url', None),
            node_id=data.get('node_id', None)
        )

    if casing_strategy == 'camel':
        return performance_timeline.LargestContentfulPaint(
            render_time=data['renderTime'],
            load_time=data['loadTime'],
            size=data['size'],
            element_id=data.get('elementId', None),
            url=data.get('url', None),
            node_id=data.get('nodeId', None)
        )

    if casing_strategy == 'pascal':
        return performance_timeline.LargestContentfulPaint(
            render_time=data['RenderTime'],
            load_time=data['LoadTime'],
            size=data['Size'],
            element_id=data.get('ElementId', None),
            url=data.get('Url', None),
            node_id=data.get('NodeId', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _performance_timeline__layout_shift_attribution__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'performance_timeline.LayoutShiftAttribution':

    if casing_strategy == 'snake':
        return performance_timeline.LayoutShiftAttribution(
            previous_rect=from_dict(
                performance_timeline.Rect,
                data['previous_rect'],
                casing_strategy
            ),
            current_rect=from_dict(
                performance_timeline.Rect,
                data['current_rect'],
                casing_strategy
            ),
            node_id=data.get('node_id', None)
        )

    if casing_strategy == 'camel':
        return performance_timeline.LayoutShiftAttribution(
            previous_rect=from_dict(
                performance_timeline.Rect,
                data['previousRect'],
                casing_strategy
            ),
            current_rect=from_dict(
                performance_timeline.Rect,
                data['currentRect'],
                casing_strategy
            ),
            node_id=data.get('nodeId', None)
        )

    if casing_strategy == 'pascal':
        return performance_timeline.LayoutShiftAttribution(
            previous_rect=from_dict(
                performance_timeline.Rect,
                data['PreviousRect'],
                casing_strategy
            ),
            current_rect=from_dict(
                performance_timeline.Rect,
                data['CurrentRect'],
                casing_strategy
            ),
            node_id=data.get('NodeId', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _performance_timeline__layout_shift__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'performance_timeline.LayoutShift':

    if casing_strategy == 'snake':
        return performance_timeline.LayoutShift(
            value=data['value'],
            had_recent_input=data['had_recent_input'],
            last_input_time=data['last_input_time'],
            sources=[
                from_dict(performance_timeline.LayoutShiftAttribution, item, casing_strategy)
                for item in data['sources']
            ]
        )

    if casing_strategy == 'camel':
        return performance_timeline.LayoutShift(
            value=data['value'],
            had_recent_input=data['hadRecentInput'],
            last_input_time=data['lastInputTime'],
            sources=[
                from_dict(performance_timeline.LayoutShiftAttribution, item, casing_strategy)
                for item in data['sources']
            ]
        )

    if casing_strategy == 'pascal':
        return performance_timeline.LayoutShift(
            value=data['Value'],
            had_recent_input=data['HadRecentInput'],
            last_input_time=data['LastInputTime'],
            sources=[
                from_dict(performance_timeline.LayoutShiftAttribution, item, casing_strategy)
                for item in data['Sources']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _performance_timeline__timeline_event__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'performance_timeline.TimelineEvent':

    if casing_strategy == 'snake':
        return performance_timeline.TimelineEvent(
            frame_id=data['frame_id'],
            type=data['type'],
            name=data['name'],
            time=data['time'],
            duration=data.get('duration', None),
            lcp_details=from_dict(
                performance_timeline.LargestContentfulPaint,
                data.get('lcp_details', None),
                casing_strategy
            ),
            layout_shift_details=from_dict(
                performance_timeline.LayoutShift,
                data.get('layout_shift_details', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return performance_timeline.TimelineEvent(
            frame_id=data['frameId'],
            type=data['type'],
            name=data['name'],
            time=data['time'],
            duration=data.get('duration', None),
            lcp_details=from_dict(
                performance_timeline.LargestContentfulPaint,
                data.get('lcpDetails', None),
                casing_strategy
            ),
            layout_shift_details=from_dict(
                performance_timeline.LayoutShift,
                data.get('layoutShiftDetails', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return performance_timeline.TimelineEvent(
            frame_id=data['FrameId'],
            type=data['Type'],
            name=data['Name'],
            time=data['Time'],
            duration=data.get('Duration', None),
            lcp_details=from_dict(
                performance_timeline.LargestContentfulPaint,
                data.get('LcpDetails', None),
                casing_strategy
            ),
            layout_shift_details=from_dict(
                performance_timeline.LayoutShift,
                data.get('LayoutShiftDetails', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _security__certificate_security_state__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'security.CertificateSecurityState':

    if casing_strategy == 'snake':
        return security.CertificateSecurityState(
            protocol=data['protocol'],
            key_exchange=data['key_exchange'],
            key_exchange_group=data.get('key_exchange_group', None),
            cipher=data['cipher'],
            mac=data.get('mac', None),
            certificate=data['certificate'],
            subject_name=data['subject_name'],
            issuer=data['issuer'],
            valid_from=data['valid_from'],
            valid_to=data['valid_to'],
            certificate_network_error=data.get('certificate_network_error', None),
            certificate_has_weak_signature=data['certificate_has_weak_signature'],
            certificate_has_sha1_signature=data['certificate_has_sha1_signature'],
            modern_ssl=data['modern_ssl'],
            obsolete_ssl_protocol=data['obsolete_ssl_protocol'],
            obsolete_ssl_key_exchange=data['obsolete_ssl_key_exchange'],
            obsolete_ssl_cipher=data['obsolete_ssl_cipher'],
            obsolete_ssl_signature=data['obsolete_ssl_signature']
        )

    if casing_strategy == 'camel':
        return security.CertificateSecurityState(
            protocol=data['protocol'],
            key_exchange=data['keyExchange'],
            key_exchange_group=data.get('keyExchangeGroup', None),
            cipher=data['cipher'],
            mac=data.get('mac', None),
            certificate=data['certificate'],
            subject_name=data['subjectName'],
            issuer=data['issuer'],
            valid_from=data['validFrom'],
            valid_to=data['validTo'],
            certificate_network_error=data.get('certificateNetworkError', None),
            certificate_has_weak_signature=data['certificateHasWeakSignature'],
            certificate_has_sha1_signature=data['certificateHasSha1Signature'],
            modern_ssl=data['modernSSL'],
            obsolete_ssl_protocol=data['obsoleteSslProtocol'],
            obsolete_ssl_key_exchange=data['obsoleteSslKeyExchange'],
            obsolete_ssl_cipher=data['obsoleteSslCipher'],
            obsolete_ssl_signature=data['obsoleteSslSignature']
        )

    if casing_strategy == 'pascal':
        return security.CertificateSecurityState(
            protocol=data['Protocol'],
            key_exchange=data['KeyExchange'],
            key_exchange_group=data.get('KeyExchangeGroup', None),
            cipher=data['Cipher'],
            mac=data.get('Mac', None),
            certificate=data['Certificate'],
            subject_name=data['SubjectName'],
            issuer=data['Issuer'],
            valid_from=data['ValidFrom'],
            valid_to=data['ValidTo'],
            certificate_network_error=data.get('CertificateNetworkError', None),
            certificate_has_weak_signature=data['CertificateHasWeakSignature'],
            certificate_has_sha1_signature=data['CertificateHasSha1Signature'],
            modern_ssl=data['ModernSSL'],
            obsolete_ssl_protocol=data['ObsoleteSslProtocol'],
            obsolete_ssl_key_exchange=data['ObsoleteSslKeyExchange'],
            obsolete_ssl_cipher=data['ObsoleteSslCipher'],
            obsolete_ssl_signature=data['ObsoleteSslSignature']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _security__safety_tip_info__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'security.SafetyTipInfo':

    if casing_strategy == 'snake':
        return security.SafetyTipInfo(
            safety_tip_status=data['safety_tip_status'],
            safe_url=data.get('safe_url', None)
        )

    if casing_strategy == 'camel':
        return security.SafetyTipInfo(
            safety_tip_status=data['safetyTipStatus'],
            safe_url=data.get('safeUrl', None)
        )

    if casing_strategy == 'pascal':
        return security.SafetyTipInfo(
            safety_tip_status=data['SafetyTipStatus'],
            safe_url=data.get('SafeUrl', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _security__visible_security_state__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'security.VisibleSecurityState':

    if casing_strategy == 'snake':
        return security.VisibleSecurityState(
            security_state=data['security_state'],
            certificate_security_state=from_dict(
                security.CertificateSecurityState,
                data.get('certificate_security_state', None),
                casing_strategy
            ),
            safety_tip_info=from_dict(
                security.SafetyTipInfo,
                data.get('safety_tip_info', None),
                casing_strategy
            ),
            security_state_issue_ids=data['security_state_issue_ids']
        )

    if casing_strategy == 'camel':
        return security.VisibleSecurityState(
            security_state=data['securityState'],
            certificate_security_state=from_dict(
                security.CertificateSecurityState,
                data.get('certificateSecurityState', None),
                casing_strategy
            ),
            safety_tip_info=from_dict(
                security.SafetyTipInfo,
                data.get('safetyTipInfo', None),
                casing_strategy
            ),
            security_state_issue_ids=data['securityStateIssueIds']
        )

    if casing_strategy == 'pascal':
        return security.VisibleSecurityState(
            security_state=data['SecurityState'],
            certificate_security_state=from_dict(
                security.CertificateSecurityState,
                data.get('CertificateSecurityState', None),
                casing_strategy
            ),
            safety_tip_info=from_dict(
                security.SafetyTipInfo,
                data.get('SafetyTipInfo', None),
                casing_strategy
            ),
            security_state_issue_ids=data['SecurityStateIssueIds']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _security__security_state_explanation__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'security.SecurityStateExplanation':

    if casing_strategy == 'snake':
        return security.SecurityStateExplanation(
            security_state=data['security_state'],
            title=data['title'],
            summary=data['summary'],
            description=data['description'],
            mixed_content_type=data['mixed_content_type'],
            certificate=data['certificate'],
            recommendations=data.get('recommendations', [])
        )

    if casing_strategy == 'camel':
        return security.SecurityStateExplanation(
            security_state=data['securityState'],
            title=data['title'],
            summary=data['summary'],
            description=data['description'],
            mixed_content_type=data['mixedContentType'],
            certificate=data['certificate'],
            recommendations=data.get('recommendations', [])
        )

    if casing_strategy == 'pascal':
        return security.SecurityStateExplanation(
            security_state=data['SecurityState'],
            title=data['Title'],
            summary=data['Summary'],
            description=data['Description'],
            mixed_content_type=data['MixedContentType'],
            certificate=data['Certificate'],
            recommendations=data.get('Recommendations', [])
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _security__insecure_content_status__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'security.InsecureContentStatus':

    if casing_strategy == 'snake':
        return security.InsecureContentStatus(
            ran_mixed_content=data['ran_mixed_content'],
            displayed_mixed_content=data['displayed_mixed_content'],
            contained_mixed_form=data['contained_mixed_form'],
            ran_content_with_cert_errors=data['ran_content_with_cert_errors'],
            displayed_content_with_cert_errors=data['displayed_content_with_cert_errors'],
            ran_insecure_content_style=data['ran_insecure_content_style'],
            displayed_insecure_content_style=data['displayed_insecure_content_style']
        )

    if casing_strategy == 'camel':
        return security.InsecureContentStatus(
            ran_mixed_content=data['ranMixedContent'],
            displayed_mixed_content=data['displayedMixedContent'],
            contained_mixed_form=data['containedMixedForm'],
            ran_content_with_cert_errors=data['ranContentWithCertErrors'],
            displayed_content_with_cert_errors=data['displayedContentWithCertErrors'],
            ran_insecure_content_style=data['ranInsecureContentStyle'],
            displayed_insecure_content_style=data['displayedInsecureContentStyle']
        )

    if casing_strategy == 'pascal':
        return security.InsecureContentStatus(
            ran_mixed_content=data['RanMixedContent'],
            displayed_mixed_content=data['DisplayedMixedContent'],
            contained_mixed_form=data['ContainedMixedForm'],
            ran_content_with_cert_errors=data['RanContentWithCertErrors'],
            displayed_content_with_cert_errors=data['DisplayedContentWithCertErrors'],
            ran_insecure_content_style=data['RanInsecureContentStyle'],
            displayed_insecure_content_style=data['DisplayedInsecureContentStyle']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _service_worker__service_worker_registration__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'service_worker.ServiceWorkerRegistration':

    if casing_strategy == 'snake':
        return service_worker.ServiceWorkerRegistration(
            registration_id=data['registration_id'],
            scope_url=data['scope_url'],
            is_deleted=data['is_deleted']
        )

    if casing_strategy == 'camel':
        return service_worker.ServiceWorkerRegistration(
            registration_id=data['registrationId'],
            scope_url=data['scopeURL'],
            is_deleted=data['isDeleted']
        )

    if casing_strategy == 'pascal':
        return service_worker.ServiceWorkerRegistration(
            registration_id=data['RegistrationId'],
            scope_url=data['ScopeURL'],
            is_deleted=data['IsDeleted']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _service_worker__service_worker_version__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'service_worker.ServiceWorkerVersion':

    if casing_strategy == 'snake':
        return service_worker.ServiceWorkerVersion(
            version_id=data['version_id'],
            registration_id=data['registration_id'],
            script_url=data['script_url'],
            running_status=data['running_status'],
            status=data['status'],
            script_last_modified=data.get('script_last_modified', None),
            script_response_time=data.get('script_response_time', None),
            controlled_clients=data.get('controlled_clients', []),
            target_id=data.get('target_id', None)
        )

    if casing_strategy == 'camel':
        return service_worker.ServiceWorkerVersion(
            version_id=data['versionId'],
            registration_id=data['registrationId'],
            script_url=data['scriptURL'],
            running_status=data['runningStatus'],
            status=data['status'],
            script_last_modified=data.get('scriptLastModified', None),
            script_response_time=data.get('scriptResponseTime', None),
            controlled_clients=data.get('controlledClients', []),
            target_id=data.get('targetId', None)
        )

    if casing_strategy == 'pascal':
        return service_worker.ServiceWorkerVersion(
            version_id=data['VersionId'],
            registration_id=data['RegistrationId'],
            script_url=data['ScriptURL'],
            running_status=data['RunningStatus'],
            status=data['Status'],
            script_last_modified=data.get('ScriptLastModified', None),
            script_response_time=data.get('ScriptResponseTime', None),
            controlled_clients=data.get('ControlledClients', []),
            target_id=data.get('TargetId', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _service_worker__service_worker_error_message__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'service_worker.ServiceWorkerErrorMessage':

    if casing_strategy == 'snake':
        return service_worker.ServiceWorkerErrorMessage(
            error_message=data['error_message'],
            registration_id=data['registration_id'],
            version_id=data['version_id'],
            source_url=data['source_url'],
            line_number=data['line_number'],
            column_number=data['column_number']
        )

    if casing_strategy == 'camel':
        return service_worker.ServiceWorkerErrorMessage(
            error_message=data['errorMessage'],
            registration_id=data['registrationId'],
            version_id=data['versionId'],
            source_url=data['sourceURL'],
            line_number=data['lineNumber'],
            column_number=data['columnNumber']
        )

    if casing_strategy == 'pascal':
        return service_worker.ServiceWorkerErrorMessage(
            error_message=data['ErrorMessage'],
            registration_id=data['RegistrationId'],
            version_id=data['VersionId'],
            source_url=data['SourceURL'],
            line_number=data['LineNumber'],
            column_number=data['ColumnNumber']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__usage_for_type__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.UsageForType':

    if casing_strategy == 'snake':
        return storage.UsageForType(
            storage_type=data['storage_type'],
            usage=data['usage']
        )

    if casing_strategy == 'camel':
        return storage.UsageForType(
            storage_type=data['storageType'],
            usage=data['usage']
        )

    if casing_strategy == 'pascal':
        return storage.UsageForType(
            storage_type=data['StorageType'],
            usage=data['Usage']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__trust_tokens__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.TrustTokens':

    if casing_strategy == 'snake':
        return storage.TrustTokens(
            issuer_origin=data['issuer_origin'],
            count=data['count']
        )

    if casing_strategy == 'camel':
        return storage.TrustTokens(
            issuer_origin=data['issuerOrigin'],
            count=data['count']
        )

    if casing_strategy == 'pascal':
        return storage.TrustTokens(
            issuer_origin=data['IssuerOrigin'],
            count=data['Count']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__interest_group_ad__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.InterestGroupAd':

    if casing_strategy == 'snake':
        return storage.InterestGroupAd(
            render_url=data['render_url'],
            metadata=data.get('metadata', None)
        )

    if casing_strategy == 'camel':
        return storage.InterestGroupAd(
            render_url=data['renderUrl'],
            metadata=data.get('metadata', None)
        )

    if casing_strategy == 'pascal':
        return storage.InterestGroupAd(
            render_url=data['RenderUrl'],
            metadata=data.get('Metadata', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__interest_group_details__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.InterestGroupDetails':

    if casing_strategy == 'snake':
        return storage.InterestGroupDetails(
            owner_origin=data['owner_origin'],
            name=data['name'],
            expiration_time=data['expiration_time'],
            joining_origin=data['joining_origin'],
            bidding_url=data.get('bidding_url', None),
            bidding_wasm_helper_url=data.get('bidding_wasm_helper_url', None),
            update_url=data.get('update_url', None),
            trusted_bidding_signals_url=data.get('trusted_bidding_signals_url', None),
            trusted_bidding_signals_keys=data['trusted_bidding_signals_keys'],
            user_bidding_signals=data.get('user_bidding_signals', None),
            ads=[
                from_dict(storage.InterestGroupAd, item, casing_strategy)
                for item in data['ads']
            ],
            ad_components=[
                from_dict(storage.InterestGroupAd, item, casing_strategy)
                for item in data['ad_components']
            ]
        )

    if casing_strategy == 'camel':
        return storage.InterestGroupDetails(
            owner_origin=data['ownerOrigin'],
            name=data['name'],
            expiration_time=data['expirationTime'],
            joining_origin=data['joiningOrigin'],
            bidding_url=data.get('biddingUrl', None),
            bidding_wasm_helper_url=data.get('biddingWasmHelperUrl', None),
            update_url=data.get('updateUrl', None),
            trusted_bidding_signals_url=data.get('trustedBiddingSignalsUrl', None),
            trusted_bidding_signals_keys=data['trustedBiddingSignalsKeys'],
            user_bidding_signals=data.get('userBiddingSignals', None),
            ads=[
                from_dict(storage.InterestGroupAd, item, casing_strategy)
                for item in data['ads']
            ],
            ad_components=[
                from_dict(storage.InterestGroupAd, item, casing_strategy)
                for item in data['adComponents']
            ]
        )

    if casing_strategy == 'pascal':
        return storage.InterestGroupDetails(
            owner_origin=data['OwnerOrigin'],
            name=data['Name'],
            expiration_time=data['ExpirationTime'],
            joining_origin=data['JoiningOrigin'],
            bidding_url=data.get('BiddingUrl', None),
            bidding_wasm_helper_url=data.get('BiddingWasmHelperUrl', None),
            update_url=data.get('UpdateUrl', None),
            trusted_bidding_signals_url=data.get('TrustedBiddingSignalsUrl', None),
            trusted_bidding_signals_keys=data['TrustedBiddingSignalsKeys'],
            user_bidding_signals=data.get('UserBiddingSignals', None),
            ads=[
                from_dict(storage.InterestGroupAd, item, casing_strategy)
                for item in data['Ads']
            ],
            ad_components=[
                from_dict(storage.InterestGroupAd, item, casing_strategy)
                for item in data['AdComponents']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__shared_storage_entry__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.SharedStorageEntry':

    if casing_strategy == 'snake':
        return storage.SharedStorageEntry(
            key=data['key'],
            value=data['value']
        )

    if casing_strategy == 'camel':
        return storage.SharedStorageEntry(
            key=data['key'],
            value=data['value']
        )

    if casing_strategy == 'pascal':
        return storage.SharedStorageEntry(
            key=data['Key'],
            value=data['Value']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__shared_storage_metadata__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.SharedStorageMetadata':

    if casing_strategy == 'snake':
        return storage.SharedStorageMetadata(
            creation_time=data['creation_time'],
            length=data['length'],
            remaining_budget=data['remaining_budget']
        )

    if casing_strategy == 'camel':
        return storage.SharedStorageMetadata(
            creation_time=data['creationTime'],
            length=data['length'],
            remaining_budget=data['remainingBudget']
        )

    if casing_strategy == 'pascal':
        return storage.SharedStorageMetadata(
            creation_time=data['CreationTime'],
            length=data['Length'],
            remaining_budget=data['RemainingBudget']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__shared_storage_reporting_metadata__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.SharedStorageReportingMetadata':

    if casing_strategy == 'snake':
        return storage.SharedStorageReportingMetadata(
            event_type=data['event_type'],
            reporting_url=data['reporting_url']
        )

    if casing_strategy == 'camel':
        return storage.SharedStorageReportingMetadata(
            event_type=data['eventType'],
            reporting_url=data['reportingUrl']
        )

    if casing_strategy == 'pascal':
        return storage.SharedStorageReportingMetadata(
            event_type=data['EventType'],
            reporting_url=data['ReportingUrl']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__shared_storage_url_with_metadata__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.SharedStorageUrlWithMetadata':

    if casing_strategy == 'snake':
        return storage.SharedStorageUrlWithMetadata(
            url=data['url'],
            reporting_metadata=[
                from_dict(storage.SharedStorageReportingMetadata, item, casing_strategy)
                for item in data['reporting_metadata']
            ]
        )

    if casing_strategy == 'camel':
        return storage.SharedStorageUrlWithMetadata(
            url=data['url'],
            reporting_metadata=[
                from_dict(storage.SharedStorageReportingMetadata, item, casing_strategy)
                for item in data['reportingMetadata']
            ]
        )

    if casing_strategy == 'pascal':
        return storage.SharedStorageUrlWithMetadata(
            url=data['Url'],
            reporting_metadata=[
                from_dict(storage.SharedStorageReportingMetadata, item, casing_strategy)
                for item in data['ReportingMetadata']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__shared_storage_access_params__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.SharedStorageAccessParams':

    if casing_strategy == 'snake':
        return storage.SharedStorageAccessParams(
            script_source_url=data.get('script_source_url', None),
            operation_name=data.get('operation_name', None),
            serialized_data=data.get('serialized_data', None),
            urls_with_metadata=[
                from_dict(storage.SharedStorageUrlWithMetadata, item, casing_strategy)
                for item in data.get('urls_with_metadata', [])
            ],
            key=data.get('key', None),
            value=data.get('value', None),
            ignore_if_present=data.get('ignore_if_present', None)
        )

    if casing_strategy == 'camel':
        return storage.SharedStorageAccessParams(
            script_source_url=data.get('scriptSourceUrl', None),
            operation_name=data.get('operationName', None),
            serialized_data=data.get('serializedData', None),
            urls_with_metadata=[
                from_dict(storage.SharedStorageUrlWithMetadata, item, casing_strategy)
                for item in data.get('urlsWithMetadata', [])
            ],
            key=data.get('key', None),
            value=data.get('value', None),
            ignore_if_present=data.get('ignoreIfPresent', None)
        )

    if casing_strategy == 'pascal':
        return storage.SharedStorageAccessParams(
            script_source_url=data.get('ScriptSourceUrl', None),
            operation_name=data.get('OperationName', None),
            serialized_data=data.get('SerializedData', None),
            urls_with_metadata=[
                from_dict(storage.SharedStorageUrlWithMetadata, item, casing_strategy)
                for item in data.get('UrlsWithMetadata', [])
            ],
            key=data.get('Key', None),
            value=data.get('Value', None),
            ignore_if_present=data.get('IgnoreIfPresent', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__storage_bucket__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.StorageBucket':

    if casing_strategy == 'snake':
        return storage.StorageBucket(
            storage_key=data['storage_key'],
            name=data.get('name', None)
        )

    if casing_strategy == 'camel':
        return storage.StorageBucket(
            storage_key=data['storageKey'],
            name=data.get('name', None)
        )

    if casing_strategy == 'pascal':
        return storage.StorageBucket(
            storage_key=data['StorageKey'],
            name=data.get('Name', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__storage_bucket_info__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.StorageBucketInfo':

    if casing_strategy == 'snake':
        return storage.StorageBucketInfo(
            bucket=from_dict(
                storage.StorageBucket,
                data['bucket'],
                casing_strategy
            ),
            id=data['id'],
            expiration=data['expiration'],
            quota=data['quota'],
            persistent=data['persistent'],
            durability=data['durability']
        )

    if casing_strategy == 'camel':
        return storage.StorageBucketInfo(
            bucket=from_dict(
                storage.StorageBucket,
                data['bucket'],
                casing_strategy
            ),
            id=data['id'],
            expiration=data['expiration'],
            quota=data['quota'],
            persistent=data['persistent'],
            durability=data['durability']
        )

    if casing_strategy == 'pascal':
        return storage.StorageBucketInfo(
            bucket=from_dict(
                storage.StorageBucket,
                data['Bucket'],
                casing_strategy
            ),
            id=data['Id'],
            expiration=data['Expiration'],
            quota=data['Quota'],
            persistent=data['Persistent'],
            durability=data['Durability']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__attribution_reporting_filter_data_entry__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.AttributionReportingFilterDataEntry':

    if casing_strategy == 'snake':
        return storage.AttributionReportingFilterDataEntry(
            key=data['key'],
            values=data['values']
        )

    if casing_strategy == 'camel':
        return storage.AttributionReportingFilterDataEntry(
            key=data['key'],
            values=data['values']
        )

    if casing_strategy == 'pascal':
        return storage.AttributionReportingFilterDataEntry(
            key=data['Key'],
            values=data['Values']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__attribution_reporting_aggregation_keys_entry__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.AttributionReportingAggregationKeysEntry':

    if casing_strategy == 'snake':
        return storage.AttributionReportingAggregationKeysEntry(
            key=data['key'],
            value=data['value']
        )

    if casing_strategy == 'camel':
        return storage.AttributionReportingAggregationKeysEntry(
            key=data['key'],
            value=data['value']
        )

    if casing_strategy == 'pascal':
        return storage.AttributionReportingAggregationKeysEntry(
            key=data['Key'],
            value=data['Value']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__attribution_reporting_event_report_windows__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.AttributionReportingEventReportWindows':

    if casing_strategy == 'snake':
        return storage.AttributionReportingEventReportWindows(
            start=data['start'],
            ends=data['ends']
        )

    if casing_strategy == 'camel':
        return storage.AttributionReportingEventReportWindows(
            start=data['start'],
            ends=data['ends']
        )

    if casing_strategy == 'pascal':
        return storage.AttributionReportingEventReportWindows(
            start=data['Start'],
            ends=data['Ends']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__attribution_reporting_source_registration__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.AttributionReportingSourceRegistration':

    if casing_strategy == 'snake':
        return storage.AttributionReportingSourceRegistration(
            time=data['time'],
            expiry=data.get('expiry', None),
            event_report_window=data.get('event_report_window', None),
            event_report_windows=from_dict(
                storage.AttributionReportingEventReportWindows,
                data.get('event_report_windows', None),
                casing_strategy
            ),
            aggregatable_report_window=data.get('aggregatable_report_window', None),
            type=data['type'],
            source_origin=data['source_origin'],
            reporting_origin=data['reporting_origin'],
            destination_sites=data['destination_sites'],
            event_id=data['event_id'],
            priority=data['priority'],
            filter_data=[
                from_dict(storage.AttributionReportingFilterDataEntry, item, casing_strategy)
                for item in data['filter_data']
            ],
            aggregation_keys=[
                from_dict(storage.AttributionReportingAggregationKeysEntry, item, casing_strategy)
                for item in data['aggregation_keys']
            ],
            debug_key=data.get('debug_key', None)
        )

    if casing_strategy == 'camel':
        return storage.AttributionReportingSourceRegistration(
            time=data['time'],
            expiry=data.get('expiry', None),
            event_report_window=data.get('eventReportWindow', None),
            event_report_windows=from_dict(
                storage.AttributionReportingEventReportWindows,
                data.get('eventReportWindows', None),
                casing_strategy
            ),
            aggregatable_report_window=data.get('aggregatableReportWindow', None),
            type=data['type'],
            source_origin=data['sourceOrigin'],
            reporting_origin=data['reportingOrigin'],
            destination_sites=data['destinationSites'],
            event_id=data['eventId'],
            priority=data['priority'],
            filter_data=[
                from_dict(storage.AttributionReportingFilterDataEntry, item, casing_strategy)
                for item in data['filterData']
            ],
            aggregation_keys=[
                from_dict(storage.AttributionReportingAggregationKeysEntry, item, casing_strategy)
                for item in data['aggregationKeys']
            ],
            debug_key=data.get('debugKey', None)
        )

    if casing_strategy == 'pascal':
        return storage.AttributionReportingSourceRegistration(
            time=data['Time'],
            expiry=data.get('Expiry', None),
            event_report_window=data.get('EventReportWindow', None),
            event_report_windows=from_dict(
                storage.AttributionReportingEventReportWindows,
                data.get('EventReportWindows', None),
                casing_strategy
            ),
            aggregatable_report_window=data.get('AggregatableReportWindow', None),
            type=data['Type'],
            source_origin=data['SourceOrigin'],
            reporting_origin=data['ReportingOrigin'],
            destination_sites=data['DestinationSites'],
            event_id=data['EventId'],
            priority=data['Priority'],
            filter_data=[
                from_dict(storage.AttributionReportingFilterDataEntry, item, casing_strategy)
                for item in data['FilterData']
            ],
            aggregation_keys=[
                from_dict(storage.AttributionReportingAggregationKeysEntry, item, casing_strategy)
                for item in data['AggregationKeys']
            ],
            debug_key=data.get('DebugKey', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _system_info__gpu_device__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'system_info.GPUDevice':

    if casing_strategy == 'snake':
        return system_info.GPUDevice(
            vendor_id=data['vendor_id'],
            device_id=data['device_id'],
            sub_sys_id=data.get('sub_sys_id', None),
            revision=data.get('revision', None),
            vendor_string=data['vendor_string'],
            device_string=data['device_string'],
            driver_vendor=data['driver_vendor'],
            driver_version=data['driver_version']
        )

    if casing_strategy == 'camel':
        return system_info.GPUDevice(
            vendor_id=data['vendorId'],
            device_id=data['deviceId'],
            sub_sys_id=data.get('subSysId', None),
            revision=data.get('revision', None),
            vendor_string=data['vendorString'],
            device_string=data['deviceString'],
            driver_vendor=data['driverVendor'],
            driver_version=data['driverVersion']
        )

    if casing_strategy == 'pascal':
        return system_info.GPUDevice(
            vendor_id=data['VendorId'],
            device_id=data['DeviceId'],
            sub_sys_id=data.get('SubSysId', None),
            revision=data.get('Revision', None),
            vendor_string=data['VendorString'],
            device_string=data['DeviceString'],
            driver_vendor=data['DriverVendor'],
            driver_version=data['DriverVersion']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _system_info__size__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'system_info.Size':

    if casing_strategy == 'snake':
        return system_info.Size(
            width=data['width'],
            height=data['height']
        )

    if casing_strategy == 'camel':
        return system_info.Size(
            width=data['width'],
            height=data['height']
        )

    if casing_strategy == 'pascal':
        return system_info.Size(
            width=data['Width'],
            height=data['Height']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _system_info__video_decode_accelerator_capability__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'system_info.VideoDecodeAcceleratorCapability':

    if casing_strategy == 'snake':
        return system_info.VideoDecodeAcceleratorCapability(
            profile=data['profile'],
            max_resolution=from_dict(
                system_info.Size,
                data['max_resolution'],
                casing_strategy
            ),
            min_resolution=from_dict(
                system_info.Size,
                data['min_resolution'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return system_info.VideoDecodeAcceleratorCapability(
            profile=data['profile'],
            max_resolution=from_dict(
                system_info.Size,
                data['maxResolution'],
                casing_strategy
            ),
            min_resolution=from_dict(
                system_info.Size,
                data['minResolution'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return system_info.VideoDecodeAcceleratorCapability(
            profile=data['Profile'],
            max_resolution=from_dict(
                system_info.Size,
                data['MaxResolution'],
                casing_strategy
            ),
            min_resolution=from_dict(
                system_info.Size,
                data['MinResolution'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _system_info__video_encode_accelerator_capability__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'system_info.VideoEncodeAcceleratorCapability':

    if casing_strategy == 'snake':
        return system_info.VideoEncodeAcceleratorCapability(
            profile=data['profile'],
            max_resolution=from_dict(
                system_info.Size,
                data['max_resolution'],
                casing_strategy
            ),
            max_framerate_numerator=data['max_framerate_numerator'],
            max_framerate_denominator=data['max_framerate_denominator']
        )

    if casing_strategy == 'camel':
        return system_info.VideoEncodeAcceleratorCapability(
            profile=data['profile'],
            max_resolution=from_dict(
                system_info.Size,
                data['maxResolution'],
                casing_strategy
            ),
            max_framerate_numerator=data['maxFramerateNumerator'],
            max_framerate_denominator=data['maxFramerateDenominator']
        )

    if casing_strategy == 'pascal':
        return system_info.VideoEncodeAcceleratorCapability(
            profile=data['Profile'],
            max_resolution=from_dict(
                system_info.Size,
                data['MaxResolution'],
                casing_strategy
            ),
            max_framerate_numerator=data['MaxFramerateNumerator'],
            max_framerate_denominator=data['MaxFramerateDenominator']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _system_info__image_decode_accelerator_capability__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'system_info.ImageDecodeAcceleratorCapability':

    if casing_strategy == 'snake':
        return system_info.ImageDecodeAcceleratorCapability(
            image_type=data['image_type'],
            max_dimensions=from_dict(
                system_info.Size,
                data['max_dimensions'],
                casing_strategy
            ),
            min_dimensions=from_dict(
                system_info.Size,
                data['min_dimensions'],
                casing_strategy
            ),
            subsamplings=data['subsamplings']
        )

    if casing_strategy == 'camel':
        return system_info.ImageDecodeAcceleratorCapability(
            image_type=data['imageType'],
            max_dimensions=from_dict(
                system_info.Size,
                data['maxDimensions'],
                casing_strategy
            ),
            min_dimensions=from_dict(
                system_info.Size,
                data['minDimensions'],
                casing_strategy
            ),
            subsamplings=data['subsamplings']
        )

    if casing_strategy == 'pascal':
        return system_info.ImageDecodeAcceleratorCapability(
            image_type=data['ImageType'],
            max_dimensions=from_dict(
                system_info.Size,
                data['MaxDimensions'],
                casing_strategy
            ),
            min_dimensions=from_dict(
                system_info.Size,
                data['MinDimensions'],
                casing_strategy
            ),
            subsamplings=data['Subsamplings']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _system_info__gpu_info__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'system_info.GPUInfo':

    if casing_strategy == 'snake':
        return system_info.GPUInfo(
            devices=[
                from_dict(system_info.GPUDevice, item, casing_strategy)
                for item in data['devices']
            ],
            aux_attributes=data.get('aux_attributes', None),
            feature_status=data.get('feature_status', None),
            driver_bug_workarounds=data['driver_bug_workarounds'],
            video_decoding=[
                from_dict(system_info.VideoDecodeAcceleratorCapability, item, casing_strategy)
                for item in data['video_decoding']
            ],
            video_encoding=[
                from_dict(system_info.VideoEncodeAcceleratorCapability, item, casing_strategy)
                for item in data['video_encoding']
            ],
            image_decoding=[
                from_dict(system_info.ImageDecodeAcceleratorCapability, item, casing_strategy)
                for item in data['image_decoding']
            ]
        )

    if casing_strategy == 'camel':
        return system_info.GPUInfo(
            devices=[
                from_dict(system_info.GPUDevice, item, casing_strategy)
                for item in data['devices']
            ],
            aux_attributes=data.get('auxAttributes', None),
            feature_status=data.get('featureStatus', None),
            driver_bug_workarounds=data['driverBugWorkarounds'],
            video_decoding=[
                from_dict(system_info.VideoDecodeAcceleratorCapability, item, casing_strategy)
                for item in data['videoDecoding']
            ],
            video_encoding=[
                from_dict(system_info.VideoEncodeAcceleratorCapability, item, casing_strategy)
                for item in data['videoEncoding']
            ],
            image_decoding=[
                from_dict(system_info.ImageDecodeAcceleratorCapability, item, casing_strategy)
                for item in data['imageDecoding']
            ]
        )

    if casing_strategy == 'pascal':
        return system_info.GPUInfo(
            devices=[
                from_dict(system_info.GPUDevice, item, casing_strategy)
                for item in data['Devices']
            ],
            aux_attributes=data.get('AuxAttributes', None),
            feature_status=data.get('FeatureStatus', None),
            driver_bug_workarounds=data['DriverBugWorkarounds'],
            video_decoding=[
                from_dict(system_info.VideoDecodeAcceleratorCapability, item, casing_strategy)
                for item in data['VideoDecoding']
            ],
            video_encoding=[
                from_dict(system_info.VideoEncodeAcceleratorCapability, item, casing_strategy)
                for item in data['VideoEncoding']
            ],
            image_decoding=[
                from_dict(system_info.ImageDecodeAcceleratorCapability, item, casing_strategy)
                for item in data['ImageDecoding']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _system_info__process_info__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'system_info.ProcessInfo':

    if casing_strategy == 'snake':
        return system_info.ProcessInfo(
            type=data['type'],
            id=data['id'],
            cpu_time=data['cpu_time']
        )

    if casing_strategy == 'camel':
        return system_info.ProcessInfo(
            type=data['type'],
            id=data['id'],
            cpu_time=data['cpuTime']
        )

    if casing_strategy == 'pascal':
        return system_info.ProcessInfo(
            type=data['Type'],
            id=data['Id'],
            cpu_time=data['CpuTime']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _target__target_info__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'target.TargetInfo':

    if casing_strategy == 'snake':
        return target.TargetInfo(
            target_id=data['target_id'],
            type=data['type'],
            title=data['title'],
            url=data['url'],
            attached=data['attached'],
            opener_id=data.get('opener_id', None),
            can_access_opener=data['can_access_opener'],
            opener_frame_id=data.get('opener_frame_id', None),
            browser_context_id=data.get('browser_context_id', None),
            subtype=data.get('subtype', None)
        )

    if casing_strategy == 'camel':
        return target.TargetInfo(
            target_id=data['targetId'],
            type=data['type'],
            title=data['title'],
            url=data['url'],
            attached=data['attached'],
            opener_id=data.get('openerId', None),
            can_access_opener=data['canAccessOpener'],
            opener_frame_id=data.get('openerFrameId', None),
            browser_context_id=data.get('browserContextId', None),
            subtype=data.get('subtype', None)
        )

    if casing_strategy == 'pascal':
        return target.TargetInfo(
            target_id=data['TargetId'],
            type=data['Type'],
            title=data['Title'],
            url=data['Url'],
            attached=data['Attached'],
            opener_id=data.get('OpenerId', None),
            can_access_opener=data['CanAccessOpener'],
            opener_frame_id=data.get('OpenerFrameId', None),
            browser_context_id=data.get('BrowserContextId', None),
            subtype=data.get('Subtype', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _target__filter_entry__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'target.FilterEntry':

    if casing_strategy == 'snake':
        return target.FilterEntry(
            exclude=data.get('exclude', None),
            type=data.get('type', None)
        )

    if casing_strategy == 'camel':
        return target.FilterEntry(
            exclude=data.get('exclude', None),
            type=data.get('type', None)
        )

    if casing_strategy == 'pascal':
        return target.FilterEntry(
            exclude=data.get('Exclude', None),
            type=data.get('Type', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _target__remote_location__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'target.RemoteLocation':

    if casing_strategy == 'snake':
        return target.RemoteLocation(
            host=data['host'],
            port=data['port']
        )

    if casing_strategy == 'camel':
        return target.RemoteLocation(
            host=data['host'],
            port=data['port']
        )

    if casing_strategy == 'pascal':
        return target.RemoteLocation(
            host=data['Host'],
            port=data['Port']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _tracing__trace_config__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'tracing.TraceConfig':

    if casing_strategy == 'snake':
        return tracing.TraceConfig(
            record_mode=data.get('record_mode', None),
            trace_buffer_size_in_kb=data.get('trace_buffer_size_in_kb', None),
            enable_sampling=data.get('enable_sampling', None),
            enable_systrace=data.get('enable_systrace', None),
            enable_argument_filter=data.get('enable_argument_filter', None),
            included_categories=data.get('included_categories', []),
            excluded_categories=data.get('excluded_categories', []),
            synthetic_delays=data.get('synthetic_delays', []),
            memory_dump_config=data.get('memory_dump_config', None)
        )

    if casing_strategy == 'camel':
        return tracing.TraceConfig(
            record_mode=data.get('recordMode', None),
            trace_buffer_size_in_kb=data.get('traceBufferSizeInKb', None),
            enable_sampling=data.get('enableSampling', None),
            enable_systrace=data.get('enableSystrace', None),
            enable_argument_filter=data.get('enableArgumentFilter', None),
            included_categories=data.get('includedCategories', []),
            excluded_categories=data.get('excludedCategories', []),
            synthetic_delays=data.get('syntheticDelays', []),
            memory_dump_config=data.get('memoryDumpConfig', None)
        )

    if casing_strategy == 'pascal':
        return tracing.TraceConfig(
            record_mode=data.get('RecordMode', None),
            trace_buffer_size_in_kb=data.get('TraceBufferSizeInKb', None),
            enable_sampling=data.get('EnableSampling', None),
            enable_systrace=data.get('EnableSystrace', None),
            enable_argument_filter=data.get('EnableArgumentFilter', None),
            included_categories=data.get('IncludedCategories', []),
            excluded_categories=data.get('ExcludedCategories', []),
            synthetic_delays=data.get('SyntheticDelays', []),
            memory_dump_config=data.get('MemoryDumpConfig', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _fetch__request_pattern__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'fetch.RequestPattern':

    if casing_strategy == 'snake':
        return fetch.RequestPattern(
            url_pattern=data.get('url_pattern', None),
            resource_type=data.get('resource_type', None),
            request_stage=data.get('request_stage', None)
        )

    if casing_strategy == 'camel':
        return fetch.RequestPattern(
            url_pattern=data.get('urlPattern', None),
            resource_type=data.get('resourceType', None),
            request_stage=data.get('requestStage', None)
        )

    if casing_strategy == 'pascal':
        return fetch.RequestPattern(
            url_pattern=data.get('UrlPattern', None),
            resource_type=data.get('ResourceType', None),
            request_stage=data.get('RequestStage', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _fetch__header_entry__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'fetch.HeaderEntry':

    if casing_strategy == 'snake':
        return fetch.HeaderEntry(
            name=data['name'],
            value=data['value']
        )

    if casing_strategy == 'camel':
        return fetch.HeaderEntry(
            name=data['name'],
            value=data['value']
        )

    if casing_strategy == 'pascal':
        return fetch.HeaderEntry(
            name=data['Name'],
            value=data['Value']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _fetch__auth_challenge__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'fetch.AuthChallenge':

    if casing_strategy == 'snake':
        return fetch.AuthChallenge(
            source=data.get('source', None),
            origin=data['origin'],
            scheme=data['scheme'],
            realm=data['realm']
        )

    if casing_strategy == 'camel':
        return fetch.AuthChallenge(
            source=data.get('source', None),
            origin=data['origin'],
            scheme=data['scheme'],
            realm=data['realm']
        )

    if casing_strategy == 'pascal':
        return fetch.AuthChallenge(
            source=data.get('Source', None),
            origin=data['Origin'],
            scheme=data['Scheme'],
            realm=data['Realm']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _fetch__auth_challenge_response__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'fetch.AuthChallengeResponse':

    if casing_strategy == 'snake':
        return fetch.AuthChallengeResponse(
            response=data['response'],
            username=data.get('username', None),
            password=data.get('password', None)
        )

    if casing_strategy == 'camel':
        return fetch.AuthChallengeResponse(
            response=data['response'],
            username=data.get('username', None),
            password=data.get('password', None)
        )

    if casing_strategy == 'pascal':
        return fetch.AuthChallengeResponse(
            response=data['Response'],
            username=data.get('Username', None),
            password=data.get('Password', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _web_audio__context_realtime_data__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'web_audio.ContextRealtimeData':

    if casing_strategy == 'snake':
        return web_audio.ContextRealtimeData(
            current_time=data['current_time'],
            render_capacity=data['render_capacity'],
            callback_interval_mean=data['callback_interval_mean'],
            callback_interval_variance=data['callback_interval_variance']
        )

    if casing_strategy == 'camel':
        return web_audio.ContextRealtimeData(
            current_time=data['currentTime'],
            render_capacity=data['renderCapacity'],
            callback_interval_mean=data['callbackIntervalMean'],
            callback_interval_variance=data['callbackIntervalVariance']
        )

    if casing_strategy == 'pascal':
        return web_audio.ContextRealtimeData(
            current_time=data['CurrentTime'],
            render_capacity=data['RenderCapacity'],
            callback_interval_mean=data['CallbackIntervalMean'],
            callback_interval_variance=data['CallbackIntervalVariance']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _web_audio__base_audio_context__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'web_audio.BaseAudioContext':

    if casing_strategy == 'snake':
        return web_audio.BaseAudioContext(
            context_id=data['context_id'],
            context_type=data['context_type'],
            context_state=data['context_state'],
            realtime_data=from_dict(
                web_audio.ContextRealtimeData,
                data.get('realtime_data', None),
                casing_strategy
            ),
            callback_buffer_size=data['callback_buffer_size'],
            max_output_channel_count=data['max_output_channel_count'],
            sample_rate=data['sample_rate']
        )

    if casing_strategy == 'camel':
        return web_audio.BaseAudioContext(
            context_id=data['contextId'],
            context_type=data['contextType'],
            context_state=data['contextState'],
            realtime_data=from_dict(
                web_audio.ContextRealtimeData,
                data.get('realtimeData', None),
                casing_strategy
            ),
            callback_buffer_size=data['callbackBufferSize'],
            max_output_channel_count=data['maxOutputChannelCount'],
            sample_rate=data['sampleRate']
        )

    if casing_strategy == 'pascal':
        return web_audio.BaseAudioContext(
            context_id=data['ContextId'],
            context_type=data['ContextType'],
            context_state=data['ContextState'],
            realtime_data=from_dict(
                web_audio.ContextRealtimeData,
                data.get('RealtimeData', None),
                casing_strategy
            ),
            callback_buffer_size=data['CallbackBufferSize'],
            max_output_channel_count=data['MaxOutputChannelCount'],
            sample_rate=data['SampleRate']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _web_audio__audio_listener__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'web_audio.AudioListener':

    if casing_strategy == 'snake':
        return web_audio.AudioListener(
            listener_id=data['listener_id'],
            context_id=data['context_id']
        )

    if casing_strategy == 'camel':
        return web_audio.AudioListener(
            listener_id=data['listenerId'],
            context_id=data['contextId']
        )

    if casing_strategy == 'pascal':
        return web_audio.AudioListener(
            listener_id=data['ListenerId'],
            context_id=data['ContextId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _web_audio__audio_node__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'web_audio.AudioNode':

    if casing_strategy == 'snake':
        return web_audio.AudioNode(
            node_id=data['node_id'],
            context_id=data['context_id'],
            node_type=data['node_type'],
            number_of_inputs=data['number_of_inputs'],
            number_of_outputs=data['number_of_outputs'],
            channel_count=data['channel_count'],
            channel_count_mode=data['channel_count_mode'],
            channel_interpretation=data['channel_interpretation']
        )

    if casing_strategy == 'camel':
        return web_audio.AudioNode(
            node_id=data['nodeId'],
            context_id=data['contextId'],
            node_type=data['nodeType'],
            number_of_inputs=data['numberOfInputs'],
            number_of_outputs=data['numberOfOutputs'],
            channel_count=data['channelCount'],
            channel_count_mode=data['channelCountMode'],
            channel_interpretation=data['channelInterpretation']
        )

    if casing_strategy == 'pascal':
        return web_audio.AudioNode(
            node_id=data['NodeId'],
            context_id=data['ContextId'],
            node_type=data['NodeType'],
            number_of_inputs=data['NumberOfInputs'],
            number_of_outputs=data['NumberOfOutputs'],
            channel_count=data['ChannelCount'],
            channel_count_mode=data['ChannelCountMode'],
            channel_interpretation=data['ChannelInterpretation']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _web_audio__audio_param__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'web_audio.AudioParam':

    if casing_strategy == 'snake':
        return web_audio.AudioParam(
            param_id=data['param_id'],
            node_id=data['node_id'],
            context_id=data['context_id'],
            param_type=data['param_type'],
            rate=data['rate'],
            default_value=data['default_value'],
            min_value=data['min_value'],
            max_value=data['max_value']
        )

    if casing_strategy == 'camel':
        return web_audio.AudioParam(
            param_id=data['paramId'],
            node_id=data['nodeId'],
            context_id=data['contextId'],
            param_type=data['paramType'],
            rate=data['rate'],
            default_value=data['defaultValue'],
            min_value=data['minValue'],
            max_value=data['maxValue']
        )

    if casing_strategy == 'pascal':
        return web_audio.AudioParam(
            param_id=data['ParamId'],
            node_id=data['NodeId'],
            context_id=data['ContextId'],
            param_type=data['ParamType'],
            rate=data['Rate'],
            default_value=data['DefaultValue'],
            min_value=data['MinValue'],
            max_value=data['MaxValue']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _web_authn__virtual_authenticator_options__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'web_authn.VirtualAuthenticatorOptions':

    if casing_strategy == 'snake':
        return web_authn.VirtualAuthenticatorOptions(
            protocol=data['protocol'],
            ctap2_version=data.get('ctap2_version', None),
            transport=data['transport'],
            has_resident_key=data.get('has_resident_key', None),
            has_user_verification=data.get('has_user_verification', None),
            has_large_blob=data.get('has_large_blob', None),
            has_cred_blob=data.get('has_cred_blob', None),
            has_min_pin_length=data.get('has_min_pin_length', None),
            has_prf=data.get('has_prf', None),
            automatic_presence_simulation=data.get('automatic_presence_simulation', None),
            is_user_verified=data.get('is_user_verified', None)
        )

    if casing_strategy == 'camel':
        return web_authn.VirtualAuthenticatorOptions(
            protocol=data['protocol'],
            ctap2_version=data.get('ctap2Version', None),
            transport=data['transport'],
            has_resident_key=data.get('hasResidentKey', None),
            has_user_verification=data.get('hasUserVerification', None),
            has_large_blob=data.get('hasLargeBlob', None),
            has_cred_blob=data.get('hasCredBlob', None),
            has_min_pin_length=data.get('hasMinPinLength', None),
            has_prf=data.get('hasPrf', None),
            automatic_presence_simulation=data.get('automaticPresenceSimulation', None),
            is_user_verified=data.get('isUserVerified', None)
        )

    if casing_strategy == 'pascal':
        return web_authn.VirtualAuthenticatorOptions(
            protocol=data['Protocol'],
            ctap2_version=data.get('Ctap2Version', None),
            transport=data['Transport'],
            has_resident_key=data.get('HasResidentKey', None),
            has_user_verification=data.get('HasUserVerification', None),
            has_large_blob=data.get('HasLargeBlob', None),
            has_cred_blob=data.get('HasCredBlob', None),
            has_min_pin_length=data.get('HasMinPinLength', None),
            has_prf=data.get('HasPrf', None),
            automatic_presence_simulation=data.get('AutomaticPresenceSimulation', None),
            is_user_verified=data.get('IsUserVerified', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _web_authn__credential__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'web_authn.Credential':

    if casing_strategy == 'snake':
        return web_authn.Credential(
            credential_id=data['credential_id'],
            is_resident_credential=data['is_resident_credential'],
            rp_id=data.get('rp_id', None),
            private_key=data['private_key'],
            user_handle=data.get('user_handle', None),
            sign_count=data['sign_count'],
            large_blob=data.get('large_blob', None)
        )

    if casing_strategy == 'camel':
        return web_authn.Credential(
            credential_id=data['credentialId'],
            is_resident_credential=data['isResidentCredential'],
            rp_id=data.get('rpId', None),
            private_key=data['privateKey'],
            user_handle=data.get('userHandle', None),
            sign_count=data['signCount'],
            large_blob=data.get('largeBlob', None)
        )

    if casing_strategy == 'pascal':
        return web_authn.Credential(
            credential_id=data['CredentialId'],
            is_resident_credential=data['IsResidentCredential'],
            rp_id=data.get('RpId', None),
            private_key=data['PrivateKey'],
            user_handle=data.get('UserHandle', None),
            sign_count=data['SignCount'],
            large_blob=data.get('LargeBlob', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _media__player_message__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'media.PlayerMessage':

    if casing_strategy == 'snake':
        return media.PlayerMessage(
            level=data['level'],
            message=data['message']
        )

    if casing_strategy == 'camel':
        return media.PlayerMessage(
            level=data['level'],
            message=data['message']
        )

    if casing_strategy == 'pascal':
        return media.PlayerMessage(
            level=data['Level'],
            message=data['Message']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _media__player_property__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'media.PlayerProperty':

    if casing_strategy == 'snake':
        return media.PlayerProperty(
            name=data['name'],
            value=data['value']
        )

    if casing_strategy == 'camel':
        return media.PlayerProperty(
            name=data['name'],
            value=data['value']
        )

    if casing_strategy == 'pascal':
        return media.PlayerProperty(
            name=data['Name'],
            value=data['Value']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _media__player_event__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'media.PlayerEvent':

    if casing_strategy == 'snake':
        return media.PlayerEvent(
            timestamp=data['timestamp'],
            value=data['value']
        )

    if casing_strategy == 'camel':
        return media.PlayerEvent(
            timestamp=data['timestamp'],
            value=data['value']
        )

    if casing_strategy == 'pascal':
        return media.PlayerEvent(
            timestamp=data['Timestamp'],
            value=data['Value']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _media__player_error_source_location__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'media.PlayerErrorSourceLocation':

    if casing_strategy == 'snake':
        return media.PlayerErrorSourceLocation(
            file=data['file'],
            line=data['line']
        )

    if casing_strategy == 'camel':
        return media.PlayerErrorSourceLocation(
            file=data['file'],
            line=data['line']
        )

    if casing_strategy == 'pascal':
        return media.PlayerErrorSourceLocation(
            file=data['File'],
            line=data['Line']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _media__player_error__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'media.PlayerError':

    if casing_strategy == 'snake':
        return media.PlayerError(
            error_type=data['error_type'],
            code=data['code'],
            stack=[
                from_dict(media.PlayerErrorSourceLocation, item, casing_strategy)
                for item in data['stack']
            ],
            cause=[
                from_dict(media.PlayerError, item, casing_strategy)
                for item in data['cause']
            ],
            data=data['data']
        )

    if casing_strategy == 'camel':
        return media.PlayerError(
            error_type=data['errorType'],
            code=data['code'],
            stack=[
                from_dict(media.PlayerErrorSourceLocation, item, casing_strategy)
                for item in data['stack']
            ],
            cause=[
                from_dict(media.PlayerError, item, casing_strategy)
                for item in data['cause']
            ],
            data=data['data']
        )

    if casing_strategy == 'pascal':
        return media.PlayerError(
            error_type=data['ErrorType'],
            code=data['Code'],
            stack=[
                from_dict(media.PlayerErrorSourceLocation, item, casing_strategy)
                for item in data['Stack']
            ],
            cause=[
                from_dict(media.PlayerError, item, casing_strategy)
                for item in data['Cause']
            ],
            data=data['Data']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _device_access__prompt_device__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'device_access.PromptDevice':

    if casing_strategy == 'snake':
        return device_access.PromptDevice(
            id=data['id'],
            name=data['name']
        )

    if casing_strategy == 'camel':
        return device_access.PromptDevice(
            id=data['id'],
            name=data['name']
        )

    if casing_strategy == 'pascal':
        return device_access.PromptDevice(
            id=data['Id'],
            name=data['Name']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _preload__rule_set__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'preload.RuleSet':

    if casing_strategy == 'snake':
        return preload.RuleSet(
            id=data['id'],
            loader_id=data['loader_id'],
            source_text=data['source_text'],
            backend_node_id=data.get('backend_node_id', None),
            url=data.get('url', None),
            request_id=data.get('request_id', None),
            error_type=data.get('error_type', None),
            error_message=data.get('error_message', None)
        )

    if casing_strategy == 'camel':
        return preload.RuleSet(
            id=data['id'],
            loader_id=data['loaderId'],
            source_text=data['sourceText'],
            backend_node_id=data.get('backendNodeId', None),
            url=data.get('url', None),
            request_id=data.get('requestId', None),
            error_type=data.get('errorType', None),
            error_message=data.get('errorMessage', None)
        )

    if casing_strategy == 'pascal':
        return preload.RuleSet(
            id=data['Id'],
            loader_id=data['LoaderId'],
            source_text=data['SourceText'],
            backend_node_id=data.get('BackendNodeId', None),
            url=data.get('Url', None),
            request_id=data.get('RequestId', None),
            error_type=data.get('ErrorType', None),
            error_message=data.get('ErrorMessage', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _preload__preloading_attempt_key__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'preload.PreloadingAttemptKey':

    if casing_strategy == 'snake':
        return preload.PreloadingAttemptKey(
            loader_id=data['loader_id'],
            action=data['action'],
            url=data['url'],
            target_hint=data.get('target_hint', None)
        )

    if casing_strategy == 'camel':
        return preload.PreloadingAttemptKey(
            loader_id=data['loaderId'],
            action=data['action'],
            url=data['url'],
            target_hint=data.get('targetHint', None)
        )

    if casing_strategy == 'pascal':
        return preload.PreloadingAttemptKey(
            loader_id=data['LoaderId'],
            action=data['Action'],
            url=data['Url'],
            target_hint=data.get('TargetHint', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _preload__preloading_attempt_source__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'preload.PreloadingAttemptSource':

    if casing_strategy == 'snake':
        return preload.PreloadingAttemptSource(
            key=from_dict(
                preload.PreloadingAttemptKey,
                data['key'],
                casing_strategy
            ),
            rule_set_ids=data['rule_set_ids'],
            node_ids=data['node_ids']
        )

    if casing_strategy == 'camel':
        return preload.PreloadingAttemptSource(
            key=from_dict(
                preload.PreloadingAttemptKey,
                data['key'],
                casing_strategy
            ),
            rule_set_ids=data['ruleSetIds'],
            node_ids=data['nodeIds']
        )

    if casing_strategy == 'pascal':
        return preload.PreloadingAttemptSource(
            key=from_dict(
                preload.PreloadingAttemptKey,
                data['Key'],
                casing_strategy
            ),
            rule_set_ids=data['RuleSetIds'],
            node_ids=data['NodeIds']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _fed_cm__account__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'fed_cm.Account':

    if casing_strategy == 'snake':
        return fed_cm.Account(
            account_id=data['account_id'],
            email=data['email'],
            name=data['name'],
            given_name=data['given_name'],
            picture_url=data['picture_url'],
            idp_config_url=data['idp_config_url'],
            idp_signin_url=data['idp_signin_url'],
            login_state=data['login_state'],
            terms_of_service_url=data.get('terms_of_service_url', None),
            privacy_policy_url=data.get('privacy_policy_url', None)
        )

    if casing_strategy == 'camel':
        return fed_cm.Account(
            account_id=data['accountId'],
            email=data['email'],
            name=data['name'],
            given_name=data['givenName'],
            picture_url=data['pictureUrl'],
            idp_config_url=data['idpConfigUrl'],
            idp_signin_url=data['idpSigninUrl'],
            login_state=data['loginState'],
            terms_of_service_url=data.get('termsOfServiceUrl', None),
            privacy_policy_url=data.get('privacyPolicyUrl', None)
        )

    if casing_strategy == 'pascal':
        return fed_cm.Account(
            account_id=data['AccountId'],
            email=data['Email'],
            name=data['Name'],
            given_name=data['GivenName'],
            picture_url=data['PictureUrl'],
            idp_config_url=data['IdpConfigUrl'],
            idp_signin_url=data['IdpSigninUrl'],
            login_state=data['LoginState'],
            terms_of_service_url=data.get('TermsOfServiceUrl', None),
            privacy_policy_url=data.get('PrivacyPolicyUrl', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _console__console_message__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'console.ConsoleMessage':

    if casing_strategy == 'snake':
        return console.ConsoleMessage(
            source=data['source'],
            level=data['level'],
            text=data['text'],
            url=data.get('url', None),
            line=data.get('line', None),
            column=data.get('column', None)
        )

    if casing_strategy == 'camel':
        return console.ConsoleMessage(
            source=data['source'],
            level=data['level'],
            text=data['text'],
            url=data.get('url', None),
            line=data.get('line', None),
            column=data.get('column', None)
        )

    if casing_strategy == 'pascal':
        return console.ConsoleMessage(
            source=data['Source'],
            level=data['Level'],
            text=data['Text'],
            url=data.get('Url', None),
            line=data.get('Line', None),
            column=data.get('Column', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__location__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'debugger.Location':

    if casing_strategy == 'snake':
        return debugger.Location(
            script_id=data['script_id'],
            line_number=data['line_number'],
            column_number=data.get('column_number', None)
        )

    if casing_strategy == 'camel':
        return debugger.Location(
            script_id=data['scriptId'],
            line_number=data['lineNumber'],
            column_number=data.get('columnNumber', None)
        )

    if casing_strategy == 'pascal':
        return debugger.Location(
            script_id=data['ScriptId'],
            line_number=data['LineNumber'],
            column_number=data.get('ColumnNumber', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__script_position__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'debugger.ScriptPosition':

    if casing_strategy == 'snake':
        return debugger.ScriptPosition(
            line_number=data['line_number'],
            column_number=data['column_number']
        )

    if casing_strategy == 'camel':
        return debugger.ScriptPosition(
            line_number=data['lineNumber'],
            column_number=data['columnNumber']
        )

    if casing_strategy == 'pascal':
        return debugger.ScriptPosition(
            line_number=data['LineNumber'],
            column_number=data['ColumnNumber']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__call_frame__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'debugger.CallFrame':

    if casing_strategy == 'snake':
        return debugger.CallFrame(
            call_frame_id=data['call_frame_id'],
            function_name=data['function_name'],
            function_location=from_dict(
                debugger.Location,
                data.get('function_location', None),
                casing_strategy
            ),
            location=from_dict(
                debugger.Location,
                data['location'],
                casing_strategy
            ),
            url=data['url'],
            scope_chain=[
                from_dict(debugger.Scope, item, casing_strategy)
                for item in data['scope_chain']
            ],
            this=from_dict(
                debugger.RemoteObject,
                data['this'],
                casing_strategy
            ),
            return_value=from_dict(
                debugger.RemoteObject,
                data.get('return_value', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return debugger.CallFrame(
            call_frame_id=data['callFrameId'],
            function_name=data['functionName'],
            function_location=from_dict(
                debugger.Location,
                data.get('functionLocation', None),
                casing_strategy
            ),
            location=from_dict(
                debugger.Location,
                data['location'],
                casing_strategy
            ),
            url=data['url'],
            scope_chain=[
                from_dict(debugger.Scope, item, casing_strategy)
                for item in data['scopeChain']
            ],
            this=from_dict(
                debugger.RemoteObject,
                data['this'],
                casing_strategy
            ),
            return_value=from_dict(
                debugger.RemoteObject,
                data.get('returnValue', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return debugger.CallFrame(
            call_frame_id=data['CallFrameId'],
            function_name=data['FunctionName'],
            function_location=from_dict(
                debugger.Location,
                data.get('FunctionLocation', None),
                casing_strategy
            ),
            location=from_dict(
                debugger.Location,
                data['Location'],
                casing_strategy
            ),
            url=data['Url'],
            scope_chain=[
                from_dict(debugger.Scope, item, casing_strategy)
                for item in data['ScopeChain']
            ],
            this=from_dict(
                debugger.RemoteObject,
                data['This'],
                casing_strategy
            ),
            return_value=from_dict(
                debugger.RemoteObject,
                data.get('ReturnValue', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__scope__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'debugger.Scope':

    if casing_strategy == 'snake':
        return debugger.Scope(
            type=data['type'],
            object=from_dict(
                debugger.RemoteObject,
                data['object'],
                casing_strategy
            ),
            name=data.get('name', None),
            start_location=from_dict(
                debugger.Location,
                data.get('start_location', None),
                casing_strategy
            ),
            end_location=from_dict(
                debugger.Location,
                data.get('end_location', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return debugger.Scope(
            type=data['type'],
            object=from_dict(
                debugger.RemoteObject,
                data['object'],
                casing_strategy
            ),
            name=data.get('name', None),
            start_location=from_dict(
                debugger.Location,
                data.get('startLocation', None),
                casing_strategy
            ),
            end_location=from_dict(
                debugger.Location,
                data.get('endLocation', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return debugger.Scope(
            type=data['Type'],
            object=from_dict(
                debugger.RemoteObject,
                data['Object'],
                casing_strategy
            ),
            name=data.get('Name', None),
            start_location=from_dict(
                debugger.Location,
                data.get('StartLocation', None),
                casing_strategy
            ),
            end_location=from_dict(
                debugger.Location,
                data.get('EndLocation', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__search_match__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'debugger.SearchMatch':

    if casing_strategy == 'snake':
        return debugger.SearchMatch(
            line_number=data['line_number'],
            line_content=data['line_content']
        )

    if casing_strategy == 'camel':
        return debugger.SearchMatch(
            line_number=data['lineNumber'],
            line_content=data['lineContent']
        )

    if casing_strategy == 'pascal':
        return debugger.SearchMatch(
            line_number=data['LineNumber'],
            line_content=data['LineContent']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__break_location__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'debugger.BreakLocation':

    if casing_strategy == 'snake':
        return debugger.BreakLocation(
            script_id=data['script_id'],
            line_number=data['line_number'],
            column_number=data.get('column_number', None),
            type=data.get('type', None)
        )

    if casing_strategy == 'camel':
        return debugger.BreakLocation(
            script_id=data['scriptId'],
            line_number=data['lineNumber'],
            column_number=data.get('columnNumber', None),
            type=data.get('type', None)
        )

    if casing_strategy == 'pascal':
        return debugger.BreakLocation(
            script_id=data['ScriptId'],
            line_number=data['LineNumber'],
            column_number=data.get('ColumnNumber', None),
            type=data.get('Type', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _heap_profiler__sampling_heap_profile_node__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'heap_profiler.SamplingHeapProfileNode':

    if casing_strategy == 'snake':
        return heap_profiler.SamplingHeapProfileNode(
            call_frame=from_dict(
                heap_profiler.CallFrame,
                data['call_frame'],
                casing_strategy
            ),
            self_size=data['self_size'],
            id=data['id'],
            children=[
                from_dict(heap_profiler.SamplingHeapProfileNode, item, casing_strategy)
                for item in data['children']
            ]
        )

    if casing_strategy == 'camel':
        return heap_profiler.SamplingHeapProfileNode(
            call_frame=from_dict(
                heap_profiler.CallFrame,
                data['callFrame'],
                casing_strategy
            ),
            self_size=data['selfSize'],
            id=data['id'],
            children=[
                from_dict(heap_profiler.SamplingHeapProfileNode, item, casing_strategy)
                for item in data['children']
            ]
        )

    if casing_strategy == 'pascal':
        return heap_profiler.SamplingHeapProfileNode(
            call_frame=from_dict(
                heap_profiler.CallFrame,
                data['CallFrame'],
                casing_strategy
            ),
            self_size=data['SelfSize'],
            id=data['Id'],
            children=[
                from_dict(heap_profiler.SamplingHeapProfileNode, item, casing_strategy)
                for item in data['Children']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _heap_profiler__sampling_heap_profile_sample__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'heap_profiler.SamplingHeapProfileSample':

    if casing_strategy == 'snake':
        return heap_profiler.SamplingHeapProfileSample(
            size=data['size'],
            node_id=data['node_id'],
            ordinal=data['ordinal']
        )

    if casing_strategy == 'camel':
        return heap_profiler.SamplingHeapProfileSample(
            size=data['size'],
            node_id=data['nodeId'],
            ordinal=data['ordinal']
        )

    if casing_strategy == 'pascal':
        return heap_profiler.SamplingHeapProfileSample(
            size=data['Size'],
            node_id=data['NodeId'],
            ordinal=data['Ordinal']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _heap_profiler__sampling_heap_profile__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'heap_profiler.SamplingHeapProfile':

    if casing_strategy == 'snake':
        return heap_profiler.SamplingHeapProfile(
            head=from_dict(
                heap_profiler.SamplingHeapProfileNode,
                data['head'],
                casing_strategy
            ),
            samples=[
                from_dict(heap_profiler.SamplingHeapProfileSample, item, casing_strategy)
                for item in data['samples']
            ]
        )

    if casing_strategy == 'camel':
        return heap_profiler.SamplingHeapProfile(
            head=from_dict(
                heap_profiler.SamplingHeapProfileNode,
                data['head'],
                casing_strategy
            ),
            samples=[
                from_dict(heap_profiler.SamplingHeapProfileSample, item, casing_strategy)
                for item in data['samples']
            ]
        )

    if casing_strategy == 'pascal':
        return heap_profiler.SamplingHeapProfile(
            head=from_dict(
                heap_profiler.SamplingHeapProfileNode,
                data['Head'],
                casing_strategy
            ),
            samples=[
                from_dict(heap_profiler.SamplingHeapProfileSample, item, casing_strategy)
                for item in data['Samples']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _profiler__profile_node__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'profiler.ProfileNode':

    if casing_strategy == 'snake':
        return profiler.ProfileNode(
            id=data['id'],
            call_frame=from_dict(
                profiler.CallFrame,
                data['call_frame'],
                casing_strategy
            ),
            hit_count=data.get('hit_count', None),
            children=data.get('children', []),
            deopt_reason=data.get('deopt_reason', None),
            position_ticks=[
                from_dict(profiler.PositionTickInfo, item, casing_strategy)
                for item in data.get('position_ticks', [])
            ]
        )

    if casing_strategy == 'camel':
        return profiler.ProfileNode(
            id=data['id'],
            call_frame=from_dict(
                profiler.CallFrame,
                data['callFrame'],
                casing_strategy
            ),
            hit_count=data.get('hitCount', None),
            children=data.get('children', []),
            deopt_reason=data.get('deoptReason', None),
            position_ticks=[
                from_dict(profiler.PositionTickInfo, item, casing_strategy)
                for item in data.get('positionTicks', [])
            ]
        )

    if casing_strategy == 'pascal':
        return profiler.ProfileNode(
            id=data['Id'],
            call_frame=from_dict(
                profiler.CallFrame,
                data['CallFrame'],
                casing_strategy
            ),
            hit_count=data.get('HitCount', None),
            children=data.get('Children', []),
            deopt_reason=data.get('DeoptReason', None),
            position_ticks=[
                from_dict(profiler.PositionTickInfo, item, casing_strategy)
                for item in data.get('PositionTicks', [])
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _profiler__profile__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'profiler.Profile':

    if casing_strategy == 'snake':
        return profiler.Profile(
            nodes=[
                from_dict(profiler.ProfileNode, item, casing_strategy)
                for item in data['nodes']
            ],
            start_time=data['start_time'],
            end_time=data['end_time'],
            samples=data.get('samples', []),
            time_deltas=data.get('time_deltas', [])
        )

    if casing_strategy == 'camel':
        return profiler.Profile(
            nodes=[
                from_dict(profiler.ProfileNode, item, casing_strategy)
                for item in data['nodes']
            ],
            start_time=data['startTime'],
            end_time=data['endTime'],
            samples=data.get('samples', []),
            time_deltas=data.get('timeDeltas', [])
        )

    if casing_strategy == 'pascal':
        return profiler.Profile(
            nodes=[
                from_dict(profiler.ProfileNode, item, casing_strategy)
                for item in data['Nodes']
            ],
            start_time=data['StartTime'],
            end_time=data['EndTime'],
            samples=data.get('Samples', []),
            time_deltas=data.get('TimeDeltas', [])
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _profiler__position_tick_info__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'profiler.PositionTickInfo':

    if casing_strategy == 'snake':
        return profiler.PositionTickInfo(
            line=data['line'],
            ticks=data['ticks']
        )

    if casing_strategy == 'camel':
        return profiler.PositionTickInfo(
            line=data['line'],
            ticks=data['ticks']
        )

    if casing_strategy == 'pascal':
        return profiler.PositionTickInfo(
            line=data['Line'],
            ticks=data['Ticks']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _profiler__coverage_range__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'profiler.CoverageRange':

    if casing_strategy == 'snake':
        return profiler.CoverageRange(
            start_offset=data['start_offset'],
            end_offset=data['end_offset'],
            count=data['count']
        )

    if casing_strategy == 'camel':
        return profiler.CoverageRange(
            start_offset=data['startOffset'],
            end_offset=data['endOffset'],
            count=data['count']
        )

    if casing_strategy == 'pascal':
        return profiler.CoverageRange(
            start_offset=data['StartOffset'],
            end_offset=data['EndOffset'],
            count=data['Count']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _profiler__function_coverage__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'profiler.FunctionCoverage':

    if casing_strategy == 'snake':
        return profiler.FunctionCoverage(
            function_name=data['function_name'],
            ranges=[
                from_dict(profiler.CoverageRange, item, casing_strategy)
                for item in data['ranges']
            ],
            is_block_coverage=data['is_block_coverage']
        )

    if casing_strategy == 'camel':
        return profiler.FunctionCoverage(
            function_name=data['functionName'],
            ranges=[
                from_dict(profiler.CoverageRange, item, casing_strategy)
                for item in data['ranges']
            ],
            is_block_coverage=data['isBlockCoverage']
        )

    if casing_strategy == 'pascal':
        return profiler.FunctionCoverage(
            function_name=data['FunctionName'],
            ranges=[
                from_dict(profiler.CoverageRange, item, casing_strategy)
                for item in data['Ranges']
            ],
            is_block_coverage=data['IsBlockCoverage']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _profiler__script_coverage__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'profiler.ScriptCoverage':

    if casing_strategy == 'snake':
        return profiler.ScriptCoverage(
            script_id=data['script_id'],
            url=data['url'],
            functions=[
                from_dict(profiler.FunctionCoverage, item, casing_strategy)
                for item in data['functions']
            ]
        )

    if casing_strategy == 'camel':
        return profiler.ScriptCoverage(
            script_id=data['scriptId'],
            url=data['url'],
            functions=[
                from_dict(profiler.FunctionCoverage, item, casing_strategy)
                for item in data['functions']
            ]
        )

    if casing_strategy == 'pascal':
        return profiler.ScriptCoverage(
            script_id=data['ScriptId'],
            url=data['Url'],
            functions=[
                from_dict(profiler.FunctionCoverage, item, casing_strategy)
                for item in data['Functions']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _profiler__type_object__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'profiler.TypeObject':

    if casing_strategy == 'snake':
        return profiler.TypeObject(
            name=data['name']
        )

    if casing_strategy == 'camel':
        return profiler.TypeObject(
            name=data['name']
        )

    if casing_strategy == 'pascal':
        return profiler.TypeObject(
            name=data['Name']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _profiler__type_profile_entry__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'profiler.TypeProfileEntry':

    if casing_strategy == 'snake':
        return profiler.TypeProfileEntry(
            offset=data['offset'],
            types=[
                from_dict(profiler.TypeObject, item, casing_strategy)
                for item in data['types']
            ]
        )

    if casing_strategy == 'camel':
        return profiler.TypeProfileEntry(
            offset=data['offset'],
            types=[
                from_dict(profiler.TypeObject, item, casing_strategy)
                for item in data['types']
            ]
        )

    if casing_strategy == 'pascal':
        return profiler.TypeProfileEntry(
            offset=data['Offset'],
            types=[
                from_dict(profiler.TypeObject, item, casing_strategy)
                for item in data['Types']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _profiler__script_type_profile__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'profiler.ScriptTypeProfile':

    if casing_strategy == 'snake':
        return profiler.ScriptTypeProfile(
            script_id=data['script_id'],
            url=data['url'],
            entries=[
                from_dict(profiler.TypeProfileEntry, item, casing_strategy)
                for item in data['entries']
            ]
        )

    if casing_strategy == 'camel':
        return profiler.ScriptTypeProfile(
            script_id=data['scriptId'],
            url=data['url'],
            entries=[
                from_dict(profiler.TypeProfileEntry, item, casing_strategy)
                for item in data['entries']
            ]
        )

    if casing_strategy == 'pascal':
        return profiler.ScriptTypeProfile(
            script_id=data['ScriptId'],
            url=data['Url'],
            entries=[
                from_dict(profiler.TypeProfileEntry, item, casing_strategy)
                for item in data['Entries']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__remote_object__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.RemoteObject':

    if casing_strategy == 'snake':
        return runtime.RemoteObject(
            type=data['type'],
            subtype=data.get('subtype', None),
            class_name=data.get('class_name', None),
            value=data.get('value', None),
            unserializable_value=data.get('unserializable_value', None),
            description=data.get('description', None),
            object_id=data.get('object_id', None),
            preview=from_dict(
                runtime.ObjectPreview,
                data.get('preview', None),
                casing_strategy
            ),
            custom_preview=from_dict(
                runtime.CustomPreview,
                data.get('custom_preview', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return runtime.RemoteObject(
            type=data['type'],
            subtype=data.get('subtype', None),
            class_name=data.get('className', None),
            value=data.get('value', None),
            unserializable_value=data.get('unserializableValue', None),
            description=data.get('description', None),
            object_id=data.get('objectId', None),
            preview=from_dict(
                runtime.ObjectPreview,
                data.get('preview', None),
                casing_strategy
            ),
            custom_preview=from_dict(
                runtime.CustomPreview,
                data.get('customPreview', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return runtime.RemoteObject(
            type=data['Type'],
            subtype=data.get('Subtype', None),
            class_name=data.get('ClassName', None),
            value=data.get('Value', None),
            unserializable_value=data.get('UnserializableValue', None),
            description=data.get('Description', None),
            object_id=data.get('ObjectId', None),
            preview=from_dict(
                runtime.ObjectPreview,
                data.get('Preview', None),
                casing_strategy
            ),
            custom_preview=from_dict(
                runtime.CustomPreview,
                data.get('CustomPreview', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__custom_preview__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.CustomPreview':

    if casing_strategy == 'snake':
        return runtime.CustomPreview(
            header=data['header'],
            body_getter_id=data.get('body_getter_id', None)
        )

    if casing_strategy == 'camel':
        return runtime.CustomPreview(
            header=data['header'],
            body_getter_id=data.get('bodyGetterId', None)
        )

    if casing_strategy == 'pascal':
        return runtime.CustomPreview(
            header=data['Header'],
            body_getter_id=data.get('BodyGetterId', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__object_preview__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.ObjectPreview':

    if casing_strategy == 'snake':
        return runtime.ObjectPreview(
            type=data['type'],
            subtype=data.get('subtype', None),
            description=data.get('description', None),
            overflow=data['overflow'],
            properties=[
                from_dict(runtime.PropertyPreview, item, casing_strategy)
                for item in data['properties']
            ],
            entries=[
                from_dict(runtime.EntryPreview, item, casing_strategy)
                for item in data.get('entries', [])
            ]
        )

    if casing_strategy == 'camel':
        return runtime.ObjectPreview(
            type=data['type'],
            subtype=data.get('subtype', None),
            description=data.get('description', None),
            overflow=data['overflow'],
            properties=[
                from_dict(runtime.PropertyPreview, item, casing_strategy)
                for item in data['properties']
            ],
            entries=[
                from_dict(runtime.EntryPreview, item, casing_strategy)
                for item in data.get('entries', [])
            ]
        )

    if casing_strategy == 'pascal':
        return runtime.ObjectPreview(
            type=data['Type'],
            subtype=data.get('Subtype', None),
            description=data.get('Description', None),
            overflow=data['Overflow'],
            properties=[
                from_dict(runtime.PropertyPreview, item, casing_strategy)
                for item in data['Properties']
            ],
            entries=[
                from_dict(runtime.EntryPreview, item, casing_strategy)
                for item in data.get('Entries', [])
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__property_preview__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.PropertyPreview':

    if casing_strategy == 'snake':
        return runtime.PropertyPreview(
            name=data['name'],
            type=data['type'],
            value=data.get('value', None),
            value_preview=from_dict(
                runtime.ObjectPreview,
                data.get('value_preview', None),
                casing_strategy
            ),
            subtype=data.get('subtype', None)
        )

    if casing_strategy == 'camel':
        return runtime.PropertyPreview(
            name=data['name'],
            type=data['type'],
            value=data.get('value', None),
            value_preview=from_dict(
                runtime.ObjectPreview,
                data.get('valuePreview', None),
                casing_strategy
            ),
            subtype=data.get('subtype', None)
        )

    if casing_strategy == 'pascal':
        return runtime.PropertyPreview(
            name=data['Name'],
            type=data['Type'],
            value=data.get('Value', None),
            value_preview=from_dict(
                runtime.ObjectPreview,
                data.get('ValuePreview', None),
                casing_strategy
            ),
            subtype=data.get('Subtype', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__entry_preview__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.EntryPreview':

    if casing_strategy == 'snake':
        return runtime.EntryPreview(
            key=from_dict(
                runtime.ObjectPreview,
                data.get('key', None),
                casing_strategy
            ),
            value=from_dict(
                runtime.ObjectPreview,
                data['value'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return runtime.EntryPreview(
            key=from_dict(
                runtime.ObjectPreview,
                data.get('key', None),
                casing_strategy
            ),
            value=from_dict(
                runtime.ObjectPreview,
                data['value'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return runtime.EntryPreview(
            key=from_dict(
                runtime.ObjectPreview,
                data.get('Key', None),
                casing_strategy
            ),
            value=from_dict(
                runtime.ObjectPreview,
                data['Value'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__property_descriptor__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.PropertyDescriptor':

    if casing_strategy == 'snake':
        return runtime.PropertyDescriptor(
            name=data['name'],
            value=from_dict(
                runtime.RemoteObject,
                data.get('value', None),
                casing_strategy
            ),
            writable=data.get('writable', None),
            get=from_dict(
                runtime.RemoteObject,
                data.get('get', None),
                casing_strategy
            ),
            set=from_dict(
                runtime.RemoteObject,
                data.get('set', None),
                casing_strategy
            ),
            configurable=data['configurable'],
            enumerable=data['enumerable'],
            was_thrown=data.get('was_thrown', None),
            is_own=data.get('is_own', None),
            symbol=from_dict(
                runtime.RemoteObject,
                data.get('symbol', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return runtime.PropertyDescriptor(
            name=data['name'],
            value=from_dict(
                runtime.RemoteObject,
                data.get('value', None),
                casing_strategy
            ),
            writable=data.get('writable', None),
            get=from_dict(
                runtime.RemoteObject,
                data.get('get', None),
                casing_strategy
            ),
            set=from_dict(
                runtime.RemoteObject,
                data.get('set', None),
                casing_strategy
            ),
            configurable=data['configurable'],
            enumerable=data['enumerable'],
            was_thrown=data.get('wasThrown', None),
            is_own=data.get('isOwn', None),
            symbol=from_dict(
                runtime.RemoteObject,
                data.get('symbol', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return runtime.PropertyDescriptor(
            name=data['Name'],
            value=from_dict(
                runtime.RemoteObject,
                data.get('Value', None),
                casing_strategy
            ),
            writable=data.get('Writable', None),
            get=from_dict(
                runtime.RemoteObject,
                data.get('Get', None),
                casing_strategy
            ),
            set=from_dict(
                runtime.RemoteObject,
                data.get('Set', None),
                casing_strategy
            ),
            configurable=data['Configurable'],
            enumerable=data['Enumerable'],
            was_thrown=data.get('WasThrown', None),
            is_own=data.get('IsOwn', None),
            symbol=from_dict(
                runtime.RemoteObject,
                data.get('Symbol', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__internal_property_descriptor__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.InternalPropertyDescriptor':

    if casing_strategy == 'snake':
        return runtime.InternalPropertyDescriptor(
            name=data['name'],
            value=from_dict(
                runtime.RemoteObject,
                data.get('value', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return runtime.InternalPropertyDescriptor(
            name=data['name'],
            value=from_dict(
                runtime.RemoteObject,
                data.get('value', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return runtime.InternalPropertyDescriptor(
            name=data['Name'],
            value=from_dict(
                runtime.RemoteObject,
                data.get('Value', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__private_property_descriptor__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.PrivatePropertyDescriptor':

    if casing_strategy == 'snake':
        return runtime.PrivatePropertyDescriptor(
            name=data['name'],
            value=from_dict(
                runtime.RemoteObject,
                data['value'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return runtime.PrivatePropertyDescriptor(
            name=data['name'],
            value=from_dict(
                runtime.RemoteObject,
                data['value'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return runtime.PrivatePropertyDescriptor(
            name=data['Name'],
            value=from_dict(
                runtime.RemoteObject,
                data['Value'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__call_argument__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.CallArgument':

    if casing_strategy == 'snake':
        return runtime.CallArgument(
            value=data.get('value', None),
            unserializable_value=data.get('unserializable_value', None),
            object_id=data.get('object_id', None)
        )

    if casing_strategy == 'camel':
        return runtime.CallArgument(
            value=data.get('value', None),
            unserializable_value=data.get('unserializableValue', None),
            object_id=data.get('objectId', None)
        )

    if casing_strategy == 'pascal':
        return runtime.CallArgument(
            value=data.get('Value', None),
            unserializable_value=data.get('UnserializableValue', None),
            object_id=data.get('ObjectId', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__execution_context_description__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.ExecutionContextDescription':

    if casing_strategy == 'snake':
        return runtime.ExecutionContextDescription(
            id=data['id'],
            origin=data['origin'],
            name=data['name'],
            aux_data=data.get('aux_data', None)
        )

    if casing_strategy == 'camel':
        return runtime.ExecutionContextDescription(
            id=data['id'],
            origin=data['origin'],
            name=data['name'],
            aux_data=data.get('auxData', None)
        )

    if casing_strategy == 'pascal':
        return runtime.ExecutionContextDescription(
            id=data['Id'],
            origin=data['Origin'],
            name=data['Name'],
            aux_data=data.get('AuxData', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__exception_details__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.ExceptionDetails':

    if casing_strategy == 'snake':
        return runtime.ExceptionDetails(
            exception_id=data['exception_id'],
            text=data['text'],
            line_number=data['line_number'],
            column_number=data['column_number'],
            script_id=data.get('script_id', None),
            url=data.get('url', None),
            stack_trace=from_dict(
                runtime.StackTrace,
                data.get('stack_trace', None),
                casing_strategy
            ),
            exception=from_dict(
                runtime.RemoteObject,
                data.get('exception', None),
                casing_strategy
            ),
            execution_context_id=data.get('execution_context_id', None)
        )

    if casing_strategy == 'camel':
        return runtime.ExceptionDetails(
            exception_id=data['exceptionId'],
            text=data['text'],
            line_number=data['lineNumber'],
            column_number=data['columnNumber'],
            script_id=data.get('scriptId', None),
            url=data.get('url', None),
            stack_trace=from_dict(
                runtime.StackTrace,
                data.get('stackTrace', None),
                casing_strategy
            ),
            exception=from_dict(
                runtime.RemoteObject,
                data.get('exception', None),
                casing_strategy
            ),
            execution_context_id=data.get('executionContextId', None)
        )

    if casing_strategy == 'pascal':
        return runtime.ExceptionDetails(
            exception_id=data['ExceptionId'],
            text=data['Text'],
            line_number=data['LineNumber'],
            column_number=data['ColumnNumber'],
            script_id=data.get('ScriptId', None),
            url=data.get('Url', None),
            stack_trace=from_dict(
                runtime.StackTrace,
                data.get('StackTrace', None),
                casing_strategy
            ),
            exception=from_dict(
                runtime.RemoteObject,
                data.get('Exception', None),
                casing_strategy
            ),
            execution_context_id=data.get('ExecutionContextId', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__call_frame__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.CallFrame':

    if casing_strategy == 'snake':
        return runtime.CallFrame(
            function_name=data['function_name'],
            script_id=data['script_id'],
            url=data['url'],
            line_number=data['line_number'],
            column_number=data['column_number']
        )

    if casing_strategy == 'camel':
        return runtime.CallFrame(
            function_name=data['functionName'],
            script_id=data['scriptId'],
            url=data['url'],
            line_number=data['lineNumber'],
            column_number=data['columnNumber']
        )

    if casing_strategy == 'pascal':
        return runtime.CallFrame(
            function_name=data['FunctionName'],
            script_id=data['ScriptId'],
            url=data['Url'],
            line_number=data['LineNumber'],
            column_number=data['ColumnNumber']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__stack_trace__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.StackTrace':

    if casing_strategy == 'snake':
        return runtime.StackTrace(
            description=data.get('description', None),
            call_frames=[
                from_dict(runtime.CallFrame, item, casing_strategy)
                for item in data['call_frames']
            ],
            parent=from_dict(
                runtime.StackTrace,
                data.get('parent', None),
                casing_strategy
            ),
            parent_id=from_dict(
                runtime.StackTraceId,
                data.get('parent_id', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return runtime.StackTrace(
            description=data.get('description', None),
            call_frames=[
                from_dict(runtime.CallFrame, item, casing_strategy)
                for item in data['callFrames']
            ],
            parent=from_dict(
                runtime.StackTrace,
                data.get('parent', None),
                casing_strategy
            ),
            parent_id=from_dict(
                runtime.StackTraceId,
                data.get('parentId', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return runtime.StackTrace(
            description=data.get('Description', None),
            call_frames=[
                from_dict(runtime.CallFrame, item, casing_strategy)
                for item in data['CallFrames']
            ],
            parent=from_dict(
                runtime.StackTrace,
                data.get('Parent', None),
                casing_strategy
            ),
            parent_id=from_dict(
                runtime.StackTraceId,
                data.get('ParentId', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__stack_trace_id__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.StackTraceId':

    if casing_strategy == 'snake':
        return runtime.StackTraceId(
            id=data['id'],
            debugger_id=data.get('debugger_id', None)
        )

    if casing_strategy == 'camel':
        return runtime.StackTraceId(
            id=data['id'],
            debugger_id=data.get('debuggerId', None)
        )

    if casing_strategy == 'pascal':
        return runtime.StackTraceId(
            id=data['Id'],
            debugger_id=data.get('DebuggerId', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _schema__domain__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'schema.Domain':

    if casing_strategy == 'snake':
        return schema.Domain(
            name=data['name'],
            version=data['version']
        )

    if casing_strategy == 'camel':
        return schema.Domain(
            name=data['name'],
            version=data['version']
        )

    if casing_strategy == 'pascal':
        return schema.Domain(
            name=data['Name'],
            version=data['Version']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _accessibility__get_partial_ax_tree_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'accessibility.GetPartialAXTreeReturnT':

    if casing_strategy == 'snake':
        return accessibility.GetPartialAXTreeReturnT(
            nodes=[
                from_dict(accessibility.AXNode, item, casing_strategy)
                for item in data['nodes']
            ]
        )

    if casing_strategy == 'camel':
        return accessibility.GetPartialAXTreeReturnT(
            nodes=[
                from_dict(accessibility.AXNode, item, casing_strategy)
                for item in data['nodes']
            ]
        )

    if casing_strategy == 'pascal':
        return accessibility.GetPartialAXTreeReturnT(
            nodes=[
                from_dict(accessibility.AXNode, item, casing_strategy)
                for item in data['Nodes']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _accessibility__get_full_ax_tree_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'accessibility.GetFullAXTreeReturnT':

    if casing_strategy == 'snake':
        return accessibility.GetFullAXTreeReturnT(
            nodes=[
                from_dict(accessibility.AXNode, item, casing_strategy)
                for item in data['nodes']
            ]
        )

    if casing_strategy == 'camel':
        return accessibility.GetFullAXTreeReturnT(
            nodes=[
                from_dict(accessibility.AXNode, item, casing_strategy)
                for item in data['nodes']
            ]
        )

    if casing_strategy == 'pascal':
        return accessibility.GetFullAXTreeReturnT(
            nodes=[
                from_dict(accessibility.AXNode, item, casing_strategy)
                for item in data['Nodes']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _accessibility__get_root_ax_node_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'accessibility.GetRootAXNodeReturnT':

    if casing_strategy == 'snake':
        return accessibility.GetRootAXNodeReturnT(
            node=from_dict(
                accessibility.AXNode,
                data['node'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return accessibility.GetRootAXNodeReturnT(
            node=from_dict(
                accessibility.AXNode,
                data['node'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return accessibility.GetRootAXNodeReturnT(
            node=from_dict(
                accessibility.AXNode,
                data['Node'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _accessibility__get_ax_node_and_ancestors_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'accessibility.GetAXNodeAndAncestorsReturnT':

    if casing_strategy == 'snake':
        return accessibility.GetAXNodeAndAncestorsReturnT(
            nodes=[
                from_dict(accessibility.AXNode, item, casing_strategy)
                for item in data['nodes']
            ]
        )

    if casing_strategy == 'camel':
        return accessibility.GetAXNodeAndAncestorsReturnT(
            nodes=[
                from_dict(accessibility.AXNode, item, casing_strategy)
                for item in data['nodes']
            ]
        )

    if casing_strategy == 'pascal':
        return accessibility.GetAXNodeAndAncestorsReturnT(
            nodes=[
                from_dict(accessibility.AXNode, item, casing_strategy)
                for item in data['Nodes']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _accessibility__get_child_ax_nodes_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'accessibility.GetChildAXNodesReturnT':

    if casing_strategy == 'snake':
        return accessibility.GetChildAXNodesReturnT(
            nodes=[
                from_dict(accessibility.AXNode, item, casing_strategy)
                for item in data['nodes']
            ]
        )

    if casing_strategy == 'camel':
        return accessibility.GetChildAXNodesReturnT(
            nodes=[
                from_dict(accessibility.AXNode, item, casing_strategy)
                for item in data['nodes']
            ]
        )

    if casing_strategy == 'pascal':
        return accessibility.GetChildAXNodesReturnT(
            nodes=[
                from_dict(accessibility.AXNode, item, casing_strategy)
                for item in data['Nodes']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _accessibility__query_ax_tree_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'accessibility.QueryAXTreeReturnT':

    if casing_strategy == 'snake':
        return accessibility.QueryAXTreeReturnT(
            nodes=[
                from_dict(accessibility.AXNode, item, casing_strategy)
                for item in data['nodes']
            ]
        )

    if casing_strategy == 'camel':
        return accessibility.QueryAXTreeReturnT(
            nodes=[
                from_dict(accessibility.AXNode, item, casing_strategy)
                for item in data['nodes']
            ]
        )

    if casing_strategy == 'pascal':
        return accessibility.QueryAXTreeReturnT(
            nodes=[
                from_dict(accessibility.AXNode, item, casing_strategy)
                for item in data['Nodes']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _animation__get_current_time_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'animation.GetCurrentTimeReturnT':

    if casing_strategy == 'snake':
        return animation.GetCurrentTimeReturnT(
            current_time=data['current_time']
        )

    if casing_strategy == 'camel':
        return animation.GetCurrentTimeReturnT(
            current_time=data['currentTime']
        )

    if casing_strategy == 'pascal':
        return animation.GetCurrentTimeReturnT(
            current_time=data['CurrentTime']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _animation__get_playback_rate_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'animation.GetPlaybackRateReturnT':

    if casing_strategy == 'snake':
        return animation.GetPlaybackRateReturnT(
            playback_rate=data['playback_rate']
        )

    if casing_strategy == 'camel':
        return animation.GetPlaybackRateReturnT(
            playback_rate=data['playbackRate']
        )

    if casing_strategy == 'pascal':
        return animation.GetPlaybackRateReturnT(
            playback_rate=data['PlaybackRate']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _animation__resolve_animation_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'animation.ResolveAnimationReturnT':

    if casing_strategy == 'snake':
        return animation.ResolveAnimationReturnT(
            remote_object=from_dict(
                animation.RemoteObject,
                data['remote_object'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return animation.ResolveAnimationReturnT(
            remote_object=from_dict(
                animation.RemoteObject,
                data['remoteObject'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return animation.ResolveAnimationReturnT(
            remote_object=from_dict(
                animation.RemoteObject,
                data['RemoteObject'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__get_encoded_response_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.GetEncodedResponseReturnT':

    if casing_strategy == 'snake':
        return audits.GetEncodedResponseReturnT(
            body=data.get('body', None),
            original_size=data['original_size'],
            encoded_size=data['encoded_size']
        )

    if casing_strategy == 'camel':
        return audits.GetEncodedResponseReturnT(
            body=data.get('body', None),
            original_size=data['originalSize'],
            encoded_size=data['encodedSize']
        )

    if casing_strategy == 'pascal':
        return audits.GetEncodedResponseReturnT(
            body=data.get('Body', None),
            original_size=data['OriginalSize'],
            encoded_size=data['EncodedSize']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _audits__check_forms_issues_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'audits.CheckFormsIssuesReturnT':

    if casing_strategy == 'snake':
        return audits.CheckFormsIssuesReturnT(
            form_issues=[
                from_dict(audits.GenericIssueDetails, item, casing_strategy)
                for item in data['form_issues']
            ]
        )

    if casing_strategy == 'camel':
        return audits.CheckFormsIssuesReturnT(
            form_issues=[
                from_dict(audits.GenericIssueDetails, item, casing_strategy)
                for item in data['formIssues']
            ]
        )

    if casing_strategy == 'pascal':
        return audits.CheckFormsIssuesReturnT(
            form_issues=[
                from_dict(audits.GenericIssueDetails, item, casing_strategy)
                for item in data['FormIssues']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _browser__get_version_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'browser.GetVersionReturnT':

    if casing_strategy == 'snake':
        return browser.GetVersionReturnT(
            protocol_version=data['protocol_version'],
            product=data['product'],
            revision=data['revision'],
            user_agent=data['user_agent'],
            js_version=data['js_version']
        )

    if casing_strategy == 'camel':
        return browser.GetVersionReturnT(
            protocol_version=data['protocolVersion'],
            product=data['product'],
            revision=data['revision'],
            user_agent=data['userAgent'],
            js_version=data['jsVersion']
        )

    if casing_strategy == 'pascal':
        return browser.GetVersionReturnT(
            protocol_version=data['ProtocolVersion'],
            product=data['Product'],
            revision=data['Revision'],
            user_agent=data['UserAgent'],
            js_version=data['JsVersion']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _browser__get_browser_command_line_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'browser.GetBrowserCommandLineReturnT':

    if casing_strategy == 'snake':
        return browser.GetBrowserCommandLineReturnT(
            arguments=data['arguments']
        )

    if casing_strategy == 'camel':
        return browser.GetBrowserCommandLineReturnT(
            arguments=data['arguments']
        )

    if casing_strategy == 'pascal':
        return browser.GetBrowserCommandLineReturnT(
            arguments=data['Arguments']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _browser__get_histograms_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'browser.GetHistogramsReturnT':

    if casing_strategy == 'snake':
        return browser.GetHistogramsReturnT(
            histograms=[
                from_dict(browser.Histogram, item, casing_strategy)
                for item in data['histograms']
            ]
        )

    if casing_strategy == 'camel':
        return browser.GetHistogramsReturnT(
            histograms=[
                from_dict(browser.Histogram, item, casing_strategy)
                for item in data['histograms']
            ]
        )

    if casing_strategy == 'pascal':
        return browser.GetHistogramsReturnT(
            histograms=[
                from_dict(browser.Histogram, item, casing_strategy)
                for item in data['Histograms']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _browser__get_histogram_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'browser.GetHistogramReturnT':

    if casing_strategy == 'snake':
        return browser.GetHistogramReturnT(
            histogram=from_dict(
                browser.Histogram,
                data['histogram'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return browser.GetHistogramReturnT(
            histogram=from_dict(
                browser.Histogram,
                data['histogram'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return browser.GetHistogramReturnT(
            histogram=from_dict(
                browser.Histogram,
                data['Histogram'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _browser__get_window_bounds_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'browser.GetWindowBoundsReturnT':

    if casing_strategy == 'snake':
        return browser.GetWindowBoundsReturnT(
            bounds=from_dict(
                browser.Bounds,
                data['bounds'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return browser.GetWindowBoundsReturnT(
            bounds=from_dict(
                browser.Bounds,
                data['bounds'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return browser.GetWindowBoundsReturnT(
            bounds=from_dict(
                browser.Bounds,
                data['Bounds'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _browser__get_window_for_target_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'browser.GetWindowForTargetReturnT':

    if casing_strategy == 'snake':
        return browser.GetWindowForTargetReturnT(
            window_id=data['window_id'],
            bounds=from_dict(
                browser.Bounds,
                data['bounds'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return browser.GetWindowForTargetReturnT(
            window_id=data['windowId'],
            bounds=from_dict(
                browser.Bounds,
                data['bounds'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return browser.GetWindowForTargetReturnT(
            window_id=data['WindowId'],
            bounds=from_dict(
                browser.Bounds,
                data['Bounds'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__add_rule_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.AddRuleReturnT':

    if casing_strategy == 'snake':
        return css.AddRuleReturnT(
            rule=from_dict(
                css.CSSRule,
                data['rule'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return css.AddRuleReturnT(
            rule=from_dict(
                css.CSSRule,
                data['rule'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return css.AddRuleReturnT(
            rule=from_dict(
                css.CSSRule,
                data['Rule'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__collect_class_names_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.CollectClassNamesReturnT':

    if casing_strategy == 'snake':
        return css.CollectClassNamesReturnT(
            class_names=data['class_names']
        )

    if casing_strategy == 'camel':
        return css.CollectClassNamesReturnT(
            class_names=data['classNames']
        )

    if casing_strategy == 'pascal':
        return css.CollectClassNamesReturnT(
            class_names=data['ClassNames']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__create_style_sheet_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.CreateStyleSheetReturnT':

    if casing_strategy == 'snake':
        return css.CreateStyleSheetReturnT(
            style_sheet_id=data['style_sheet_id']
        )

    if casing_strategy == 'camel':
        return css.CreateStyleSheetReturnT(
            style_sheet_id=data['styleSheetId']
        )

    if casing_strategy == 'pascal':
        return css.CreateStyleSheetReturnT(
            style_sheet_id=data['StyleSheetId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__get_background_colors_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.GetBackgroundColorsReturnT':

    if casing_strategy == 'snake':
        return css.GetBackgroundColorsReturnT(
            background_colors=data.get('background_colors', []),
            computed_font_size=data.get('computed_font_size', None),
            computed_font_weight=data.get('computed_font_weight', None)
        )

    if casing_strategy == 'camel':
        return css.GetBackgroundColorsReturnT(
            background_colors=data.get('backgroundColors', []),
            computed_font_size=data.get('computedFontSize', None),
            computed_font_weight=data.get('computedFontWeight', None)
        )

    if casing_strategy == 'pascal':
        return css.GetBackgroundColorsReturnT(
            background_colors=data.get('BackgroundColors', []),
            computed_font_size=data.get('ComputedFontSize', None),
            computed_font_weight=data.get('ComputedFontWeight', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__get_computed_style_for_node_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.GetComputedStyleForNodeReturnT':

    if casing_strategy == 'snake':
        return css.GetComputedStyleForNodeReturnT(
            computed_style=[
                from_dict(css.CSSComputedStyleProperty, item, casing_strategy)
                for item in data['computed_style']
            ]
        )

    if casing_strategy == 'camel':
        return css.GetComputedStyleForNodeReturnT(
            computed_style=[
                from_dict(css.CSSComputedStyleProperty, item, casing_strategy)
                for item in data['computedStyle']
            ]
        )

    if casing_strategy == 'pascal':
        return css.GetComputedStyleForNodeReturnT(
            computed_style=[
                from_dict(css.CSSComputedStyleProperty, item, casing_strategy)
                for item in data['ComputedStyle']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__get_inline_styles_for_node_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.GetInlineStylesForNodeReturnT':

    if casing_strategy == 'snake':
        return css.GetInlineStylesForNodeReturnT(
            inline_style=from_dict(
                css.CSSStyle,
                data.get('inline_style', None),
                casing_strategy
            ),
            attributes_style=from_dict(
                css.CSSStyle,
                data.get('attributes_style', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return css.GetInlineStylesForNodeReturnT(
            inline_style=from_dict(
                css.CSSStyle,
                data.get('inlineStyle', None),
                casing_strategy
            ),
            attributes_style=from_dict(
                css.CSSStyle,
                data.get('attributesStyle', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return css.GetInlineStylesForNodeReturnT(
            inline_style=from_dict(
                css.CSSStyle,
                data.get('InlineStyle', None),
                casing_strategy
            ),
            attributes_style=from_dict(
                css.CSSStyle,
                data.get('AttributesStyle', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__get_matched_styles_for_node_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.GetMatchedStylesForNodeReturnT':

    if casing_strategy == 'snake':
        return css.GetMatchedStylesForNodeReturnT(
            inline_style=from_dict(
                css.CSSStyle,
                data.get('inline_style', None),
                casing_strategy
            ),
            attributes_style=from_dict(
                css.CSSStyle,
                data.get('attributes_style', None),
                casing_strategy
            ),
            matched_css_rules=[
                from_dict(css.RuleMatch, item, casing_strategy)
                for item in data.get('matched_css_rules', [])
            ],
            pseudo_elements=[
                from_dict(css.PseudoElementMatches, item, casing_strategy)
                for item in data.get('pseudo_elements', [])
            ],
            inherited=[
                from_dict(css.InheritedStyleEntry, item, casing_strategy)
                for item in data.get('inherited', [])
            ],
            inherited_pseudo_elements=[
                from_dict(css.InheritedPseudoElementMatches, item, casing_strategy)
                for item in data.get('inherited_pseudo_elements', [])
            ],
            css_keyframes_rules=[
                from_dict(css.CSSKeyframesRule, item, casing_strategy)
                for item in data.get('css_keyframes_rules', [])
            ],
            css_position_fallback_rules=[
                from_dict(css.CSSPositionFallbackRule, item, casing_strategy)
                for item in data.get('css_position_fallback_rules', [])
            ],
            css_property_rules=[
                from_dict(css.CSSPropertyRule, item, casing_strategy)
                for item in data.get('css_property_rules', [])
            ],
            css_property_registrations=[
                from_dict(css.CSSPropertyRegistration, item, casing_strategy)
                for item in data.get('css_property_registrations', [])
            ],
            parent_layout_node_id=data.get('parent_layout_node_id', None)
        )

    if casing_strategy == 'camel':
        return css.GetMatchedStylesForNodeReturnT(
            inline_style=from_dict(
                css.CSSStyle,
                data.get('inlineStyle', None),
                casing_strategy
            ),
            attributes_style=from_dict(
                css.CSSStyle,
                data.get('attributesStyle', None),
                casing_strategy
            ),
            matched_css_rules=[
                from_dict(css.RuleMatch, item, casing_strategy)
                for item in data.get('matchedCSSRules', [])
            ],
            pseudo_elements=[
                from_dict(css.PseudoElementMatches, item, casing_strategy)
                for item in data.get('pseudoElements', [])
            ],
            inherited=[
                from_dict(css.InheritedStyleEntry, item, casing_strategy)
                for item in data.get('inherited', [])
            ],
            inherited_pseudo_elements=[
                from_dict(css.InheritedPseudoElementMatches, item, casing_strategy)
                for item in data.get('inheritedPseudoElements', [])
            ],
            css_keyframes_rules=[
                from_dict(css.CSSKeyframesRule, item, casing_strategy)
                for item in data.get('cssKeyframesRules', [])
            ],
            css_position_fallback_rules=[
                from_dict(css.CSSPositionFallbackRule, item, casing_strategy)
                for item in data.get('cssPositionFallbackRules', [])
            ],
            css_property_rules=[
                from_dict(css.CSSPropertyRule, item, casing_strategy)
                for item in data.get('cssPropertyRules', [])
            ],
            css_property_registrations=[
                from_dict(css.CSSPropertyRegistration, item, casing_strategy)
                for item in data.get('cssPropertyRegistrations', [])
            ],
            parent_layout_node_id=data.get('parentLayoutNodeId', None)
        )

    if casing_strategy == 'pascal':
        return css.GetMatchedStylesForNodeReturnT(
            inline_style=from_dict(
                css.CSSStyle,
                data.get('InlineStyle', None),
                casing_strategy
            ),
            attributes_style=from_dict(
                css.CSSStyle,
                data.get('AttributesStyle', None),
                casing_strategy
            ),
            matched_css_rules=[
                from_dict(css.RuleMatch, item, casing_strategy)
                for item in data.get('MatchedCSSRules', [])
            ],
            pseudo_elements=[
                from_dict(css.PseudoElementMatches, item, casing_strategy)
                for item in data.get('PseudoElements', [])
            ],
            inherited=[
                from_dict(css.InheritedStyleEntry, item, casing_strategy)
                for item in data.get('Inherited', [])
            ],
            inherited_pseudo_elements=[
                from_dict(css.InheritedPseudoElementMatches, item, casing_strategy)
                for item in data.get('InheritedPseudoElements', [])
            ],
            css_keyframes_rules=[
                from_dict(css.CSSKeyframesRule, item, casing_strategy)
                for item in data.get('CssKeyframesRules', [])
            ],
            css_position_fallback_rules=[
                from_dict(css.CSSPositionFallbackRule, item, casing_strategy)
                for item in data.get('CssPositionFallbackRules', [])
            ],
            css_property_rules=[
                from_dict(css.CSSPropertyRule, item, casing_strategy)
                for item in data.get('CssPropertyRules', [])
            ],
            css_property_registrations=[
                from_dict(css.CSSPropertyRegistration, item, casing_strategy)
                for item in data.get('CssPropertyRegistrations', [])
            ],
            parent_layout_node_id=data.get('ParentLayoutNodeId', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__get_media_queries_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.GetMediaQueriesReturnT':

    if casing_strategy == 'snake':
        return css.GetMediaQueriesReturnT(
            medias=[
                from_dict(css.CSSMedia, item, casing_strategy)
                for item in data['medias']
            ]
        )

    if casing_strategy == 'camel':
        return css.GetMediaQueriesReturnT(
            medias=[
                from_dict(css.CSSMedia, item, casing_strategy)
                for item in data['medias']
            ]
        )

    if casing_strategy == 'pascal':
        return css.GetMediaQueriesReturnT(
            medias=[
                from_dict(css.CSSMedia, item, casing_strategy)
                for item in data['Medias']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__get_platform_fonts_for_node_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.GetPlatformFontsForNodeReturnT':

    if casing_strategy == 'snake':
        return css.GetPlatformFontsForNodeReturnT(
            fonts=[
                from_dict(css.PlatformFontUsage, item, casing_strategy)
                for item in data['fonts']
            ]
        )

    if casing_strategy == 'camel':
        return css.GetPlatformFontsForNodeReturnT(
            fonts=[
                from_dict(css.PlatformFontUsage, item, casing_strategy)
                for item in data['fonts']
            ]
        )

    if casing_strategy == 'pascal':
        return css.GetPlatformFontsForNodeReturnT(
            fonts=[
                from_dict(css.PlatformFontUsage, item, casing_strategy)
                for item in data['Fonts']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__get_style_sheet_text_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.GetStyleSheetTextReturnT':

    if casing_strategy == 'snake':
        return css.GetStyleSheetTextReturnT(
            text=data['text']
        )

    if casing_strategy == 'camel':
        return css.GetStyleSheetTextReturnT(
            text=data['text']
        )

    if casing_strategy == 'pascal':
        return css.GetStyleSheetTextReturnT(
            text=data['Text']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__get_layers_for_node_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.GetLayersForNodeReturnT':

    if casing_strategy == 'snake':
        return css.GetLayersForNodeReturnT(
            root_layer=from_dict(
                css.CSSLayerData,
                data['root_layer'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return css.GetLayersForNodeReturnT(
            root_layer=from_dict(
                css.CSSLayerData,
                data['rootLayer'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return css.GetLayersForNodeReturnT(
            root_layer=from_dict(
                css.CSSLayerData,
                data['RootLayer'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__take_computed_style_updates_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.TakeComputedStyleUpdatesReturnT':

    if casing_strategy == 'snake':
        return css.TakeComputedStyleUpdatesReturnT(
            node_ids=data['node_ids']
        )

    if casing_strategy == 'camel':
        return css.TakeComputedStyleUpdatesReturnT(
            node_ids=data['nodeIds']
        )

    if casing_strategy == 'pascal':
        return css.TakeComputedStyleUpdatesReturnT(
            node_ids=data['NodeIds']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__set_keyframe_key_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.SetKeyframeKeyReturnT':

    if casing_strategy == 'snake':
        return css.SetKeyframeKeyReturnT(
            key_text=from_dict(
                css.Value,
                data['key_text'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return css.SetKeyframeKeyReturnT(
            key_text=from_dict(
                css.Value,
                data['keyText'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return css.SetKeyframeKeyReturnT(
            key_text=from_dict(
                css.Value,
                data['KeyText'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__set_media_text_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.SetMediaTextReturnT':

    if casing_strategy == 'snake':
        return css.SetMediaTextReturnT(
            media=from_dict(
                css.CSSMedia,
                data['media'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return css.SetMediaTextReturnT(
            media=from_dict(
                css.CSSMedia,
                data['media'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return css.SetMediaTextReturnT(
            media=from_dict(
                css.CSSMedia,
                data['Media'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__set_container_query_text_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.SetContainerQueryTextReturnT':

    if casing_strategy == 'snake':
        return css.SetContainerQueryTextReturnT(
            container_query=from_dict(
                css.CSSContainerQuery,
                data['container_query'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return css.SetContainerQueryTextReturnT(
            container_query=from_dict(
                css.CSSContainerQuery,
                data['containerQuery'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return css.SetContainerQueryTextReturnT(
            container_query=from_dict(
                css.CSSContainerQuery,
                data['ContainerQuery'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__set_supports_text_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.SetSupportsTextReturnT':

    if casing_strategy == 'snake':
        return css.SetSupportsTextReturnT(
            supports=from_dict(
                css.CSSSupports,
                data['supports'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return css.SetSupportsTextReturnT(
            supports=from_dict(
                css.CSSSupports,
                data['supports'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return css.SetSupportsTextReturnT(
            supports=from_dict(
                css.CSSSupports,
                data['Supports'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__set_scope_text_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.SetScopeTextReturnT':

    if casing_strategy == 'snake':
        return css.SetScopeTextReturnT(
            scope=from_dict(
                css.CSSScope,
                data['scope'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return css.SetScopeTextReturnT(
            scope=from_dict(
                css.CSSScope,
                data['scope'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return css.SetScopeTextReturnT(
            scope=from_dict(
                css.CSSScope,
                data['Scope'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__set_rule_selector_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.SetRuleSelectorReturnT':

    if casing_strategy == 'snake':
        return css.SetRuleSelectorReturnT(
            selector_list=from_dict(
                css.SelectorList,
                data['selector_list'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return css.SetRuleSelectorReturnT(
            selector_list=from_dict(
                css.SelectorList,
                data['selectorList'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return css.SetRuleSelectorReturnT(
            selector_list=from_dict(
                css.SelectorList,
                data['SelectorList'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__set_style_sheet_text_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.SetStyleSheetTextReturnT':

    if casing_strategy == 'snake':
        return css.SetStyleSheetTextReturnT(
            source_map_url=data.get('source_map_url', None)
        )

    if casing_strategy == 'camel':
        return css.SetStyleSheetTextReturnT(
            source_map_url=data.get('sourceMapURL', None)
        )

    if casing_strategy == 'pascal':
        return css.SetStyleSheetTextReturnT(
            source_map_url=data.get('SourceMapURL', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__set_style_texts_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.SetStyleTextsReturnT':

    if casing_strategy == 'snake':
        return css.SetStyleTextsReturnT(
            styles=[
                from_dict(css.CSSStyle, item, casing_strategy)
                for item in data['styles']
            ]
        )

    if casing_strategy == 'camel':
        return css.SetStyleTextsReturnT(
            styles=[
                from_dict(css.CSSStyle, item, casing_strategy)
                for item in data['styles']
            ]
        )

    if casing_strategy == 'pascal':
        return css.SetStyleTextsReturnT(
            styles=[
                from_dict(css.CSSStyle, item, casing_strategy)
                for item in data['Styles']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__stop_rule_usage_tracking_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.StopRuleUsageTrackingReturnT':

    if casing_strategy == 'snake':
        return css.StopRuleUsageTrackingReturnT(
            rule_usage=[
                from_dict(css.RuleUsage, item, casing_strategy)
                for item in data['rule_usage']
            ]
        )

    if casing_strategy == 'camel':
        return css.StopRuleUsageTrackingReturnT(
            rule_usage=[
                from_dict(css.RuleUsage, item, casing_strategy)
                for item in data['ruleUsage']
            ]
        )

    if casing_strategy == 'pascal':
        return css.StopRuleUsageTrackingReturnT(
            rule_usage=[
                from_dict(css.RuleUsage, item, casing_strategy)
                for item in data['RuleUsage']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _css__take_coverage_delta_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'css.TakeCoverageDeltaReturnT':

    if casing_strategy == 'snake':
        return css.TakeCoverageDeltaReturnT(
            coverage=[
                from_dict(css.RuleUsage, item, casing_strategy)
                for item in data['coverage']
            ],
            timestamp=data['timestamp']
        )

    if casing_strategy == 'camel':
        return css.TakeCoverageDeltaReturnT(
            coverage=[
                from_dict(css.RuleUsage, item, casing_strategy)
                for item in data['coverage']
            ],
            timestamp=data['timestamp']
        )

    if casing_strategy == 'pascal':
        return css.TakeCoverageDeltaReturnT(
            coverage=[
                from_dict(css.RuleUsage, item, casing_strategy)
                for item in data['Coverage']
            ],
            timestamp=data['Timestamp']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _cache_storage__request_cache_names_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'cache_storage.RequestCacheNamesReturnT':

    if casing_strategy == 'snake':
        return cache_storage.RequestCacheNamesReturnT(
            caches=[
                from_dict(cache_storage.Cache, item, casing_strategy)
                for item in data['caches']
            ]
        )

    if casing_strategy == 'camel':
        return cache_storage.RequestCacheNamesReturnT(
            caches=[
                from_dict(cache_storage.Cache, item, casing_strategy)
                for item in data['caches']
            ]
        )

    if casing_strategy == 'pascal':
        return cache_storage.RequestCacheNamesReturnT(
            caches=[
                from_dict(cache_storage.Cache, item, casing_strategy)
                for item in data['Caches']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _cache_storage__request_cached_response_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'cache_storage.RequestCachedResponseReturnT':

    if casing_strategy == 'snake':
        return cache_storage.RequestCachedResponseReturnT(
            response=from_dict(
                cache_storage.CachedResponse,
                data['response'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return cache_storage.RequestCachedResponseReturnT(
            response=from_dict(
                cache_storage.CachedResponse,
                data['response'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return cache_storage.RequestCachedResponseReturnT(
            response=from_dict(
                cache_storage.CachedResponse,
                data['Response'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _cache_storage__request_entries_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'cache_storage.RequestEntriesReturnT':

    if casing_strategy == 'snake':
        return cache_storage.RequestEntriesReturnT(
            cache_data_entries=[
                from_dict(cache_storage.DataEntry, item, casing_strategy)
                for item in data['cache_data_entries']
            ],
            return_count=data['return_count']
        )

    if casing_strategy == 'camel':
        return cache_storage.RequestEntriesReturnT(
            cache_data_entries=[
                from_dict(cache_storage.DataEntry, item, casing_strategy)
                for item in data['cacheDataEntries']
            ],
            return_count=data['returnCount']
        )

    if casing_strategy == 'pascal':
        return cache_storage.RequestEntriesReturnT(
            cache_data_entries=[
                from_dict(cache_storage.DataEntry, item, casing_strategy)
                for item in data['CacheDataEntries']
            ],
            return_count=data['ReturnCount']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__collect_class_names_from_subtree_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.CollectClassNamesFromSubtreeReturnT':

    if casing_strategy == 'snake':
        return dom.CollectClassNamesFromSubtreeReturnT(
            class_names=data['class_names']
        )

    if casing_strategy == 'camel':
        return dom.CollectClassNamesFromSubtreeReturnT(
            class_names=data['classNames']
        )

    if casing_strategy == 'pascal':
        return dom.CollectClassNamesFromSubtreeReturnT(
            class_names=data['ClassNames']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__copy_to_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.CopyToReturnT':

    if casing_strategy == 'snake':
        return dom.CopyToReturnT(
            node_id=data['node_id']
        )

    if casing_strategy == 'camel':
        return dom.CopyToReturnT(
            node_id=data['nodeId']
        )

    if casing_strategy == 'pascal':
        return dom.CopyToReturnT(
            node_id=data['NodeId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__describe_node_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.DescribeNodeReturnT':

    if casing_strategy == 'snake':
        return dom.DescribeNodeReturnT(
            node=from_dict(
                dom.Node,
                data['node'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return dom.DescribeNodeReturnT(
            node=from_dict(
                dom.Node,
                data['node'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return dom.DescribeNodeReturnT(
            node=from_dict(
                dom.Node,
                data['Node'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__get_attributes_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.GetAttributesReturnT':

    if casing_strategy == 'snake':
        return dom.GetAttributesReturnT(
            attributes=data['attributes']
        )

    if casing_strategy == 'camel':
        return dom.GetAttributesReturnT(
            attributes=data['attributes']
        )

    if casing_strategy == 'pascal':
        return dom.GetAttributesReturnT(
            attributes=data['Attributes']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__get_box_model_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.GetBoxModelReturnT':

    if casing_strategy == 'snake':
        return dom.GetBoxModelReturnT(
            model=from_dict(
                dom.BoxModel,
                data['model'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return dom.GetBoxModelReturnT(
            model=from_dict(
                dom.BoxModel,
                data['model'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return dom.GetBoxModelReturnT(
            model=from_dict(
                dom.BoxModel,
                data['Model'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__get_content_quads_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.GetContentQuadsReturnT':

    if casing_strategy == 'snake':
        return dom.GetContentQuadsReturnT(
            quads=data['quads']
        )

    if casing_strategy == 'camel':
        return dom.GetContentQuadsReturnT(
            quads=data['quads']
        )

    if casing_strategy == 'pascal':
        return dom.GetContentQuadsReturnT(
            quads=data['Quads']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__get_document_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.GetDocumentReturnT':

    if casing_strategy == 'snake':
        return dom.GetDocumentReturnT(
            root=from_dict(
                dom.Node,
                data['root'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return dom.GetDocumentReturnT(
            root=from_dict(
                dom.Node,
                data['root'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return dom.GetDocumentReturnT(
            root=from_dict(
                dom.Node,
                data['Root'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__get_flattened_document_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.GetFlattenedDocumentReturnT':

    if casing_strategy == 'snake':
        return dom.GetFlattenedDocumentReturnT(
            nodes=[
                from_dict(dom.Node, item, casing_strategy)
                for item in data['nodes']
            ]
        )

    if casing_strategy == 'camel':
        return dom.GetFlattenedDocumentReturnT(
            nodes=[
                from_dict(dom.Node, item, casing_strategy)
                for item in data['nodes']
            ]
        )

    if casing_strategy == 'pascal':
        return dom.GetFlattenedDocumentReturnT(
            nodes=[
                from_dict(dom.Node, item, casing_strategy)
                for item in data['Nodes']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__get_nodes_for_subtree_by_style_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.GetNodesForSubtreeByStyleReturnT':

    if casing_strategy == 'snake':
        return dom.GetNodesForSubtreeByStyleReturnT(
            node_ids=data['node_ids']
        )

    if casing_strategy == 'camel':
        return dom.GetNodesForSubtreeByStyleReturnT(
            node_ids=data['nodeIds']
        )

    if casing_strategy == 'pascal':
        return dom.GetNodesForSubtreeByStyleReturnT(
            node_ids=data['NodeIds']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__get_node_for_location_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.GetNodeForLocationReturnT':

    if casing_strategy == 'snake':
        return dom.GetNodeForLocationReturnT(
            backend_node_id=data['backend_node_id'],
            frame_id=data['frame_id'],
            node_id=data.get('node_id', None)
        )

    if casing_strategy == 'camel':
        return dom.GetNodeForLocationReturnT(
            backend_node_id=data['backendNodeId'],
            frame_id=data['frameId'],
            node_id=data.get('nodeId', None)
        )

    if casing_strategy == 'pascal':
        return dom.GetNodeForLocationReturnT(
            backend_node_id=data['BackendNodeId'],
            frame_id=data['FrameId'],
            node_id=data.get('NodeId', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__get_outer_html_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.GetOuterHTMLReturnT':

    if casing_strategy == 'snake':
        return dom.GetOuterHTMLReturnT(
            outer_html=data['outer_html']
        )

    if casing_strategy == 'camel':
        return dom.GetOuterHTMLReturnT(
            outer_html=data['outerHTML']
        )

    if casing_strategy == 'pascal':
        return dom.GetOuterHTMLReturnT(
            outer_html=data['OuterHTML']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__get_relayout_boundary_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.GetRelayoutBoundaryReturnT':

    if casing_strategy == 'snake':
        return dom.GetRelayoutBoundaryReturnT(
            node_id=data['node_id']
        )

    if casing_strategy == 'camel':
        return dom.GetRelayoutBoundaryReturnT(
            node_id=data['nodeId']
        )

    if casing_strategy == 'pascal':
        return dom.GetRelayoutBoundaryReturnT(
            node_id=data['NodeId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__get_search_results_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.GetSearchResultsReturnT':

    if casing_strategy == 'snake':
        return dom.GetSearchResultsReturnT(
            node_ids=data['node_ids']
        )

    if casing_strategy == 'camel':
        return dom.GetSearchResultsReturnT(
            node_ids=data['nodeIds']
        )

    if casing_strategy == 'pascal':
        return dom.GetSearchResultsReturnT(
            node_ids=data['NodeIds']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__move_to_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.MoveToReturnT':

    if casing_strategy == 'snake':
        return dom.MoveToReturnT(
            node_id=data['node_id']
        )

    if casing_strategy == 'camel':
        return dom.MoveToReturnT(
            node_id=data['nodeId']
        )

    if casing_strategy == 'pascal':
        return dom.MoveToReturnT(
            node_id=data['NodeId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__perform_search_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.PerformSearchReturnT':

    if casing_strategy == 'snake':
        return dom.PerformSearchReturnT(
            search_id=data['search_id'],
            result_count=data['result_count']
        )

    if casing_strategy == 'camel':
        return dom.PerformSearchReturnT(
            search_id=data['searchId'],
            result_count=data['resultCount']
        )

    if casing_strategy == 'pascal':
        return dom.PerformSearchReturnT(
            search_id=data['SearchId'],
            result_count=data['ResultCount']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__push_node_by_path_to_frontend_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.PushNodeByPathToFrontendReturnT':

    if casing_strategy == 'snake':
        return dom.PushNodeByPathToFrontendReturnT(
            node_id=data['node_id']
        )

    if casing_strategy == 'camel':
        return dom.PushNodeByPathToFrontendReturnT(
            node_id=data['nodeId']
        )

    if casing_strategy == 'pascal':
        return dom.PushNodeByPathToFrontendReturnT(
            node_id=data['NodeId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__push_nodes_by_backend_ids_to_frontend_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.PushNodesByBackendIdsToFrontendReturnT':

    if casing_strategy == 'snake':
        return dom.PushNodesByBackendIdsToFrontendReturnT(
            node_ids=data['node_ids']
        )

    if casing_strategy == 'camel':
        return dom.PushNodesByBackendIdsToFrontendReturnT(
            node_ids=data['nodeIds']
        )

    if casing_strategy == 'pascal':
        return dom.PushNodesByBackendIdsToFrontendReturnT(
            node_ids=data['NodeIds']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__query_selector_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.QuerySelectorReturnT':

    if casing_strategy == 'snake':
        return dom.QuerySelectorReturnT(
            node_id=data['node_id']
        )

    if casing_strategy == 'camel':
        return dom.QuerySelectorReturnT(
            node_id=data['nodeId']
        )

    if casing_strategy == 'pascal':
        return dom.QuerySelectorReturnT(
            node_id=data['NodeId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__query_selector_all_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.QuerySelectorAllReturnT':

    if casing_strategy == 'snake':
        return dom.QuerySelectorAllReturnT(
            node_ids=data['node_ids']
        )

    if casing_strategy == 'camel':
        return dom.QuerySelectorAllReturnT(
            node_ids=data['nodeIds']
        )

    if casing_strategy == 'pascal':
        return dom.QuerySelectorAllReturnT(
            node_ids=data['NodeIds']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__get_top_layer_elements_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.GetTopLayerElementsReturnT':

    if casing_strategy == 'snake':
        return dom.GetTopLayerElementsReturnT(
            node_ids=data['node_ids']
        )

    if casing_strategy == 'camel':
        return dom.GetTopLayerElementsReturnT(
            node_ids=data['nodeIds']
        )

    if casing_strategy == 'pascal':
        return dom.GetTopLayerElementsReturnT(
            node_ids=data['NodeIds']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__request_node_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.RequestNodeReturnT':

    if casing_strategy == 'snake':
        return dom.RequestNodeReturnT(
            node_id=data['node_id']
        )

    if casing_strategy == 'camel':
        return dom.RequestNodeReturnT(
            node_id=data['nodeId']
        )

    if casing_strategy == 'pascal':
        return dom.RequestNodeReturnT(
            node_id=data['NodeId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__resolve_node_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.ResolveNodeReturnT':

    if casing_strategy == 'snake':
        return dom.ResolveNodeReturnT(
            object=from_dict(
                dom.RemoteObject,
                data['object'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return dom.ResolveNodeReturnT(
            object=from_dict(
                dom.RemoteObject,
                data['object'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return dom.ResolveNodeReturnT(
            object=from_dict(
                dom.RemoteObject,
                data['Object'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__get_node_stack_traces_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.GetNodeStackTracesReturnT':

    if casing_strategy == 'snake':
        return dom.GetNodeStackTracesReturnT(
            creation=from_dict(
                dom.StackTrace,
                data.get('creation', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return dom.GetNodeStackTracesReturnT(
            creation=from_dict(
                dom.StackTrace,
                data.get('creation', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return dom.GetNodeStackTracesReturnT(
            creation=from_dict(
                dom.StackTrace,
                data.get('Creation', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__get_file_info_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.GetFileInfoReturnT':

    if casing_strategy == 'snake':
        return dom.GetFileInfoReturnT(
            path=data['path']
        )

    if casing_strategy == 'camel':
        return dom.GetFileInfoReturnT(
            path=data['path']
        )

    if casing_strategy == 'pascal':
        return dom.GetFileInfoReturnT(
            path=data['Path']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__set_node_name_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.SetNodeNameReturnT':

    if casing_strategy == 'snake':
        return dom.SetNodeNameReturnT(
            node_id=data['node_id']
        )

    if casing_strategy == 'camel':
        return dom.SetNodeNameReturnT(
            node_id=data['nodeId']
        )

    if casing_strategy == 'pascal':
        return dom.SetNodeNameReturnT(
            node_id=data['NodeId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__get_frame_owner_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.GetFrameOwnerReturnT':

    if casing_strategy == 'snake':
        return dom.GetFrameOwnerReturnT(
            backend_node_id=data['backend_node_id'],
            node_id=data.get('node_id', None)
        )

    if casing_strategy == 'camel':
        return dom.GetFrameOwnerReturnT(
            backend_node_id=data['backendNodeId'],
            node_id=data.get('nodeId', None)
        )

    if casing_strategy == 'pascal':
        return dom.GetFrameOwnerReturnT(
            backend_node_id=data['BackendNodeId'],
            node_id=data.get('NodeId', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__get_container_for_node_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.GetContainerForNodeReturnT':

    if casing_strategy == 'snake':
        return dom.GetContainerForNodeReturnT(
            node_id=data.get('node_id', None)
        )

    if casing_strategy == 'camel':
        return dom.GetContainerForNodeReturnT(
            node_id=data.get('nodeId', None)
        )

    if casing_strategy == 'pascal':
        return dom.GetContainerForNodeReturnT(
            node_id=data.get('NodeId', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom__get_querying_descendants_for_container_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom.GetQueryingDescendantsForContainerReturnT':

    if casing_strategy == 'snake':
        return dom.GetQueryingDescendantsForContainerReturnT(
            node_ids=data['node_ids']
        )

    if casing_strategy == 'camel':
        return dom.GetQueryingDescendantsForContainerReturnT(
            node_ids=data['nodeIds']
        )

    if casing_strategy == 'pascal':
        return dom.GetQueryingDescendantsForContainerReturnT(
            node_ids=data['NodeIds']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_debugger__get_event_listeners_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom_debugger.GetEventListenersReturnT':

    if casing_strategy == 'snake':
        return dom_debugger.GetEventListenersReturnT(
            listeners=[
                from_dict(dom_debugger.EventListener, item, casing_strategy)
                for item in data['listeners']
            ]
        )

    if casing_strategy == 'camel':
        return dom_debugger.GetEventListenersReturnT(
            listeners=[
                from_dict(dom_debugger.EventListener, item, casing_strategy)
                for item in data['listeners']
            ]
        )

    if casing_strategy == 'pascal':
        return dom_debugger.GetEventListenersReturnT(
            listeners=[
                from_dict(dom_debugger.EventListener, item, casing_strategy)
                for item in data['Listeners']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__get_snapshot_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom_snapshot.GetSnapshotReturnT':

    if casing_strategy == 'snake':
        return dom_snapshot.GetSnapshotReturnT(
            dom_nodes=[
                from_dict(dom_snapshot.DOMNode, item, casing_strategy)
                for item in data['dom_nodes']
            ],
            layout_tree_nodes=[
                from_dict(dom_snapshot.LayoutTreeNode, item, casing_strategy)
                for item in data['layout_tree_nodes']
            ],
            computed_styles=[
                from_dict(dom_snapshot.ComputedStyle, item, casing_strategy)
                for item in data['computed_styles']
            ]
        )

    if casing_strategy == 'camel':
        return dom_snapshot.GetSnapshotReturnT(
            dom_nodes=[
                from_dict(dom_snapshot.DOMNode, item, casing_strategy)
                for item in data['domNodes']
            ],
            layout_tree_nodes=[
                from_dict(dom_snapshot.LayoutTreeNode, item, casing_strategy)
                for item in data['layoutTreeNodes']
            ],
            computed_styles=[
                from_dict(dom_snapshot.ComputedStyle, item, casing_strategy)
                for item in data['computedStyles']
            ]
        )

    if casing_strategy == 'pascal':
        return dom_snapshot.GetSnapshotReturnT(
            dom_nodes=[
                from_dict(dom_snapshot.DOMNode, item, casing_strategy)
                for item in data['DomNodes']
            ],
            layout_tree_nodes=[
                from_dict(dom_snapshot.LayoutTreeNode, item, casing_strategy)
                for item in data['LayoutTreeNodes']
            ],
            computed_styles=[
                from_dict(dom_snapshot.ComputedStyle, item, casing_strategy)
                for item in data['ComputedStyles']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_snapshot__capture_snapshot_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom_snapshot.CaptureSnapshotReturnT':

    if casing_strategy == 'snake':
        return dom_snapshot.CaptureSnapshotReturnT(
            documents=[
                from_dict(dom_snapshot.DocumentSnapshot, item, casing_strategy)
                for item in data['documents']
            ],
            strings=data['strings']
        )

    if casing_strategy == 'camel':
        return dom_snapshot.CaptureSnapshotReturnT(
            documents=[
                from_dict(dom_snapshot.DocumentSnapshot, item, casing_strategy)
                for item in data['documents']
            ],
            strings=data['strings']
        )

    if casing_strategy == 'pascal':
        return dom_snapshot.CaptureSnapshotReturnT(
            documents=[
                from_dict(dom_snapshot.DocumentSnapshot, item, casing_strategy)
                for item in data['Documents']
            ],
            strings=data['Strings']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _dom_storage__get_dom_storage_items_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'dom_storage.GetDOMStorageItemsReturnT':

    if casing_strategy == 'snake':
        return dom_storage.GetDOMStorageItemsReturnT(
            entries=data['entries']
        )

    if casing_strategy == 'camel':
        return dom_storage.GetDOMStorageItemsReturnT(
            entries=data['entries']
        )

    if casing_strategy == 'pascal':
        return dom_storage.GetDOMStorageItemsReturnT(
            entries=data['Entries']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _database__execute_sql_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'database.ExecuteSQLReturnT':

    if casing_strategy == 'snake':
        return database.ExecuteSQLReturnT(
            column_names=data.get('column_names', []),
            values=data.get('values', []),
            sql_error=from_dict(
                database.Error,
                data.get('sql_error', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return database.ExecuteSQLReturnT(
            column_names=data.get('columnNames', []),
            values=data.get('values', []),
            sql_error=from_dict(
                database.Error,
                data.get('sqlError', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return database.ExecuteSQLReturnT(
            column_names=data.get('ColumnNames', []),
            values=data.get('Values', []),
            sql_error=from_dict(
                database.Error,
                data.get('SqlError', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _database__get_database_table_names_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'database.GetDatabaseTableNamesReturnT':

    if casing_strategy == 'snake':
        return database.GetDatabaseTableNamesReturnT(
            table_names=data['table_names']
        )

    if casing_strategy == 'camel':
        return database.GetDatabaseTableNamesReturnT(
            table_names=data['tableNames']
        )

    if casing_strategy == 'pascal':
        return database.GetDatabaseTableNamesReturnT(
            table_names=data['TableNames']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _emulation__can_emulate_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'emulation.CanEmulateReturnT':

    if casing_strategy == 'snake':
        return emulation.CanEmulateReturnT(
            result=data['result']
        )

    if casing_strategy == 'camel':
        return emulation.CanEmulateReturnT(
            result=data['result']
        )

    if casing_strategy == 'pascal':
        return emulation.CanEmulateReturnT(
            result=data['Result']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _emulation__set_virtual_time_policy_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'emulation.SetVirtualTimePolicyReturnT':

    if casing_strategy == 'snake':
        return emulation.SetVirtualTimePolicyReturnT(
            virtual_time_ticks_base=data['virtual_time_ticks_base']
        )

    if casing_strategy == 'camel':
        return emulation.SetVirtualTimePolicyReturnT(
            virtual_time_ticks_base=data['virtualTimeTicksBase']
        )

    if casing_strategy == 'pascal':
        return emulation.SetVirtualTimePolicyReturnT(
            virtual_time_ticks_base=data['VirtualTimeTicksBase']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _headless_experimental__begin_frame_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'headless_experimental.BeginFrameReturnT':

    if casing_strategy == 'snake':
        return headless_experimental.BeginFrameReturnT(
            has_damage=data['has_damage'],
            screenshot_data=data.get('screenshot_data', None)
        )

    if casing_strategy == 'camel':
        return headless_experimental.BeginFrameReturnT(
            has_damage=data['hasDamage'],
            screenshot_data=data.get('screenshotData', None)
        )

    if casing_strategy == 'pascal':
        return headless_experimental.BeginFrameReturnT(
            has_damage=data['HasDamage'],
            screenshot_data=data.get('ScreenshotData', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _io__read_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'io.ReadReturnT':

    if casing_strategy == 'snake':
        return io.ReadReturnT(
            base64_encoded=data.get('base64_encoded', None),
            data=data['data'],
            eof=data['eof']
        )

    if casing_strategy == 'camel':
        return io.ReadReturnT(
            base64_encoded=data.get('base64Encoded', None),
            data=data['data'],
            eof=data['eof']
        )

    if casing_strategy == 'pascal':
        return io.ReadReturnT(
            base64_encoded=data.get('Base64Encoded', None),
            data=data['Data'],
            eof=data['Eof']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _io__resolve_blob_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'io.ResolveBlobReturnT':

    if casing_strategy == 'snake':
        return io.ResolveBlobReturnT(
            uuid=data['uuid']
        )

    if casing_strategy == 'camel':
        return io.ResolveBlobReturnT(
            uuid=data['uuid']
        )

    if casing_strategy == 'pascal':
        return io.ResolveBlobReturnT(
            uuid=data['Uuid']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _indexed_db__request_data_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'indexed_db.RequestDataReturnT':

    if casing_strategy == 'snake':
        return indexed_db.RequestDataReturnT(
            object_store_data_entries=[
                from_dict(indexed_db.DataEntry, item, casing_strategy)
                for item in data['object_store_data_entries']
            ],
            has_more=data['has_more']
        )

    if casing_strategy == 'camel':
        return indexed_db.RequestDataReturnT(
            object_store_data_entries=[
                from_dict(indexed_db.DataEntry, item, casing_strategy)
                for item in data['objectStoreDataEntries']
            ],
            has_more=data['hasMore']
        )

    if casing_strategy == 'pascal':
        return indexed_db.RequestDataReturnT(
            object_store_data_entries=[
                from_dict(indexed_db.DataEntry, item, casing_strategy)
                for item in data['ObjectStoreDataEntries']
            ],
            has_more=data['HasMore']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _indexed_db__get_metadata_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'indexed_db.GetMetadataReturnT':

    if casing_strategy == 'snake':
        return indexed_db.GetMetadataReturnT(
            entries_count=data['entries_count'],
            key_generator_value=data['key_generator_value']
        )

    if casing_strategy == 'camel':
        return indexed_db.GetMetadataReturnT(
            entries_count=data['entriesCount'],
            key_generator_value=data['keyGeneratorValue']
        )

    if casing_strategy == 'pascal':
        return indexed_db.GetMetadataReturnT(
            entries_count=data['EntriesCount'],
            key_generator_value=data['KeyGeneratorValue']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _indexed_db__request_database_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'indexed_db.RequestDatabaseReturnT':

    if casing_strategy == 'snake':
        return indexed_db.RequestDatabaseReturnT(
            database_with_object_stores=from_dict(
                indexed_db.DatabaseWithObjectStores,
                data['database_with_object_stores'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return indexed_db.RequestDatabaseReturnT(
            database_with_object_stores=from_dict(
                indexed_db.DatabaseWithObjectStores,
                data['databaseWithObjectStores'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return indexed_db.RequestDatabaseReturnT(
            database_with_object_stores=from_dict(
                indexed_db.DatabaseWithObjectStores,
                data['DatabaseWithObjectStores'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _indexed_db__request_database_names_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'indexed_db.RequestDatabaseNamesReturnT':

    if casing_strategy == 'snake':
        return indexed_db.RequestDatabaseNamesReturnT(
            database_names=data['database_names']
        )

    if casing_strategy == 'camel':
        return indexed_db.RequestDatabaseNamesReturnT(
            database_names=data['databaseNames']
        )

    if casing_strategy == 'pascal':
        return indexed_db.RequestDatabaseNamesReturnT(
            database_names=data['DatabaseNames']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _layer_tree__compositing_reasons_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'layer_tree.CompositingReasonsReturnT':

    if casing_strategy == 'snake':
        return layer_tree.CompositingReasonsReturnT(
            compositing_reasons=data['compositing_reasons'],
            compositing_reason_ids=data['compositing_reason_ids']
        )

    if casing_strategy == 'camel':
        return layer_tree.CompositingReasonsReturnT(
            compositing_reasons=data['compositingReasons'],
            compositing_reason_ids=data['compositingReasonIds']
        )

    if casing_strategy == 'pascal':
        return layer_tree.CompositingReasonsReturnT(
            compositing_reasons=data['CompositingReasons'],
            compositing_reason_ids=data['CompositingReasonIds']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _layer_tree__load_snapshot_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'layer_tree.LoadSnapshotReturnT':

    if casing_strategy == 'snake':
        return layer_tree.LoadSnapshotReturnT(
            snapshot_id=data['snapshot_id']
        )

    if casing_strategy == 'camel':
        return layer_tree.LoadSnapshotReturnT(
            snapshot_id=data['snapshotId']
        )

    if casing_strategy == 'pascal':
        return layer_tree.LoadSnapshotReturnT(
            snapshot_id=data['SnapshotId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _layer_tree__make_snapshot_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'layer_tree.MakeSnapshotReturnT':

    if casing_strategy == 'snake':
        return layer_tree.MakeSnapshotReturnT(
            snapshot_id=data['snapshot_id']
        )

    if casing_strategy == 'camel':
        return layer_tree.MakeSnapshotReturnT(
            snapshot_id=data['snapshotId']
        )

    if casing_strategy == 'pascal':
        return layer_tree.MakeSnapshotReturnT(
            snapshot_id=data['SnapshotId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _layer_tree__profile_snapshot_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'layer_tree.ProfileSnapshotReturnT':

    if casing_strategy == 'snake':
        return layer_tree.ProfileSnapshotReturnT(
            timings=data['timings']
        )

    if casing_strategy == 'camel':
        return layer_tree.ProfileSnapshotReturnT(
            timings=data['timings']
        )

    if casing_strategy == 'pascal':
        return layer_tree.ProfileSnapshotReturnT(
            timings=data['Timings']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _layer_tree__replay_snapshot_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'layer_tree.ReplaySnapshotReturnT':

    if casing_strategy == 'snake':
        return layer_tree.ReplaySnapshotReturnT(
            data_url=data['data_url']
        )

    if casing_strategy == 'camel':
        return layer_tree.ReplaySnapshotReturnT(
            data_url=data['dataURL']
        )

    if casing_strategy == 'pascal':
        return layer_tree.ReplaySnapshotReturnT(
            data_url=data['DataURL']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _layer_tree__snapshot_command_log_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'layer_tree.SnapshotCommandLogReturnT':

    if casing_strategy == 'snake':
        return layer_tree.SnapshotCommandLogReturnT(
            command_log=data['command_log']
        )

    if casing_strategy == 'camel':
        return layer_tree.SnapshotCommandLogReturnT(
            command_log=data['commandLog']
        )

    if casing_strategy == 'pascal':
        return layer_tree.SnapshotCommandLogReturnT(
            command_log=data['CommandLog']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _memory__get_dom_counters_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'memory.GetDOMCountersReturnT':

    if casing_strategy == 'snake':
        return memory.GetDOMCountersReturnT(
            documents=data['documents'],
            nodes=data['nodes'],
            js_event_listeners=data['js_event_listeners']
        )

    if casing_strategy == 'camel':
        return memory.GetDOMCountersReturnT(
            documents=data['documents'],
            nodes=data['nodes'],
            js_event_listeners=data['jsEventListeners']
        )

    if casing_strategy == 'pascal':
        return memory.GetDOMCountersReturnT(
            documents=data['Documents'],
            nodes=data['Nodes'],
            js_event_listeners=data['JsEventListeners']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _memory__get_all_time_sampling_profile_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'memory.GetAllTimeSamplingProfileReturnT':

    if casing_strategy == 'snake':
        return memory.GetAllTimeSamplingProfileReturnT(
            profile=from_dict(
                memory.SamplingProfile,
                data['profile'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return memory.GetAllTimeSamplingProfileReturnT(
            profile=from_dict(
                memory.SamplingProfile,
                data['profile'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return memory.GetAllTimeSamplingProfileReturnT(
            profile=from_dict(
                memory.SamplingProfile,
                data['Profile'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _memory__get_browser_sampling_profile_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'memory.GetBrowserSamplingProfileReturnT':

    if casing_strategy == 'snake':
        return memory.GetBrowserSamplingProfileReturnT(
            profile=from_dict(
                memory.SamplingProfile,
                data['profile'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return memory.GetBrowserSamplingProfileReturnT(
            profile=from_dict(
                memory.SamplingProfile,
                data['profile'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return memory.GetBrowserSamplingProfileReturnT(
            profile=from_dict(
                memory.SamplingProfile,
                data['Profile'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _memory__get_sampling_profile_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'memory.GetSamplingProfileReturnT':

    if casing_strategy == 'snake':
        return memory.GetSamplingProfileReturnT(
            profile=from_dict(
                memory.SamplingProfile,
                data['profile'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return memory.GetSamplingProfileReturnT(
            profile=from_dict(
                memory.SamplingProfile,
                data['profile'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return memory.GetSamplingProfileReturnT(
            profile=from_dict(
                memory.SamplingProfile,
                data['Profile'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__can_clear_browser_cache_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.CanClearBrowserCacheReturnT':

    if casing_strategy == 'snake':
        return network.CanClearBrowserCacheReturnT(
            result=data['result']
        )

    if casing_strategy == 'camel':
        return network.CanClearBrowserCacheReturnT(
            result=data['result']
        )

    if casing_strategy == 'pascal':
        return network.CanClearBrowserCacheReturnT(
            result=data['Result']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__can_clear_browser_cookies_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.CanClearBrowserCookiesReturnT':

    if casing_strategy == 'snake':
        return network.CanClearBrowserCookiesReturnT(
            result=data['result']
        )

    if casing_strategy == 'camel':
        return network.CanClearBrowserCookiesReturnT(
            result=data['result']
        )

    if casing_strategy == 'pascal':
        return network.CanClearBrowserCookiesReturnT(
            result=data['Result']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__can_emulate_network_conditions_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.CanEmulateNetworkConditionsReturnT':

    if casing_strategy == 'snake':
        return network.CanEmulateNetworkConditionsReturnT(
            result=data['result']
        )

    if casing_strategy == 'camel':
        return network.CanEmulateNetworkConditionsReturnT(
            result=data['result']
        )

    if casing_strategy == 'pascal':
        return network.CanEmulateNetworkConditionsReturnT(
            result=data['Result']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__get_all_cookies_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.GetAllCookiesReturnT':

    if casing_strategy == 'snake':
        return network.GetAllCookiesReturnT(
            cookies=[
                from_dict(network.Cookie, item, casing_strategy)
                for item in data['cookies']
            ]
        )

    if casing_strategy == 'camel':
        return network.GetAllCookiesReturnT(
            cookies=[
                from_dict(network.Cookie, item, casing_strategy)
                for item in data['cookies']
            ]
        )

    if casing_strategy == 'pascal':
        return network.GetAllCookiesReturnT(
            cookies=[
                from_dict(network.Cookie, item, casing_strategy)
                for item in data['Cookies']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__get_certificate_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.GetCertificateReturnT':

    if casing_strategy == 'snake':
        return network.GetCertificateReturnT(
            table_names=data['table_names']
        )

    if casing_strategy == 'camel':
        return network.GetCertificateReturnT(
            table_names=data['tableNames']
        )

    if casing_strategy == 'pascal':
        return network.GetCertificateReturnT(
            table_names=data['TableNames']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__get_cookies_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.GetCookiesReturnT':

    if casing_strategy == 'snake':
        return network.GetCookiesReturnT(
            cookies=[
                from_dict(network.Cookie, item, casing_strategy)
                for item in data['cookies']
            ]
        )

    if casing_strategy == 'camel':
        return network.GetCookiesReturnT(
            cookies=[
                from_dict(network.Cookie, item, casing_strategy)
                for item in data['cookies']
            ]
        )

    if casing_strategy == 'pascal':
        return network.GetCookiesReturnT(
            cookies=[
                from_dict(network.Cookie, item, casing_strategy)
                for item in data['Cookies']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__get_response_body_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.GetResponseBodyReturnT':

    if casing_strategy == 'snake':
        return network.GetResponseBodyReturnT(
            body=data['body'],
            base64_encoded=data['base64_encoded']
        )

    if casing_strategy == 'camel':
        return network.GetResponseBodyReturnT(
            body=data['body'],
            base64_encoded=data['base64Encoded']
        )

    if casing_strategy == 'pascal':
        return network.GetResponseBodyReturnT(
            body=data['Body'],
            base64_encoded=data['Base64Encoded']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__get_request_post_data_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.GetRequestPostDataReturnT':

    if casing_strategy == 'snake':
        return network.GetRequestPostDataReturnT(
            post_data=data['post_data']
        )

    if casing_strategy == 'camel':
        return network.GetRequestPostDataReturnT(
            post_data=data['postData']
        )

    if casing_strategy == 'pascal':
        return network.GetRequestPostDataReturnT(
            post_data=data['PostData']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__get_response_body_for_interception_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.GetResponseBodyForInterceptionReturnT':

    if casing_strategy == 'snake':
        return network.GetResponseBodyForInterceptionReturnT(
            body=data['body'],
            base64_encoded=data['base64_encoded']
        )

    if casing_strategy == 'camel':
        return network.GetResponseBodyForInterceptionReturnT(
            body=data['body'],
            base64_encoded=data['base64Encoded']
        )

    if casing_strategy == 'pascal':
        return network.GetResponseBodyForInterceptionReturnT(
            body=data['Body'],
            base64_encoded=data['Base64Encoded']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__take_response_body_for_interception_as_stream_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.TakeResponseBodyForInterceptionAsStreamReturnT':

    if casing_strategy == 'snake':
        return network.TakeResponseBodyForInterceptionAsStreamReturnT(
            stream=data['stream']
        )

    if casing_strategy == 'camel':
        return network.TakeResponseBodyForInterceptionAsStreamReturnT(
            stream=data['stream']
        )

    if casing_strategy == 'pascal':
        return network.TakeResponseBodyForInterceptionAsStreamReturnT(
            stream=data['Stream']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__search_in_response_body_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.SearchInResponseBodyReturnT':

    if casing_strategy == 'snake':
        return network.SearchInResponseBodyReturnT(
            result=[
                from_dict(network.SearchMatch, item, casing_strategy)
                for item in data['result']
            ]
        )

    if casing_strategy == 'camel':
        return network.SearchInResponseBodyReturnT(
            result=[
                from_dict(network.SearchMatch, item, casing_strategy)
                for item in data['result']
            ]
        )

    if casing_strategy == 'pascal':
        return network.SearchInResponseBodyReturnT(
            result=[
                from_dict(network.SearchMatch, item, casing_strategy)
                for item in data['Result']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__set_cookie_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.SetCookieReturnT':

    if casing_strategy == 'snake':
        return network.SetCookieReturnT(
            success=data['success']
        )

    if casing_strategy == 'camel':
        return network.SetCookieReturnT(
            success=data['success']
        )

    if casing_strategy == 'pascal':
        return network.SetCookieReturnT(
            success=data['Success']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__get_security_isolation_status_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.GetSecurityIsolationStatusReturnT':

    if casing_strategy == 'snake':
        return network.GetSecurityIsolationStatusReturnT(
            status=from_dict(
                network.SecurityIsolationStatus,
                data['status'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return network.GetSecurityIsolationStatusReturnT(
            status=from_dict(
                network.SecurityIsolationStatus,
                data['status'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return network.GetSecurityIsolationStatusReturnT(
            status=from_dict(
                network.SecurityIsolationStatus,
                data['Status'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _network__load_network_resource_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'network.LoadNetworkResourceReturnT':

    if casing_strategy == 'snake':
        return network.LoadNetworkResourceReturnT(
            resource=from_dict(
                network.LoadNetworkResourcePageResult,
                data['resource'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return network.LoadNetworkResourceReturnT(
            resource=from_dict(
                network.LoadNetworkResourcePageResult,
                data['resource'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return network.LoadNetworkResourceReturnT(
            resource=from_dict(
                network.LoadNetworkResourcePageResult,
                data['Resource'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__get_highlight_object_for_test_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'overlay.GetHighlightObjectForTestReturnT':

    if casing_strategy == 'snake':
        return overlay.GetHighlightObjectForTestReturnT(
            highlight=data['highlight']
        )

    if casing_strategy == 'camel':
        return overlay.GetHighlightObjectForTestReturnT(
            highlight=data['highlight']
        )

    if casing_strategy == 'pascal':
        return overlay.GetHighlightObjectForTestReturnT(
            highlight=data['Highlight']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__get_grid_highlight_objects_for_test_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'overlay.GetGridHighlightObjectsForTestReturnT':

    if casing_strategy == 'snake':
        return overlay.GetGridHighlightObjectsForTestReturnT(
            highlights=data['highlights']
        )

    if casing_strategy == 'camel':
        return overlay.GetGridHighlightObjectsForTestReturnT(
            highlights=data['highlights']
        )

    if casing_strategy == 'pascal':
        return overlay.GetGridHighlightObjectsForTestReturnT(
            highlights=data['Highlights']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _overlay__get_source_order_highlight_object_for_test_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'overlay.GetSourceOrderHighlightObjectForTestReturnT':

    if casing_strategy == 'snake':
        return overlay.GetSourceOrderHighlightObjectForTestReturnT(
            highlight=data['highlight']
        )

    if casing_strategy == 'camel':
        return overlay.GetSourceOrderHighlightObjectForTestReturnT(
            highlight=data['highlight']
        )

    if casing_strategy == 'pascal':
        return overlay.GetSourceOrderHighlightObjectForTestReturnT(
            highlight=data['Highlight']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__add_script_to_evaluate_on_load_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.AddScriptToEvaluateOnLoadReturnT':

    if casing_strategy == 'snake':
        return page.AddScriptToEvaluateOnLoadReturnT(
            identifier=data['identifier']
        )

    if casing_strategy == 'camel':
        return page.AddScriptToEvaluateOnLoadReturnT(
            identifier=data['identifier']
        )

    if casing_strategy == 'pascal':
        return page.AddScriptToEvaluateOnLoadReturnT(
            identifier=data['Identifier']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__add_script_to_evaluate_on_new_document_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.AddScriptToEvaluateOnNewDocumentReturnT':

    if casing_strategy == 'snake':
        return page.AddScriptToEvaluateOnNewDocumentReturnT(
            identifier=data['identifier']
        )

    if casing_strategy == 'camel':
        return page.AddScriptToEvaluateOnNewDocumentReturnT(
            identifier=data['identifier']
        )

    if casing_strategy == 'pascal':
        return page.AddScriptToEvaluateOnNewDocumentReturnT(
            identifier=data['Identifier']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__capture_screenshot_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.CaptureScreenshotReturnT':

    if casing_strategy == 'snake':
        return page.CaptureScreenshotReturnT(
            data=data['data']
        )

    if casing_strategy == 'camel':
        return page.CaptureScreenshotReturnT(
            data=data['data']
        )

    if casing_strategy == 'pascal':
        return page.CaptureScreenshotReturnT(
            data=data['Data']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__capture_snapshot_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.CaptureSnapshotReturnT':

    if casing_strategy == 'snake':
        return page.CaptureSnapshotReturnT(
            data=data['data']
        )

    if casing_strategy == 'camel':
        return page.CaptureSnapshotReturnT(
            data=data['data']
        )

    if casing_strategy == 'pascal':
        return page.CaptureSnapshotReturnT(
            data=data['Data']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__create_isolated_world_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.CreateIsolatedWorldReturnT':

    if casing_strategy == 'snake':
        return page.CreateIsolatedWorldReturnT(
            execution_context_id=data['execution_context_id']
        )

    if casing_strategy == 'camel':
        return page.CreateIsolatedWorldReturnT(
            execution_context_id=data['executionContextId']
        )

    if casing_strategy == 'pascal':
        return page.CreateIsolatedWorldReturnT(
            execution_context_id=data['ExecutionContextId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__get_app_manifest_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.GetAppManifestReturnT':

    if casing_strategy == 'snake':
        return page.GetAppManifestReturnT(
            url=data['url'],
            errors=[
                from_dict(page.AppManifestError, item, casing_strategy)
                for item in data['errors']
            ],
            data=data.get('data', None),
            parsed=from_dict(
                page.AppManifestParsedProperties,
                data.get('parsed', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return page.GetAppManifestReturnT(
            url=data['url'],
            errors=[
                from_dict(page.AppManifestError, item, casing_strategy)
                for item in data['errors']
            ],
            data=data.get('data', None),
            parsed=from_dict(
                page.AppManifestParsedProperties,
                data.get('parsed', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return page.GetAppManifestReturnT(
            url=data['Url'],
            errors=[
                from_dict(page.AppManifestError, item, casing_strategy)
                for item in data['Errors']
            ],
            data=data.get('Data', None),
            parsed=from_dict(
                page.AppManifestParsedProperties,
                data.get('Parsed', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__get_installability_errors_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.GetInstallabilityErrorsReturnT':

    if casing_strategy == 'snake':
        return page.GetInstallabilityErrorsReturnT(
            installability_errors=[
                from_dict(page.InstallabilityError, item, casing_strategy)
                for item in data['installability_errors']
            ]
        )

    if casing_strategy == 'camel':
        return page.GetInstallabilityErrorsReturnT(
            installability_errors=[
                from_dict(page.InstallabilityError, item, casing_strategy)
                for item in data['installabilityErrors']
            ]
        )

    if casing_strategy == 'pascal':
        return page.GetInstallabilityErrorsReturnT(
            installability_errors=[
                from_dict(page.InstallabilityError, item, casing_strategy)
                for item in data['InstallabilityErrors']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__get_manifest_icons_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.GetManifestIconsReturnT':

    if casing_strategy == 'snake':
        return page.GetManifestIconsReturnT(
            primary_icon=data.get('primary_icon', None)
        )

    if casing_strategy == 'camel':
        return page.GetManifestIconsReturnT(
            primary_icon=data.get('primaryIcon', None)
        )

    if casing_strategy == 'pascal':
        return page.GetManifestIconsReturnT(
            primary_icon=data.get('PrimaryIcon', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__get_app_id_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.GetAppIdReturnT':

    if casing_strategy == 'snake':
        return page.GetAppIdReturnT(
            app_id=data.get('app_id', None),
            recommended_id=data.get('recommended_id', None)
        )

    if casing_strategy == 'camel':
        return page.GetAppIdReturnT(
            app_id=data.get('appId', None),
            recommended_id=data.get('recommendedId', None)
        )

    if casing_strategy == 'pascal':
        return page.GetAppIdReturnT(
            app_id=data.get('AppId', None),
            recommended_id=data.get('RecommendedId', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__get_ad_script_id_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.GetAdScriptIdReturnT':

    if casing_strategy == 'snake':
        return page.GetAdScriptIdReturnT(
            ad_script_id=from_dict(
                page.AdScriptId,
                data.get('ad_script_id', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return page.GetAdScriptIdReturnT(
            ad_script_id=from_dict(
                page.AdScriptId,
                data.get('adScriptId', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return page.GetAdScriptIdReturnT(
            ad_script_id=from_dict(
                page.AdScriptId,
                data.get('AdScriptId', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__get_cookies_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.GetCookiesReturnT':

    if casing_strategy == 'snake':
        return page.GetCookiesReturnT(
            cookies=[
                from_dict(page.Cookie, item, casing_strategy)
                for item in data['cookies']
            ]
        )

    if casing_strategy == 'camel':
        return page.GetCookiesReturnT(
            cookies=[
                from_dict(page.Cookie, item, casing_strategy)
                for item in data['cookies']
            ]
        )

    if casing_strategy == 'pascal':
        return page.GetCookiesReturnT(
            cookies=[
                from_dict(page.Cookie, item, casing_strategy)
                for item in data['Cookies']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__get_frame_tree_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.GetFrameTreeReturnT':

    if casing_strategy == 'snake':
        return page.GetFrameTreeReturnT(
            frame_tree=from_dict(
                page.FrameTree,
                data['frame_tree'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return page.GetFrameTreeReturnT(
            frame_tree=from_dict(
                page.FrameTree,
                data['frameTree'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return page.GetFrameTreeReturnT(
            frame_tree=from_dict(
                page.FrameTree,
                data['FrameTree'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__get_layout_metrics_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.GetLayoutMetricsReturnT':

    if casing_strategy == 'snake':
        return page.GetLayoutMetricsReturnT(
            layout_viewport=from_dict(
                page.LayoutViewport,
                data['layout_viewport'],
                casing_strategy
            ),
            visual_viewport=from_dict(
                page.VisualViewport,
                data['visual_viewport'],
                casing_strategy
            ),
            content_size=from_dict(
                page.Rect,
                data['content_size'],
                casing_strategy
            ),
            css_layout_viewport=from_dict(
                page.LayoutViewport,
                data['css_layout_viewport'],
                casing_strategy
            ),
            css_visual_viewport=from_dict(
                page.VisualViewport,
                data['css_visual_viewport'],
                casing_strategy
            ),
            css_content_size=from_dict(
                page.Rect,
                data['css_content_size'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return page.GetLayoutMetricsReturnT(
            layout_viewport=from_dict(
                page.LayoutViewport,
                data['layoutViewport'],
                casing_strategy
            ),
            visual_viewport=from_dict(
                page.VisualViewport,
                data['visualViewport'],
                casing_strategy
            ),
            content_size=from_dict(
                page.Rect,
                data['contentSize'],
                casing_strategy
            ),
            css_layout_viewport=from_dict(
                page.LayoutViewport,
                data['cssLayoutViewport'],
                casing_strategy
            ),
            css_visual_viewport=from_dict(
                page.VisualViewport,
                data['cssVisualViewport'],
                casing_strategy
            ),
            css_content_size=from_dict(
                page.Rect,
                data['cssContentSize'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return page.GetLayoutMetricsReturnT(
            layout_viewport=from_dict(
                page.LayoutViewport,
                data['LayoutViewport'],
                casing_strategy
            ),
            visual_viewport=from_dict(
                page.VisualViewport,
                data['VisualViewport'],
                casing_strategy
            ),
            content_size=from_dict(
                page.Rect,
                data['ContentSize'],
                casing_strategy
            ),
            css_layout_viewport=from_dict(
                page.LayoutViewport,
                data['CssLayoutViewport'],
                casing_strategy
            ),
            css_visual_viewport=from_dict(
                page.VisualViewport,
                data['CssVisualViewport'],
                casing_strategy
            ),
            css_content_size=from_dict(
                page.Rect,
                data['CssContentSize'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__get_navigation_history_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.GetNavigationHistoryReturnT':

    if casing_strategy == 'snake':
        return page.GetNavigationHistoryReturnT(
            current_index=data['current_index'],
            entries=[
                from_dict(page.NavigationEntry, item, casing_strategy)
                for item in data['entries']
            ]
        )

    if casing_strategy == 'camel':
        return page.GetNavigationHistoryReturnT(
            current_index=data['currentIndex'],
            entries=[
                from_dict(page.NavigationEntry, item, casing_strategy)
                for item in data['entries']
            ]
        )

    if casing_strategy == 'pascal':
        return page.GetNavigationHistoryReturnT(
            current_index=data['CurrentIndex'],
            entries=[
                from_dict(page.NavigationEntry, item, casing_strategy)
                for item in data['Entries']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__get_resource_content_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.GetResourceContentReturnT':

    if casing_strategy == 'snake':
        return page.GetResourceContentReturnT(
            content=data['content'],
            base64_encoded=data['base64_encoded']
        )

    if casing_strategy == 'camel':
        return page.GetResourceContentReturnT(
            content=data['content'],
            base64_encoded=data['base64Encoded']
        )

    if casing_strategy == 'pascal':
        return page.GetResourceContentReturnT(
            content=data['Content'],
            base64_encoded=data['Base64Encoded']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__get_resource_tree_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.GetResourceTreeReturnT':

    if casing_strategy == 'snake':
        return page.GetResourceTreeReturnT(
            frame_tree=from_dict(
                page.FrameResourceTree,
                data['frame_tree'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return page.GetResourceTreeReturnT(
            frame_tree=from_dict(
                page.FrameResourceTree,
                data['frameTree'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return page.GetResourceTreeReturnT(
            frame_tree=from_dict(
                page.FrameResourceTree,
                data['FrameTree'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__navigate_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.NavigateReturnT':

    if casing_strategy == 'snake':
        return page.NavigateReturnT(
            frame_id=data['frame_id'],
            loader_id=data.get('loader_id', None),
            error_text=data.get('error_text', None)
        )

    if casing_strategy == 'camel':
        return page.NavigateReturnT(
            frame_id=data['frameId'],
            loader_id=data.get('loaderId', None),
            error_text=data.get('errorText', None)
        )

    if casing_strategy == 'pascal':
        return page.NavigateReturnT(
            frame_id=data['FrameId'],
            loader_id=data.get('LoaderId', None),
            error_text=data.get('ErrorText', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__print_to_pdf_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.PrintToPDFReturnT':

    if casing_strategy == 'snake':
        return page.PrintToPDFReturnT(
            data=data['data'],
            stream=data.get('stream', None)
        )

    if casing_strategy == 'camel':
        return page.PrintToPDFReturnT(
            data=data['data'],
            stream=data.get('stream', None)
        )

    if casing_strategy == 'pascal':
        return page.PrintToPDFReturnT(
            data=data['Data'],
            stream=data.get('Stream', None)
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__search_in_resource_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.SearchInResourceReturnT':

    if casing_strategy == 'snake':
        return page.SearchInResourceReturnT(
            result=[
                from_dict(page.SearchMatch, item, casing_strategy)
                for item in data['result']
            ]
        )

    if casing_strategy == 'camel':
        return page.SearchInResourceReturnT(
            result=[
                from_dict(page.SearchMatch, item, casing_strategy)
                for item in data['result']
            ]
        )

    if casing_strategy == 'pascal':
        return page.SearchInResourceReturnT(
            result=[
                from_dict(page.SearchMatch, item, casing_strategy)
                for item in data['Result']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__get_permissions_policy_state_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.GetPermissionsPolicyStateReturnT':

    if casing_strategy == 'snake':
        return page.GetPermissionsPolicyStateReturnT(
            states=[
                from_dict(page.PermissionsPolicyFeatureState, item, casing_strategy)
                for item in data['states']
            ]
        )

    if casing_strategy == 'camel':
        return page.GetPermissionsPolicyStateReturnT(
            states=[
                from_dict(page.PermissionsPolicyFeatureState, item, casing_strategy)
                for item in data['states']
            ]
        )

    if casing_strategy == 'pascal':
        return page.GetPermissionsPolicyStateReturnT(
            states=[
                from_dict(page.PermissionsPolicyFeatureState, item, casing_strategy)
                for item in data['States']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _page__get_origin_trials_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'page.GetOriginTrialsReturnT':

    if casing_strategy == 'snake':
        return page.GetOriginTrialsReturnT(
            origin_trials=[
                from_dict(page.OriginTrial, item, casing_strategy)
                for item in data['origin_trials']
            ]
        )

    if casing_strategy == 'camel':
        return page.GetOriginTrialsReturnT(
            origin_trials=[
                from_dict(page.OriginTrial, item, casing_strategy)
                for item in data['originTrials']
            ]
        )

    if casing_strategy == 'pascal':
        return page.GetOriginTrialsReturnT(
            origin_trials=[
                from_dict(page.OriginTrial, item, casing_strategy)
                for item in data['OriginTrials']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _performance__get_metrics_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'performance.GetMetricsReturnT':

    if casing_strategy == 'snake':
        return performance.GetMetricsReturnT(
            metrics=[
                from_dict(performance.Metric, item, casing_strategy)
                for item in data['metrics']
            ]
        )

    if casing_strategy == 'camel':
        return performance.GetMetricsReturnT(
            metrics=[
                from_dict(performance.Metric, item, casing_strategy)
                for item in data['metrics']
            ]
        )

    if casing_strategy == 'pascal':
        return performance.GetMetricsReturnT(
            metrics=[
                from_dict(performance.Metric, item, casing_strategy)
                for item in data['Metrics']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__get_storage_key_for_frame_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.GetStorageKeyForFrameReturnT':

    if casing_strategy == 'snake':
        return storage.GetStorageKeyForFrameReturnT(
            storage_key=data['storage_key']
        )

    if casing_strategy == 'camel':
        return storage.GetStorageKeyForFrameReturnT(
            storage_key=data['storageKey']
        )

    if casing_strategy == 'pascal':
        return storage.GetStorageKeyForFrameReturnT(
            storage_key=data['StorageKey']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__get_cookies_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.GetCookiesReturnT':

    if casing_strategy == 'snake':
        return storage.GetCookiesReturnT(
            cookies=[
                from_dict(storage.Cookie, item, casing_strategy)
                for item in data['cookies']
            ]
        )

    if casing_strategy == 'camel':
        return storage.GetCookiesReturnT(
            cookies=[
                from_dict(storage.Cookie, item, casing_strategy)
                for item in data['cookies']
            ]
        )

    if casing_strategy == 'pascal':
        return storage.GetCookiesReturnT(
            cookies=[
                from_dict(storage.Cookie, item, casing_strategy)
                for item in data['Cookies']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__get_usage_and_quota_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.GetUsageAndQuotaReturnT':

    if casing_strategy == 'snake':
        return storage.GetUsageAndQuotaReturnT(
            usage=data['usage'],
            quota=data['quota'],
            override_active=data['override_active'],
            usage_breakdown=[
                from_dict(storage.UsageForType, item, casing_strategy)
                for item in data['usage_breakdown']
            ]
        )

    if casing_strategy == 'camel':
        return storage.GetUsageAndQuotaReturnT(
            usage=data['usage'],
            quota=data['quota'],
            override_active=data['overrideActive'],
            usage_breakdown=[
                from_dict(storage.UsageForType, item, casing_strategy)
                for item in data['usageBreakdown']
            ]
        )

    if casing_strategy == 'pascal':
        return storage.GetUsageAndQuotaReturnT(
            usage=data['Usage'],
            quota=data['Quota'],
            override_active=data['OverrideActive'],
            usage_breakdown=[
                from_dict(storage.UsageForType, item, casing_strategy)
                for item in data['UsageBreakdown']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__get_trust_tokens_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.GetTrustTokensReturnT':

    if casing_strategy == 'snake':
        return storage.GetTrustTokensReturnT(
            tokens=[
                from_dict(storage.TrustTokens, item, casing_strategy)
                for item in data['tokens']
            ]
        )

    if casing_strategy == 'camel':
        return storage.GetTrustTokensReturnT(
            tokens=[
                from_dict(storage.TrustTokens, item, casing_strategy)
                for item in data['tokens']
            ]
        )

    if casing_strategy == 'pascal':
        return storage.GetTrustTokensReturnT(
            tokens=[
                from_dict(storage.TrustTokens, item, casing_strategy)
                for item in data['Tokens']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__clear_trust_tokens_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.ClearTrustTokensReturnT':

    if casing_strategy == 'snake':
        return storage.ClearTrustTokensReturnT(
            did_delete_tokens=data['did_delete_tokens']
        )

    if casing_strategy == 'camel':
        return storage.ClearTrustTokensReturnT(
            did_delete_tokens=data['didDeleteTokens']
        )

    if casing_strategy == 'pascal':
        return storage.ClearTrustTokensReturnT(
            did_delete_tokens=data['DidDeleteTokens']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__get_interest_group_details_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.GetInterestGroupDetailsReturnT':

    if casing_strategy == 'snake':
        return storage.GetInterestGroupDetailsReturnT(
            details=from_dict(
                storage.InterestGroupDetails,
                data['details'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return storage.GetInterestGroupDetailsReturnT(
            details=from_dict(
                storage.InterestGroupDetails,
                data['details'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return storage.GetInterestGroupDetailsReturnT(
            details=from_dict(
                storage.InterestGroupDetails,
                data['Details'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__get_shared_storage_metadata_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.GetSharedStorageMetadataReturnT':

    if casing_strategy == 'snake':
        return storage.GetSharedStorageMetadataReturnT(
            metadata=from_dict(
                storage.SharedStorageMetadata,
                data['metadata'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return storage.GetSharedStorageMetadataReturnT(
            metadata=from_dict(
                storage.SharedStorageMetadata,
                data['metadata'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return storage.GetSharedStorageMetadataReturnT(
            metadata=from_dict(
                storage.SharedStorageMetadata,
                data['Metadata'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__get_shared_storage_entries_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.GetSharedStorageEntriesReturnT':

    if casing_strategy == 'snake':
        return storage.GetSharedStorageEntriesReturnT(
            entries=[
                from_dict(storage.SharedStorageEntry, item, casing_strategy)
                for item in data['entries']
            ]
        )

    if casing_strategy == 'camel':
        return storage.GetSharedStorageEntriesReturnT(
            entries=[
                from_dict(storage.SharedStorageEntry, item, casing_strategy)
                for item in data['entries']
            ]
        )

    if casing_strategy == 'pascal':
        return storage.GetSharedStorageEntriesReturnT(
            entries=[
                from_dict(storage.SharedStorageEntry, item, casing_strategy)
                for item in data['Entries']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _storage__run_bounce_tracking_mitigations_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'storage.RunBounceTrackingMitigationsReturnT':

    if casing_strategy == 'snake':
        return storage.RunBounceTrackingMitigationsReturnT(
            deleted_sites=data['deleted_sites']
        )

    if casing_strategy == 'camel':
        return storage.RunBounceTrackingMitigationsReturnT(
            deleted_sites=data['deletedSites']
        )

    if casing_strategy == 'pascal':
        return storage.RunBounceTrackingMitigationsReturnT(
            deleted_sites=data['DeletedSites']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _system_info__get_info_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'system_info.GetInfoReturnT':

    if casing_strategy == 'snake':
        return system_info.GetInfoReturnT(
            gpu=from_dict(
                system_info.GPUInfo,
                data['gpu'],
                casing_strategy
            ),
            model_name=data['model_name'],
            model_version=data['model_version'],
            command_line=data['command_line']
        )

    if casing_strategy == 'camel':
        return system_info.GetInfoReturnT(
            gpu=from_dict(
                system_info.GPUInfo,
                data['gpu'],
                casing_strategy
            ),
            model_name=data['modelName'],
            model_version=data['modelVersion'],
            command_line=data['commandLine']
        )

    if casing_strategy == 'pascal':
        return system_info.GetInfoReturnT(
            gpu=from_dict(
                system_info.GPUInfo,
                data['Gpu'],
                casing_strategy
            ),
            model_name=data['ModelName'],
            model_version=data['ModelVersion'],
            command_line=data['CommandLine']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _system_info__get_feature_state_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'system_info.GetFeatureStateReturnT':

    if casing_strategy == 'snake':
        return system_info.GetFeatureStateReturnT(
            feature_enabled=data['feature_enabled']
        )

    if casing_strategy == 'camel':
        return system_info.GetFeatureStateReturnT(
            feature_enabled=data['featureEnabled']
        )

    if casing_strategy == 'pascal':
        return system_info.GetFeatureStateReturnT(
            feature_enabled=data['FeatureEnabled']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _system_info__get_process_info_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'system_info.GetProcessInfoReturnT':

    if casing_strategy == 'snake':
        return system_info.GetProcessInfoReturnT(
            process_info=[
                from_dict(system_info.ProcessInfo, item, casing_strategy)
                for item in data['process_info']
            ]
        )

    if casing_strategy == 'camel':
        return system_info.GetProcessInfoReturnT(
            process_info=[
                from_dict(system_info.ProcessInfo, item, casing_strategy)
                for item in data['processInfo']
            ]
        )

    if casing_strategy == 'pascal':
        return system_info.GetProcessInfoReturnT(
            process_info=[
                from_dict(system_info.ProcessInfo, item, casing_strategy)
                for item in data['ProcessInfo']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _target__attach_to_target_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'target.AttachToTargetReturnT':

    if casing_strategy == 'snake':
        return target.AttachToTargetReturnT(
            session_id=data['session_id']
        )

    if casing_strategy == 'camel':
        return target.AttachToTargetReturnT(
            session_id=data['sessionId']
        )

    if casing_strategy == 'pascal':
        return target.AttachToTargetReturnT(
            session_id=data['SessionId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _target__attach_to_browser_target_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'target.AttachToBrowserTargetReturnT':

    if casing_strategy == 'snake':
        return target.AttachToBrowserTargetReturnT(
            session_id=data['session_id']
        )

    if casing_strategy == 'camel':
        return target.AttachToBrowserTargetReturnT(
            session_id=data['sessionId']
        )

    if casing_strategy == 'pascal':
        return target.AttachToBrowserTargetReturnT(
            session_id=data['SessionId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _target__close_target_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'target.CloseTargetReturnT':

    if casing_strategy == 'snake':
        return target.CloseTargetReturnT(
            success=data['success']
        )

    if casing_strategy == 'camel':
        return target.CloseTargetReturnT(
            success=data['success']
        )

    if casing_strategy == 'pascal':
        return target.CloseTargetReturnT(
            success=data['Success']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _target__create_browser_context_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'target.CreateBrowserContextReturnT':

    if casing_strategy == 'snake':
        return target.CreateBrowserContextReturnT(
            browser_context_id=data['browser_context_id']
        )

    if casing_strategy == 'camel':
        return target.CreateBrowserContextReturnT(
            browser_context_id=data['browserContextId']
        )

    if casing_strategy == 'pascal':
        return target.CreateBrowserContextReturnT(
            browser_context_id=data['BrowserContextId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _target__get_browser_contexts_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'target.GetBrowserContextsReturnT':

    if casing_strategy == 'snake':
        return target.GetBrowserContextsReturnT(
            browser_context_ids=data['browser_context_ids']
        )

    if casing_strategy == 'camel':
        return target.GetBrowserContextsReturnT(
            browser_context_ids=data['browserContextIds']
        )

    if casing_strategy == 'pascal':
        return target.GetBrowserContextsReturnT(
            browser_context_ids=data['BrowserContextIds']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _target__create_target_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'target.CreateTargetReturnT':

    if casing_strategy == 'snake':
        return target.CreateTargetReturnT(
            target_id=data['target_id']
        )

    if casing_strategy == 'camel':
        return target.CreateTargetReturnT(
            target_id=data['targetId']
        )

    if casing_strategy == 'pascal':
        return target.CreateTargetReturnT(
            target_id=data['TargetId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _target__get_target_info_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'target.GetTargetInfoReturnT':

    if casing_strategy == 'snake':
        return target.GetTargetInfoReturnT(
            target_info=from_dict(
                target.TargetInfo,
                data['target_info'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return target.GetTargetInfoReturnT(
            target_info=from_dict(
                target.TargetInfo,
                data['targetInfo'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return target.GetTargetInfoReturnT(
            target_info=from_dict(
                target.TargetInfo,
                data['TargetInfo'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _target__get_targets_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'target.GetTargetsReturnT':

    if casing_strategy == 'snake':
        return target.GetTargetsReturnT(
            target_infos=[
                from_dict(target.TargetInfo, item, casing_strategy)
                for item in data['target_infos']
            ]
        )

    if casing_strategy == 'camel':
        return target.GetTargetsReturnT(
            target_infos=[
                from_dict(target.TargetInfo, item, casing_strategy)
                for item in data['targetInfos']
            ]
        )

    if casing_strategy == 'pascal':
        return target.GetTargetsReturnT(
            target_infos=[
                from_dict(target.TargetInfo, item, casing_strategy)
                for item in data['TargetInfos']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _tracing__get_categories_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'tracing.GetCategoriesReturnT':

    if casing_strategy == 'snake':
        return tracing.GetCategoriesReturnT(
            categories=data['categories']
        )

    if casing_strategy == 'camel':
        return tracing.GetCategoriesReturnT(
            categories=data['categories']
        )

    if casing_strategy == 'pascal':
        return tracing.GetCategoriesReturnT(
            categories=data['Categories']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _tracing__request_memory_dump_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'tracing.RequestMemoryDumpReturnT':

    if casing_strategy == 'snake':
        return tracing.RequestMemoryDumpReturnT(
            dump_guid=data['dump_guid'],
            success=data['success']
        )

    if casing_strategy == 'camel':
        return tracing.RequestMemoryDumpReturnT(
            dump_guid=data['dumpGuid'],
            success=data['success']
        )

    if casing_strategy == 'pascal':
        return tracing.RequestMemoryDumpReturnT(
            dump_guid=data['DumpGuid'],
            success=data['Success']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _fetch__get_response_body_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'fetch.GetResponseBodyReturnT':

    if casing_strategy == 'snake':
        return fetch.GetResponseBodyReturnT(
            body=data['body'],
            base64_encoded=data['base64_encoded']
        )

    if casing_strategy == 'camel':
        return fetch.GetResponseBodyReturnT(
            body=data['body'],
            base64_encoded=data['base64Encoded']
        )

    if casing_strategy == 'pascal':
        return fetch.GetResponseBodyReturnT(
            body=data['Body'],
            base64_encoded=data['Base64Encoded']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _fetch__take_response_body_as_stream_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'fetch.TakeResponseBodyAsStreamReturnT':

    if casing_strategy == 'snake':
        return fetch.TakeResponseBodyAsStreamReturnT(
            stream=data['stream']
        )

    if casing_strategy == 'camel':
        return fetch.TakeResponseBodyAsStreamReturnT(
            stream=data['stream']
        )

    if casing_strategy == 'pascal':
        return fetch.TakeResponseBodyAsStreamReturnT(
            stream=data['Stream']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _web_audio__get_realtime_data_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'web_audio.GetRealtimeDataReturnT':

    if casing_strategy == 'snake':
        return web_audio.GetRealtimeDataReturnT(
            realtime_data=from_dict(
                web_audio.ContextRealtimeData,
                data['realtime_data'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return web_audio.GetRealtimeDataReturnT(
            realtime_data=from_dict(
                web_audio.ContextRealtimeData,
                data['realtimeData'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return web_audio.GetRealtimeDataReturnT(
            realtime_data=from_dict(
                web_audio.ContextRealtimeData,
                data['RealtimeData'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _web_authn__add_virtual_authenticator_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'web_authn.AddVirtualAuthenticatorReturnT':

    if casing_strategy == 'snake':
        return web_authn.AddVirtualAuthenticatorReturnT(
            authenticator_id=data['authenticator_id']
        )

    if casing_strategy == 'camel':
        return web_authn.AddVirtualAuthenticatorReturnT(
            authenticator_id=data['authenticatorId']
        )

    if casing_strategy == 'pascal':
        return web_authn.AddVirtualAuthenticatorReturnT(
            authenticator_id=data['AuthenticatorId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _web_authn__get_credential_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'web_authn.GetCredentialReturnT':

    if casing_strategy == 'snake':
        return web_authn.GetCredentialReturnT(
            credential=from_dict(
                web_authn.Credential,
                data['credential'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return web_authn.GetCredentialReturnT(
            credential=from_dict(
                web_authn.Credential,
                data['credential'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return web_authn.GetCredentialReturnT(
            credential=from_dict(
                web_authn.Credential,
                data['Credential'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _web_authn__get_credentials_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'web_authn.GetCredentialsReturnT':

    if casing_strategy == 'snake':
        return web_authn.GetCredentialsReturnT(
            credentials=[
                from_dict(web_authn.Credential, item, casing_strategy)
                for item in data['credentials']
            ]
        )

    if casing_strategy == 'camel':
        return web_authn.GetCredentialsReturnT(
            credentials=[
                from_dict(web_authn.Credential, item, casing_strategy)
                for item in data['credentials']
            ]
        )

    if casing_strategy == 'pascal':
        return web_authn.GetCredentialsReturnT(
            credentials=[
                from_dict(web_authn.Credential, item, casing_strategy)
                for item in data['Credentials']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__enable_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'debugger.EnableReturnT':

    if casing_strategy == 'snake':
        return debugger.EnableReturnT(
            debugger_id=data['debugger_id']
        )

    if casing_strategy == 'camel':
        return debugger.EnableReturnT(
            debugger_id=data['debuggerId']
        )

    if casing_strategy == 'pascal':
        return debugger.EnableReturnT(
            debugger_id=data['DebuggerId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__evaluate_on_call_frame_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'debugger.EvaluateOnCallFrameReturnT':

    if casing_strategy == 'snake':
        return debugger.EvaluateOnCallFrameReturnT(
            result=from_dict(
                debugger.RemoteObject,
                data['result'],
                casing_strategy
            ),
            exception_details=from_dict(
                debugger.ExceptionDetails,
                data.get('exception_details', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return debugger.EvaluateOnCallFrameReturnT(
            result=from_dict(
                debugger.RemoteObject,
                data['result'],
                casing_strategy
            ),
            exception_details=from_dict(
                debugger.ExceptionDetails,
                data.get('exceptionDetails', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return debugger.EvaluateOnCallFrameReturnT(
            result=from_dict(
                debugger.RemoteObject,
                data['Result'],
                casing_strategy
            ),
            exception_details=from_dict(
                debugger.ExceptionDetails,
                data.get('ExceptionDetails', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__get_possible_breakpoints_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'debugger.GetPossibleBreakpointsReturnT':

    if casing_strategy == 'snake':
        return debugger.GetPossibleBreakpointsReturnT(
            locations=[
                from_dict(debugger.BreakLocation, item, casing_strategy)
                for item in data['locations']
            ]
        )

    if casing_strategy == 'camel':
        return debugger.GetPossibleBreakpointsReturnT(
            locations=[
                from_dict(debugger.BreakLocation, item, casing_strategy)
                for item in data['locations']
            ]
        )

    if casing_strategy == 'pascal':
        return debugger.GetPossibleBreakpointsReturnT(
            locations=[
                from_dict(debugger.BreakLocation, item, casing_strategy)
                for item in data['Locations']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__get_script_source_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'debugger.GetScriptSourceReturnT':

    if casing_strategy == 'snake':
        return debugger.GetScriptSourceReturnT(
            script_source=data['script_source']
        )

    if casing_strategy == 'camel':
        return debugger.GetScriptSourceReturnT(
            script_source=data['scriptSource']
        )

    if casing_strategy == 'pascal':
        return debugger.GetScriptSourceReturnT(
            script_source=data['ScriptSource']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__get_stack_trace_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'debugger.GetStackTraceReturnT':

    if casing_strategy == 'snake':
        return debugger.GetStackTraceReturnT(
            stack_trace=from_dict(
                debugger.StackTrace,
                data['stack_trace'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return debugger.GetStackTraceReturnT(
            stack_trace=from_dict(
                debugger.StackTrace,
                data['stackTrace'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return debugger.GetStackTraceReturnT(
            stack_trace=from_dict(
                debugger.StackTrace,
                data['StackTrace'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__restart_frame_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'debugger.RestartFrameReturnT':

    if casing_strategy == 'snake':
        return debugger.RestartFrameReturnT(
            call_frames=[
                from_dict(debugger.CallFrame, item, casing_strategy)
                for item in data['call_frames']
            ],
            async_stack_trace=from_dict(
                debugger.StackTrace,
                data.get('async_stack_trace', None),
                casing_strategy
            ),
            async_stack_trace_id=from_dict(
                debugger.StackTraceId,
                data.get('async_stack_trace_id', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return debugger.RestartFrameReturnT(
            call_frames=[
                from_dict(debugger.CallFrame, item, casing_strategy)
                for item in data['callFrames']
            ],
            async_stack_trace=from_dict(
                debugger.StackTrace,
                data.get('asyncStackTrace', None),
                casing_strategy
            ),
            async_stack_trace_id=from_dict(
                debugger.StackTraceId,
                data.get('asyncStackTraceId', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return debugger.RestartFrameReturnT(
            call_frames=[
                from_dict(debugger.CallFrame, item, casing_strategy)
                for item in data['CallFrames']
            ],
            async_stack_trace=from_dict(
                debugger.StackTrace,
                data.get('AsyncStackTrace', None),
                casing_strategy
            ),
            async_stack_trace_id=from_dict(
                debugger.StackTraceId,
                data.get('AsyncStackTraceId', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__search_in_content_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'debugger.SearchInContentReturnT':

    if casing_strategy == 'snake':
        return debugger.SearchInContentReturnT(
            result=[
                from_dict(debugger.SearchMatch, item, casing_strategy)
                for item in data['result']
            ]
        )

    if casing_strategy == 'camel':
        return debugger.SearchInContentReturnT(
            result=[
                from_dict(debugger.SearchMatch, item, casing_strategy)
                for item in data['result']
            ]
        )

    if casing_strategy == 'pascal':
        return debugger.SearchInContentReturnT(
            result=[
                from_dict(debugger.SearchMatch, item, casing_strategy)
                for item in data['Result']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__set_breakpoint_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'debugger.SetBreakpointReturnT':

    if casing_strategy == 'snake':
        return debugger.SetBreakpointReturnT(
            breakpoint_id=data['breakpoint_id'],
            actual_location=from_dict(
                debugger.Location,
                data['actual_location'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return debugger.SetBreakpointReturnT(
            breakpoint_id=data['breakpointId'],
            actual_location=from_dict(
                debugger.Location,
                data['actualLocation'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return debugger.SetBreakpointReturnT(
            breakpoint_id=data['BreakpointId'],
            actual_location=from_dict(
                debugger.Location,
                data['ActualLocation'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__set_instrumentation_breakpoint_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'debugger.SetInstrumentationBreakpointReturnT':

    if casing_strategy == 'snake':
        return debugger.SetInstrumentationBreakpointReturnT(
            breakpoint_id=data['breakpoint_id']
        )

    if casing_strategy == 'camel':
        return debugger.SetInstrumentationBreakpointReturnT(
            breakpoint_id=data['breakpointId']
        )

    if casing_strategy == 'pascal':
        return debugger.SetInstrumentationBreakpointReturnT(
            breakpoint_id=data['BreakpointId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__set_breakpoint_by_url_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'debugger.SetBreakpointByUrlReturnT':

    if casing_strategy == 'snake':
        return debugger.SetBreakpointByUrlReturnT(
            breakpoint_id=data['breakpoint_id'],
            locations=[
                from_dict(debugger.Location, item, casing_strategy)
                for item in data['locations']
            ]
        )

    if casing_strategy == 'camel':
        return debugger.SetBreakpointByUrlReturnT(
            breakpoint_id=data['breakpointId'],
            locations=[
                from_dict(debugger.Location, item, casing_strategy)
                for item in data['locations']
            ]
        )

    if casing_strategy == 'pascal':
        return debugger.SetBreakpointByUrlReturnT(
            breakpoint_id=data['BreakpointId'],
            locations=[
                from_dict(debugger.Location, item, casing_strategy)
                for item in data['Locations']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__set_breakpoint_on_function_call_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'debugger.SetBreakpointOnFunctionCallReturnT':

    if casing_strategy == 'snake':
        return debugger.SetBreakpointOnFunctionCallReturnT(
            breakpoint_id=data['breakpoint_id']
        )

    if casing_strategy == 'camel':
        return debugger.SetBreakpointOnFunctionCallReturnT(
            breakpoint_id=data['breakpointId']
        )

    if casing_strategy == 'pascal':
        return debugger.SetBreakpointOnFunctionCallReturnT(
            breakpoint_id=data['BreakpointId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _debugger__set_script_source_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'debugger.SetScriptSourceReturnT':

    if casing_strategy == 'snake':
        return debugger.SetScriptSourceReturnT(
            call_frames=[
                from_dict(debugger.CallFrame, item, casing_strategy)
                for item in data.get('call_frames', [])
            ],
            stack_changed=data.get('stack_changed', None),
            async_stack_trace=from_dict(
                debugger.StackTrace,
                data.get('async_stack_trace', None),
                casing_strategy
            ),
            async_stack_trace_id=from_dict(
                debugger.StackTraceId,
                data.get('async_stack_trace_id', None),
                casing_strategy
            ),
            exception_details=from_dict(
                debugger.ExceptionDetails,
                data.get('exception_details', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return debugger.SetScriptSourceReturnT(
            call_frames=[
                from_dict(debugger.CallFrame, item, casing_strategy)
                for item in data.get('callFrames', [])
            ],
            stack_changed=data.get('stackChanged', None),
            async_stack_trace=from_dict(
                debugger.StackTrace,
                data.get('asyncStackTrace', None),
                casing_strategy
            ),
            async_stack_trace_id=from_dict(
                debugger.StackTraceId,
                data.get('asyncStackTraceId', None),
                casing_strategy
            ),
            exception_details=from_dict(
                debugger.ExceptionDetails,
                data.get('exceptionDetails', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return debugger.SetScriptSourceReturnT(
            call_frames=[
                from_dict(debugger.CallFrame, item, casing_strategy)
                for item in data.get('CallFrames', [])
            ],
            stack_changed=data.get('StackChanged', None),
            async_stack_trace=from_dict(
                debugger.StackTrace,
                data.get('AsyncStackTrace', None),
                casing_strategy
            ),
            async_stack_trace_id=from_dict(
                debugger.StackTraceId,
                data.get('AsyncStackTraceId', None),
                casing_strategy
            ),
            exception_details=from_dict(
                debugger.ExceptionDetails,
                data.get('ExceptionDetails', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _heap_profiler__get_heap_object_id_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'heap_profiler.GetHeapObjectIdReturnT':

    if casing_strategy == 'snake':
        return heap_profiler.GetHeapObjectIdReturnT(
            heap_snapshot_object_id=data['heap_snapshot_object_id']
        )

    if casing_strategy == 'camel':
        return heap_profiler.GetHeapObjectIdReturnT(
            heap_snapshot_object_id=data['heapSnapshotObjectId']
        )

    if casing_strategy == 'pascal':
        return heap_profiler.GetHeapObjectIdReturnT(
            heap_snapshot_object_id=data['HeapSnapshotObjectId']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _heap_profiler__get_object_by_heap_object_id_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'heap_profiler.GetObjectByHeapObjectIdReturnT':

    if casing_strategy == 'snake':
        return heap_profiler.GetObjectByHeapObjectIdReturnT(
            result=from_dict(
                heap_profiler.RemoteObject,
                data['result'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return heap_profiler.GetObjectByHeapObjectIdReturnT(
            result=from_dict(
                heap_profiler.RemoteObject,
                data['result'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return heap_profiler.GetObjectByHeapObjectIdReturnT(
            result=from_dict(
                heap_profiler.RemoteObject,
                data['Result'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _heap_profiler__get_sampling_profile_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'heap_profiler.GetSamplingProfileReturnT':

    if casing_strategy == 'snake':
        return heap_profiler.GetSamplingProfileReturnT(
            profile=from_dict(
                heap_profiler.SamplingHeapProfile,
                data['profile'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return heap_profiler.GetSamplingProfileReturnT(
            profile=from_dict(
                heap_profiler.SamplingHeapProfile,
                data['profile'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return heap_profiler.GetSamplingProfileReturnT(
            profile=from_dict(
                heap_profiler.SamplingHeapProfile,
                data['Profile'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _heap_profiler__stop_sampling_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'heap_profiler.StopSamplingReturnT':

    if casing_strategy == 'snake':
        return heap_profiler.StopSamplingReturnT(
            profile=from_dict(
                heap_profiler.SamplingHeapProfile,
                data['profile'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return heap_profiler.StopSamplingReturnT(
            profile=from_dict(
                heap_profiler.SamplingHeapProfile,
                data['profile'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return heap_profiler.StopSamplingReturnT(
            profile=from_dict(
                heap_profiler.SamplingHeapProfile,
                data['Profile'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _profiler__get_best_effort_coverage_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'profiler.GetBestEffortCoverageReturnT':

    if casing_strategy == 'snake':
        return profiler.GetBestEffortCoverageReturnT(
            result=[
                from_dict(profiler.ScriptCoverage, item, casing_strategy)
                for item in data['result']
            ]
        )

    if casing_strategy == 'camel':
        return profiler.GetBestEffortCoverageReturnT(
            result=[
                from_dict(profiler.ScriptCoverage, item, casing_strategy)
                for item in data['result']
            ]
        )

    if casing_strategy == 'pascal':
        return profiler.GetBestEffortCoverageReturnT(
            result=[
                from_dict(profiler.ScriptCoverage, item, casing_strategy)
                for item in data['Result']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _profiler__stop_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'profiler.StopReturnT':

    if casing_strategy == 'snake':
        return profiler.StopReturnT(
            profile=from_dict(
                profiler.Profile,
                data['profile'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return profiler.StopReturnT(
            profile=from_dict(
                profiler.Profile,
                data['profile'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return profiler.StopReturnT(
            profile=from_dict(
                profiler.Profile,
                data['Profile'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _profiler__take_precise_coverage_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'profiler.TakePreciseCoverageReturnT':

    if casing_strategy == 'snake':
        return profiler.TakePreciseCoverageReturnT(
            result=[
                from_dict(profiler.ScriptCoverage, item, casing_strategy)
                for item in data['result']
            ]
        )

    if casing_strategy == 'camel':
        return profiler.TakePreciseCoverageReturnT(
            result=[
                from_dict(profiler.ScriptCoverage, item, casing_strategy)
                for item in data['result']
            ]
        )

    if casing_strategy == 'pascal':
        return profiler.TakePreciseCoverageReturnT(
            result=[
                from_dict(profiler.ScriptCoverage, item, casing_strategy)
                for item in data['Result']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _profiler__take_type_profile_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'profiler.TakeTypeProfileReturnT':

    if casing_strategy == 'snake':
        return profiler.TakeTypeProfileReturnT(
            result=[
                from_dict(profiler.ScriptTypeProfile, item, casing_strategy)
                for item in data['result']
            ]
        )

    if casing_strategy == 'camel':
        return profiler.TakeTypeProfileReturnT(
            result=[
                from_dict(profiler.ScriptTypeProfile, item, casing_strategy)
                for item in data['result']
            ]
        )

    if casing_strategy == 'pascal':
        return profiler.TakeTypeProfileReturnT(
            result=[
                from_dict(profiler.ScriptTypeProfile, item, casing_strategy)
                for item in data['Result']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__await_promise_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.AwaitPromiseReturnT':

    if casing_strategy == 'snake':
        return runtime.AwaitPromiseReturnT(
            result=from_dict(
                runtime.RemoteObject,
                data['result'],
                casing_strategy
            ),
            exception_details=from_dict(
                runtime.ExceptionDetails,
                data.get('exception_details', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return runtime.AwaitPromiseReturnT(
            result=from_dict(
                runtime.RemoteObject,
                data['result'],
                casing_strategy
            ),
            exception_details=from_dict(
                runtime.ExceptionDetails,
                data.get('exceptionDetails', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return runtime.AwaitPromiseReturnT(
            result=from_dict(
                runtime.RemoteObject,
                data['Result'],
                casing_strategy
            ),
            exception_details=from_dict(
                runtime.ExceptionDetails,
                data.get('ExceptionDetails', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__call_function_on_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.CallFunctionOnReturnT':

    if casing_strategy == 'snake':
        return runtime.CallFunctionOnReturnT(
            result=from_dict(
                runtime.RemoteObject,
                data['result'],
                casing_strategy
            ),
            exception_details=from_dict(
                runtime.ExceptionDetails,
                data.get('exception_details', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return runtime.CallFunctionOnReturnT(
            result=from_dict(
                runtime.RemoteObject,
                data['result'],
                casing_strategy
            ),
            exception_details=from_dict(
                runtime.ExceptionDetails,
                data.get('exceptionDetails', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return runtime.CallFunctionOnReturnT(
            result=from_dict(
                runtime.RemoteObject,
                data['Result'],
                casing_strategy
            ),
            exception_details=from_dict(
                runtime.ExceptionDetails,
                data.get('ExceptionDetails', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__compile_script_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.CompileScriptReturnT':

    if casing_strategy == 'snake':
        return runtime.CompileScriptReturnT(
            script_id=data.get('script_id', None),
            exception_details=from_dict(
                runtime.ExceptionDetails,
                data.get('exception_details', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return runtime.CompileScriptReturnT(
            script_id=data.get('scriptId', None),
            exception_details=from_dict(
                runtime.ExceptionDetails,
                data.get('exceptionDetails', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return runtime.CompileScriptReturnT(
            script_id=data.get('ScriptId', None),
            exception_details=from_dict(
                runtime.ExceptionDetails,
                data.get('ExceptionDetails', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__evaluate_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.EvaluateReturnT':

    if casing_strategy == 'snake':
        return runtime.EvaluateReturnT(
            result=from_dict(
                runtime.RemoteObject,
                data['result'],
                casing_strategy
            ),
            exception_details=from_dict(
                runtime.ExceptionDetails,
                data.get('exception_details', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return runtime.EvaluateReturnT(
            result=from_dict(
                runtime.RemoteObject,
                data['result'],
                casing_strategy
            ),
            exception_details=from_dict(
                runtime.ExceptionDetails,
                data.get('exceptionDetails', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return runtime.EvaluateReturnT(
            result=from_dict(
                runtime.RemoteObject,
                data['Result'],
                casing_strategy
            ),
            exception_details=from_dict(
                runtime.ExceptionDetails,
                data.get('ExceptionDetails', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__get_isolate_id_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.GetIsolateIdReturnT':

    if casing_strategy == 'snake':
        return runtime.GetIsolateIdReturnT(
            id=data['id']
        )

    if casing_strategy == 'camel':
        return runtime.GetIsolateIdReturnT(
            id=data['id']
        )

    if casing_strategy == 'pascal':
        return runtime.GetIsolateIdReturnT(
            id=data['Id']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__get_heap_usage_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.GetHeapUsageReturnT':

    if casing_strategy == 'snake':
        return runtime.GetHeapUsageReturnT(
            used_size=data['used_size'],
            total_size=data['total_size']
        )

    if casing_strategy == 'camel':
        return runtime.GetHeapUsageReturnT(
            used_size=data['usedSize'],
            total_size=data['totalSize']
        )

    if casing_strategy == 'pascal':
        return runtime.GetHeapUsageReturnT(
            used_size=data['UsedSize'],
            total_size=data['TotalSize']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__get_properties_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.GetPropertiesReturnT':

    if casing_strategy == 'snake':
        return runtime.GetPropertiesReturnT(
            result=[
                from_dict(runtime.PropertyDescriptor, item, casing_strategy)
                for item in data['result']
            ],
            internal_properties=[
                from_dict(runtime.InternalPropertyDescriptor, item, casing_strategy)
                for item in data.get('internal_properties', [])
            ],
            private_properties=[
                from_dict(runtime.PrivatePropertyDescriptor, item, casing_strategy)
                for item in data.get('private_properties', [])
            ],
            exception_details=from_dict(
                runtime.ExceptionDetails,
                data.get('exception_details', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return runtime.GetPropertiesReturnT(
            result=[
                from_dict(runtime.PropertyDescriptor, item, casing_strategy)
                for item in data['result']
            ],
            internal_properties=[
                from_dict(runtime.InternalPropertyDescriptor, item, casing_strategy)
                for item in data.get('internalProperties', [])
            ],
            private_properties=[
                from_dict(runtime.PrivatePropertyDescriptor, item, casing_strategy)
                for item in data.get('privateProperties', [])
            ],
            exception_details=from_dict(
                runtime.ExceptionDetails,
                data.get('exceptionDetails', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return runtime.GetPropertiesReturnT(
            result=[
                from_dict(runtime.PropertyDescriptor, item, casing_strategy)
                for item in data['Result']
            ],
            internal_properties=[
                from_dict(runtime.InternalPropertyDescriptor, item, casing_strategy)
                for item in data.get('InternalProperties', [])
            ],
            private_properties=[
                from_dict(runtime.PrivatePropertyDescriptor, item, casing_strategy)
                for item in data.get('PrivateProperties', [])
            ],
            exception_details=from_dict(
                runtime.ExceptionDetails,
                data.get('ExceptionDetails', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__global_lexical_scope_names_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.GlobalLexicalScopeNamesReturnT':

    if casing_strategy == 'snake':
        return runtime.GlobalLexicalScopeNamesReturnT(
            names=data['names']
        )

    if casing_strategy == 'camel':
        return runtime.GlobalLexicalScopeNamesReturnT(
            names=data['names']
        )

    if casing_strategy == 'pascal':
        return runtime.GlobalLexicalScopeNamesReturnT(
            names=data['Names']
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__query_objects_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.QueryObjectsReturnT':

    if casing_strategy == 'snake':
        return runtime.QueryObjectsReturnT(
            objects=from_dict(
                runtime.RemoteObject,
                data['objects'],
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return runtime.QueryObjectsReturnT(
            objects=from_dict(
                runtime.RemoteObject,
                data['objects'],
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return runtime.QueryObjectsReturnT(
            objects=from_dict(
                runtime.RemoteObject,
                data['Objects'],
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _runtime__run_script_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'runtime.RunScriptReturnT':

    if casing_strategy == 'snake':
        return runtime.RunScriptReturnT(
            result=from_dict(
                runtime.RemoteObject,
                data['result'],
                casing_strategy
            ),
            exception_details=from_dict(
                runtime.ExceptionDetails,
                data.get('exception_details', None),
                casing_strategy
            )
        )

    if casing_strategy == 'camel':
        return runtime.RunScriptReturnT(
            result=from_dict(
                runtime.RemoteObject,
                data['result'],
                casing_strategy
            ),
            exception_details=from_dict(
                runtime.ExceptionDetails,
                data.get('exceptionDetails', None),
                casing_strategy
            )
        )

    if casing_strategy == 'pascal':
        return runtime.RunScriptReturnT(
            result=from_dict(
                runtime.RemoteObject,
                data['Result'],
                casing_strategy
            ),
            exception_details=from_dict(
                runtime.ExceptionDetails,
                data.get('ExceptionDetails', None),
                casing_strategy
            )
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def _schema__get_domains_return_t__from_dict(
        data: dict,
        casing_strategy: 'CasingStrategyT' = 'snake'
) -> 'schema.GetDomainsReturnT':

    if casing_strategy == 'snake':
        return schema.GetDomainsReturnT(
            domains=[
                from_dict(schema.Domain, item, casing_strategy)
                for item in data['domains']
            ]
        )

    if casing_strategy == 'camel':
        return schema.GetDomainsReturnT(
            domains=[
                from_dict(schema.Domain, item, casing_strategy)
                for item in data['domains']
            ]
        )

    if casing_strategy == 'pascal':
        return schema.GetDomainsReturnT(
            domains=[
                from_dict(schema.Domain, item, casing_strategy)
                for item in data['Domains']
            ]
        )

    raise NotImplementedError(
        'Unknown casing strategy'
    )


def to_dict(
        data,
        casing_strategy: CasingStrategyT
) -> dict:
    lookup = {
        accessibility.AXValueSource: (
            _accessibility__ax_value_source__to_dict
        ),
        accessibility.AXRelatedNode: (
            _accessibility__ax_related_node__to_dict
        ),
        accessibility.AXProperty: (
            _accessibility__ax_property__to_dict
        ),
        accessibility.AXValue: (
            _accessibility__ax_value__to_dict
        ),
        accessibility.AXNode: (
            _accessibility__ax_node__to_dict
        ),
        animation.Animation: (
            _animation__animation__to_dict
        ),
        animation.AnimationEffect: (
            _animation__animation_effect__to_dict
        ),
        animation.KeyframesRule: (
            _animation__keyframes_rule__to_dict
        ),
        animation.KeyframeStyle: (
            _animation__keyframe_style__to_dict
        ),
        audits.AffectedCookie: (
            _audits__affected_cookie__to_dict
        ),
        audits.AffectedRequest: (
            _audits__affected_request__to_dict
        ),
        audits.AffectedFrame: (
            _audits__affected_frame__to_dict
        ),
        audits.CookieIssueDetails: (
            _audits__cookie_issue_details__to_dict
        ),
        audits.MixedContentIssueDetails: (
            _audits__mixed_content_issue_details__to_dict
        ),
        audits.BlockedByResponseIssueDetails: (
            _audits__blocked_by_response_issue_details__to_dict
        ),
        audits.HeavyAdIssueDetails: (
            _audits__heavy_ad_issue_details__to_dict
        ),
        audits.SourceCodeLocation: (
            _audits__source_code_location__to_dict
        ),
        audits.ContentSecurityPolicyIssueDetails: (
            _audits__content_security_policy_issue_details__to_dict
        ),
        audits.SharedArrayBufferIssueDetails: (
            _audits__shared_array_buffer_issue_details__to_dict
        ),
        audits.LowTextContrastIssueDetails: (
            _audits__low_text_contrast_issue_details__to_dict
        ),
        audits.CorsIssueDetails: (
            _audits__cors_issue_details__to_dict
        ),
        audits.AttributionReportingIssueDetails: (
            _audits__attribution_reporting_issue_details__to_dict
        ),
        audits.QuirksModeIssueDetails: (
            _audits__quirks_mode_issue_details__to_dict
        ),
        audits.NavigatorUserAgentIssueDetails: (
            _audits__navigator_user_agent_issue_details__to_dict
        ),
        audits.GenericIssueDetails: (
            _audits__generic_issue_details__to_dict
        ),
        audits.DeprecationIssueDetails: (
            _audits__deprecation_issue_details__to_dict
        ),
        audits.BounceTrackingIssueDetails: (
            _audits__bounce_tracking_issue_details__to_dict
        ),
        audits.FederatedAuthRequestIssueDetails: (
            _audits__federated_auth_request_issue_details__to_dict
        ),
        audits.FederatedAuthUserInfoRequestIssueDetails: (
            _audits__federated_auth_user_info_request_issue_details__to_dict
        ),
        audits.ClientHintIssueDetails: (
            _audits__client_hint_issue_details__to_dict
        ),
        audits.FailedRequestInfo: (
            _audits__failed_request_info__to_dict
        ),
        audits.StylesheetLoadingIssueDetails: (
            _audits__stylesheet_loading_issue_details__to_dict
        ),
        audits.InspectorIssueDetails: (
            _audits__inspector_issue_details__to_dict
        ),
        audits.InspectorIssue: (
            _audits__inspector_issue__to_dict
        ),
        autofill.CreditCard: (
            _autofill__credit_card__to_dict
        ),
        autofill.AddressField: (
            _autofill__address_field__to_dict
        ),
        autofill.AddressFields: (
            _autofill__address_fields__to_dict
        ),
        autofill.Address: (
            _autofill__address__to_dict
        ),
        autofill.AddressUI: (
            _autofill__address_ui__to_dict
        ),
        autofill.FilledField: (
            _autofill__filled_field__to_dict
        ),
        background_service.EventMetadata: (
            _background_service__event_metadata__to_dict
        ),
        background_service.BackgroundServiceEvent: (
            _background_service__background_service_event__to_dict
        ),
        browser.Bounds: (
            _browser__bounds__to_dict
        ),
        browser.PermissionDescriptor: (
            _browser__permission_descriptor__to_dict
        ),
        browser.Bucket: (
            _browser__bucket__to_dict
        ),
        browser.Histogram: (
            _browser__histogram__to_dict
        ),
        css.PseudoElementMatches: (
            _css__pseudo_element_matches__to_dict
        ),
        css.InheritedStyleEntry: (
            _css__inherited_style_entry__to_dict
        ),
        css.InheritedPseudoElementMatches: (
            _css__inherited_pseudo_element_matches__to_dict
        ),
        css.RuleMatch: (
            _css__rule_match__to_dict
        ),
        css.Value: (
            _css__value__to_dict
        ),
        css.Specificity: (
            _css__specificity__to_dict
        ),
        css.SelectorList: (
            _css__selector_list__to_dict
        ),
        css.CSSStyleSheetHeader: (
            _css__css_style_sheet_header__to_dict
        ),
        css.CSSRule: (
            _css__css_rule__to_dict
        ),
        css.RuleUsage: (
            _css__rule_usage__to_dict
        ),
        css.SourceRange: (
            _css__source_range__to_dict
        ),
        css.ShorthandEntry: (
            _css__shorthand_entry__to_dict
        ),
        css.CSSComputedStyleProperty: (
            _css__css_computed_style_property__to_dict
        ),
        css.CSSStyle: (
            _css__css_style__to_dict
        ),
        css.CSSProperty: (
            _css__css_property__to_dict
        ),
        css.CSSMedia: (
            _css__css_media__to_dict
        ),
        css.MediaQuery: (
            _css__media_query__to_dict
        ),
        css.MediaQueryExpression: (
            _css__media_query_expression__to_dict
        ),
        css.CSSContainerQuery: (
            _css__css_container_query__to_dict
        ),
        css.CSSSupports: (
            _css__css_supports__to_dict
        ),
        css.CSSScope: (
            _css__css_scope__to_dict
        ),
        css.CSSLayer: (
            _css__css_layer__to_dict
        ),
        css.CSSLayerData: (
            _css__css_layer_data__to_dict
        ),
        css.PlatformFontUsage: (
            _css__platform_font_usage__to_dict
        ),
        css.FontVariationAxis: (
            _css__font_variation_axis__to_dict
        ),
        css.FontFace: (
            _css__font_face__to_dict
        ),
        css.CSSTryRule: (
            _css__css_try_rule__to_dict
        ),
        css.CSSPositionFallbackRule: (
            _css__css_position_fallback_rule__to_dict
        ),
        css.CSSKeyframesRule: (
            _css__css_keyframes_rule__to_dict
        ),
        css.CSSPropertyRegistration: (
            _css__css_property_registration__to_dict
        ),
        css.CSSPropertyRule: (
            _css__css_property_rule__to_dict
        ),
        css.CSSKeyframeRule: (
            _css__css_keyframe_rule__to_dict
        ),
        css.StyleDeclarationEdit: (
            _css__style_declaration_edit__to_dict
        ),
        cache_storage.DataEntry: (
            _cache_storage__data_entry__to_dict
        ),
        cache_storage.Cache: (
            _cache_storage__cache__to_dict
        ),
        cache_storage.Header: (
            _cache_storage__header__to_dict
        ),
        cache_storage.CachedResponse: (
            _cache_storage__cached_response__to_dict
        ),
        cast.Sink: (
            _cast__sink__to_dict
        ),
        dom.BackendNode: (
            _dom__backend_node__to_dict
        ),
        dom.Node: (
            _dom__node__to_dict
        ),
        dom.RGBA: (
            _dom__rgba__to_dict
        ),
        dom.BoxModel: (
            _dom__box_model__to_dict
        ),
        dom.ShapeOutsideInfo: (
            _dom__shape_outside_info__to_dict
        ),
        dom.Rect: (
            _dom__rect__to_dict
        ),
        dom.CSSComputedStyleProperty: (
            _dom__css_computed_style_property__to_dict
        ),
        dom_debugger.EventListener: (
            _dom_debugger__event_listener__to_dict
        ),
        dom_snapshot.DOMNode: (
            _dom_snapshot__dom_node__to_dict
        ),
        dom_snapshot.InlineTextBox: (
            _dom_snapshot__inline_text_box__to_dict
        ),
        dom_snapshot.LayoutTreeNode: (
            _dom_snapshot__layout_tree_node__to_dict
        ),
        dom_snapshot.ComputedStyle: (
            _dom_snapshot__computed_style__to_dict
        ),
        dom_snapshot.NameValue: (
            _dom_snapshot__name_value__to_dict
        ),
        dom_snapshot.RareStringData: (
            _dom_snapshot__rare_string_data__to_dict
        ),
        dom_snapshot.RareBooleanData: (
            _dom_snapshot__rare_boolean_data__to_dict
        ),
        dom_snapshot.RareIntegerData: (
            _dom_snapshot__rare_integer_data__to_dict
        ),
        dom_snapshot.DocumentSnapshot: (
            _dom_snapshot__document_snapshot__to_dict
        ),
        dom_snapshot.NodeTreeSnapshot: (
            _dom_snapshot__node_tree_snapshot__to_dict
        ),
        dom_snapshot.LayoutTreeSnapshot: (
            _dom_snapshot__layout_tree_snapshot__to_dict
        ),
        dom_snapshot.TextBoxSnapshot: (
            _dom_snapshot__text_box_snapshot__to_dict
        ),
        dom_storage.StorageId: (
            _dom_storage__storage_id__to_dict
        ),
        database.Database: (
            _database__database__to_dict
        ),
        database.Error: (
            _database__error__to_dict
        ),
        emulation.ScreenOrientation: (
            _emulation__screen_orientation__to_dict
        ),
        emulation.DisplayFeature: (
            _emulation__display_feature__to_dict
        ),
        emulation.MediaFeature: (
            _emulation__media_feature__to_dict
        ),
        emulation.UserAgentBrandVersion: (
            _emulation__user_agent_brand_version__to_dict
        ),
        emulation.UserAgentMetadata: (
            _emulation__user_agent_metadata__to_dict
        ),
        headless_experimental.ScreenshotParams: (
            _headless_experimental__screenshot_params__to_dict
        ),
        indexed_db.DatabaseWithObjectStores: (
            _indexed_db__database_with_object_stores__to_dict
        ),
        indexed_db.ObjectStore: (
            _indexed_db__object_store__to_dict
        ),
        indexed_db.ObjectStoreIndex: (
            _indexed_db__object_store_index__to_dict
        ),
        indexed_db.Key: (
            _indexed_db__key__to_dict
        ),
        indexed_db.KeyRange: (
            _indexed_db__key_range__to_dict
        ),
        indexed_db.DataEntry: (
            _indexed_db__data_entry__to_dict
        ),
        indexed_db.KeyPath: (
            _indexed_db__key_path__to_dict
        ),
        input_.TouchPoint: (
            _input__touch_point__to_dict
        ),
        input_.DragDataItem: (
            _input__drag_data_item__to_dict
        ),
        input_.DragData: (
            _input__drag_data__to_dict
        ),
        layer_tree.ScrollRect: (
            _layer_tree__scroll_rect__to_dict
        ),
        layer_tree.StickyPositionConstraint: (
            _layer_tree__sticky_position_constraint__to_dict
        ),
        layer_tree.PictureTile: (
            _layer_tree__picture_tile__to_dict
        ),
        layer_tree.Layer: (
            _layer_tree__layer__to_dict
        ),
        log.LogEntry: (
            _log__log_entry__to_dict
        ),
        log.ViolationSetting: (
            _log__violation_setting__to_dict
        ),
        memory.SamplingProfileNode: (
            _memory__sampling_profile_node__to_dict
        ),
        memory.SamplingProfile: (
            _memory__sampling_profile__to_dict
        ),
        memory.Module: (
            _memory__module__to_dict
        ),
        network.ResourceTiming: (
            _network__resource_timing__to_dict
        ),
        network.PostDataEntry: (
            _network__post_data_entry__to_dict
        ),
        network.Request: (
            _network__request__to_dict
        ),
        network.SignedCertificateTimestamp: (
            _network__signed_certificate_timestamp__to_dict
        ),
        network.SecurityDetails: (
            _network__security_details__to_dict
        ),
        network.CorsErrorStatus: (
            _network__cors_error_status__to_dict
        ),
        network.TrustTokenParams: (
            _network__trust_token_params__to_dict
        ),
        network.Response: (
            _network__response__to_dict
        ),
        network.WebSocketRequest: (
            _network__web_socket_request__to_dict
        ),
        network.WebSocketResponse: (
            _network__web_socket_response__to_dict
        ),
        network.WebSocketFrame: (
            _network__web_socket_frame__to_dict
        ),
        network.CachedResource: (
            _network__cached_resource__to_dict
        ),
        network.Initiator: (
            _network__initiator__to_dict
        ),
        network.Cookie: (
            _network__cookie__to_dict
        ),
        network.BlockedSetCookieWithReason: (
            _network__blocked_set_cookie_with_reason__to_dict
        ),
        network.BlockedCookieWithReason: (
            _network__blocked_cookie_with_reason__to_dict
        ),
        network.CookieParam: (
            _network__cookie_param__to_dict
        ),
        network.AuthChallenge: (
            _network__auth_challenge__to_dict
        ),
        network.AuthChallengeResponse: (
            _network__auth_challenge_response__to_dict
        ),
        network.RequestPattern: (
            _network__request_pattern__to_dict
        ),
        network.SignedExchangeSignature: (
            _network__signed_exchange_signature__to_dict
        ),
        network.SignedExchangeHeader: (
            _network__signed_exchange_header__to_dict
        ),
        network.SignedExchangeError: (
            _network__signed_exchange_error__to_dict
        ),
        network.SignedExchangeInfo: (
            _network__signed_exchange_info__to_dict
        ),
        network.ConnectTiming: (
            _network__connect_timing__to_dict
        ),
        network.ClientSecurityState: (
            _network__client_security_state__to_dict
        ),
        network.CrossOriginOpenerPolicyStatus: (
            _network__cross_origin_opener_policy_status__to_dict
        ),
        network.CrossOriginEmbedderPolicyStatus: (
            _network__cross_origin_embedder_policy_status__to_dict
        ),
        network.ContentSecurityPolicyStatus: (
            _network__content_security_policy_status__to_dict
        ),
        network.SecurityIsolationStatus: (
            _network__security_isolation_status__to_dict
        ),
        network.ReportingApiReport: (
            _network__reporting_api_report__to_dict
        ),
        network.ReportingApiEndpoint: (
            _network__reporting_api_endpoint__to_dict
        ),
        network.LoadNetworkResourcePageResult: (
            _network__load_network_resource_page_result__to_dict
        ),
        network.LoadNetworkResourceOptions: (
            _network__load_network_resource_options__to_dict
        ),
        overlay.SourceOrderConfig: (
            _overlay__source_order_config__to_dict
        ),
        overlay.GridHighlightConfig: (
            _overlay__grid_highlight_config__to_dict
        ),
        overlay.FlexContainerHighlightConfig: (
            _overlay__flex_container_highlight_config__to_dict
        ),
        overlay.FlexItemHighlightConfig: (
            _overlay__flex_item_highlight_config__to_dict
        ),
        overlay.LineStyle: (
            _overlay__line_style__to_dict
        ),
        overlay.BoxStyle: (
            _overlay__box_style__to_dict
        ),
        overlay.HighlightConfig: (
            _overlay__highlight_config__to_dict
        ),
        overlay.GridNodeHighlightConfig: (
            _overlay__grid_node_highlight_config__to_dict
        ),
        overlay.FlexNodeHighlightConfig: (
            _overlay__flex_node_highlight_config__to_dict
        ),
        overlay.ScrollSnapContainerHighlightConfig: (
            _overlay__scroll_snap_container_highlight_config__to_dict
        ),
        overlay.ScrollSnapHighlightConfig: (
            _overlay__scroll_snap_highlight_config__to_dict
        ),
        overlay.HingeConfig: (
            _overlay__hinge_config__to_dict
        ),
        overlay.ContainerQueryHighlightConfig: (
            _overlay__container_query_highlight_config__to_dict
        ),
        overlay.ContainerQueryContainerHighlightConfig: (
            _overlay__container_query_container_highlight_config__to_dict
        ),
        overlay.IsolatedElementHighlightConfig: (
            _overlay__isolated_element_highlight_config__to_dict
        ),
        overlay.IsolationModeHighlightConfig: (
            _overlay__isolation_mode_highlight_config__to_dict
        ),
        page.AdFrameStatus: (
            _page__ad_frame_status__to_dict
        ),
        page.AdScriptId: (
            _page__ad_script_id__to_dict
        ),
        page.PermissionsPolicyBlockLocator: (
            _page__permissions_policy_block_locator__to_dict
        ),
        page.PermissionsPolicyFeatureState: (
            _page__permissions_policy_feature_state__to_dict
        ),
        page.OriginTrialToken: (
            _page__origin_trial_token__to_dict
        ),
        page.OriginTrialTokenWithStatus: (
            _page__origin_trial_token_with_status__to_dict
        ),
        page.OriginTrial: (
            _page__origin_trial__to_dict
        ),
        page.Frame: (
            _page__frame__to_dict
        ),
        page.FrameResource: (
            _page__frame_resource__to_dict
        ),
        page.FrameResourceTree: (
            _page__frame_resource_tree__to_dict
        ),
        page.FrameTree: (
            _page__frame_tree__to_dict
        ),
        page.NavigationEntry: (
            _page__navigation_entry__to_dict
        ),
        page.ScreencastFrameMetadata: (
            _page__screencast_frame_metadata__to_dict
        ),
        page.AppManifestError: (
            _page__app_manifest_error__to_dict
        ),
        page.AppManifestParsedProperties: (
            _page__app_manifest_parsed_properties__to_dict
        ),
        page.LayoutViewport: (
            _page__layout_viewport__to_dict
        ),
        page.VisualViewport: (
            _page__visual_viewport__to_dict
        ),
        page.Viewport: (
            _page__viewport__to_dict
        ),
        page.FontFamilies: (
            _page__font_families__to_dict
        ),
        page.ScriptFontFamilies: (
            _page__script_font_families__to_dict
        ),
        page.FontSizes: (
            _page__font_sizes__to_dict
        ),
        page.InstallabilityErrorArgument: (
            _page__installability_error_argument__to_dict
        ),
        page.InstallabilityError: (
            _page__installability_error__to_dict
        ),
        page.CompilationCacheParams: (
            _page__compilation_cache_params__to_dict
        ),
        page.BackForwardCacheNotRestoredExplanation: (
            _page__back_forward_cache_not_restored_explanation__to_dict
        ),
        page.BackForwardCacheNotRestoredExplanationTree: (
            _page__back_forward_cache_not_restored_explanation_tree__to_dict
        ),
        performance.Metric: (
            _performance__metric__to_dict
        ),
        performance_timeline.LargestContentfulPaint: (
            _performance_timeline__largest_contentful_paint__to_dict
        ),
        performance_timeline.LayoutShiftAttribution: (
            _performance_timeline__layout_shift_attribution__to_dict
        ),
        performance_timeline.LayoutShift: (
            _performance_timeline__layout_shift__to_dict
        ),
        performance_timeline.TimelineEvent: (
            _performance_timeline__timeline_event__to_dict
        ),
        security.CertificateSecurityState: (
            _security__certificate_security_state__to_dict
        ),
        security.SafetyTipInfo: (
            _security__safety_tip_info__to_dict
        ),
        security.VisibleSecurityState: (
            _security__visible_security_state__to_dict
        ),
        security.SecurityStateExplanation: (
            _security__security_state_explanation__to_dict
        ),
        security.InsecureContentStatus: (
            _security__insecure_content_status__to_dict
        ),
        service_worker.ServiceWorkerRegistration: (
            _service_worker__service_worker_registration__to_dict
        ),
        service_worker.ServiceWorkerVersion: (
            _service_worker__service_worker_version__to_dict
        ),
        service_worker.ServiceWorkerErrorMessage: (
            _service_worker__service_worker_error_message__to_dict
        ),
        storage.UsageForType: (
            _storage__usage_for_type__to_dict
        ),
        storage.TrustTokens: (
            _storage__trust_tokens__to_dict
        ),
        storage.InterestGroupAd: (
            _storage__interest_group_ad__to_dict
        ),
        storage.InterestGroupDetails: (
            _storage__interest_group_details__to_dict
        ),
        storage.SharedStorageEntry: (
            _storage__shared_storage_entry__to_dict
        ),
        storage.SharedStorageMetadata: (
            _storage__shared_storage_metadata__to_dict
        ),
        storage.SharedStorageReportingMetadata: (
            _storage__shared_storage_reporting_metadata__to_dict
        ),
        storage.SharedStorageUrlWithMetadata: (
            _storage__shared_storage_url_with_metadata__to_dict
        ),
        storage.SharedStorageAccessParams: (
            _storage__shared_storage_access_params__to_dict
        ),
        storage.StorageBucket: (
            _storage__storage_bucket__to_dict
        ),
        storage.StorageBucketInfo: (
            _storage__storage_bucket_info__to_dict
        ),
        storage.AttributionReportingFilterDataEntry: (
            _storage__attribution_reporting_filter_data_entry__to_dict
        ),
        storage.AttributionReportingAggregationKeysEntry: (
            _storage__attribution_reporting_aggregation_keys_entry__to_dict
        ),
        storage.AttributionReportingEventReportWindows: (
            _storage__attribution_reporting_event_report_windows__to_dict
        ),
        storage.AttributionReportingSourceRegistration: (
            _storage__attribution_reporting_source_registration__to_dict
        ),
        system_info.GPUDevice: (
            _system_info__gpu_device__to_dict
        ),
        system_info.Size: (
            _system_info__size__to_dict
        ),
        system_info.VideoDecodeAcceleratorCapability: (
            _system_info__video_decode_accelerator_capability__to_dict
        ),
        system_info.VideoEncodeAcceleratorCapability: (
            _system_info__video_encode_accelerator_capability__to_dict
        ),
        system_info.ImageDecodeAcceleratorCapability: (
            _system_info__image_decode_accelerator_capability__to_dict
        ),
        system_info.GPUInfo: (
            _system_info__gpu_info__to_dict
        ),
        system_info.ProcessInfo: (
            _system_info__process_info__to_dict
        ),
        target.TargetInfo: (
            _target__target_info__to_dict
        ),
        target.FilterEntry: (
            _target__filter_entry__to_dict
        ),
        target.RemoteLocation: (
            _target__remote_location__to_dict
        ),
        tracing.TraceConfig: (
            _tracing__trace_config__to_dict
        ),
        fetch.RequestPattern: (
            _fetch__request_pattern__to_dict
        ),
        fetch.HeaderEntry: (
            _fetch__header_entry__to_dict
        ),
        fetch.AuthChallenge: (
            _fetch__auth_challenge__to_dict
        ),
        fetch.AuthChallengeResponse: (
            _fetch__auth_challenge_response__to_dict
        ),
        web_audio.ContextRealtimeData: (
            _web_audio__context_realtime_data__to_dict
        ),
        web_audio.BaseAudioContext: (
            _web_audio__base_audio_context__to_dict
        ),
        web_audio.AudioListener: (
            _web_audio__audio_listener__to_dict
        ),
        web_audio.AudioNode: (
            _web_audio__audio_node__to_dict
        ),
        web_audio.AudioParam: (
            _web_audio__audio_param__to_dict
        ),
        web_authn.VirtualAuthenticatorOptions: (
            _web_authn__virtual_authenticator_options__to_dict
        ),
        web_authn.Credential: (
            _web_authn__credential__to_dict
        ),
        media.PlayerMessage: (
            _media__player_message__to_dict
        ),
        media.PlayerProperty: (
            _media__player_property__to_dict
        ),
        media.PlayerEvent: (
            _media__player_event__to_dict
        ),
        media.PlayerErrorSourceLocation: (
            _media__player_error_source_location__to_dict
        ),
        media.PlayerError: (
            _media__player_error__to_dict
        ),
        device_access.PromptDevice: (
            _device_access__prompt_device__to_dict
        ),
        preload.RuleSet: (
            _preload__rule_set__to_dict
        ),
        preload.PreloadingAttemptKey: (
            _preload__preloading_attempt_key__to_dict
        ),
        preload.PreloadingAttemptSource: (
            _preload__preloading_attempt_source__to_dict
        ),
        fed_cm.Account: (
            _fed_cm__account__to_dict
        ),
        console.ConsoleMessage: (
            _console__console_message__to_dict
        ),
        debugger.Location: (
            _debugger__location__to_dict
        ),
        debugger.ScriptPosition: (
            _debugger__script_position__to_dict
        ),
        debugger.CallFrame: (
            _debugger__call_frame__to_dict
        ),
        debugger.Scope: (
            _debugger__scope__to_dict
        ),
        debugger.SearchMatch: (
            _debugger__search_match__to_dict
        ),
        debugger.BreakLocation: (
            _debugger__break_location__to_dict
        ),
        heap_profiler.SamplingHeapProfileNode: (
            _heap_profiler__sampling_heap_profile_node__to_dict
        ),
        heap_profiler.SamplingHeapProfileSample: (
            _heap_profiler__sampling_heap_profile_sample__to_dict
        ),
        heap_profiler.SamplingHeapProfile: (
            _heap_profiler__sampling_heap_profile__to_dict
        ),
        profiler.ProfileNode: (
            _profiler__profile_node__to_dict
        ),
        profiler.Profile: (
            _profiler__profile__to_dict
        ),
        profiler.PositionTickInfo: (
            _profiler__position_tick_info__to_dict
        ),
        profiler.CoverageRange: (
            _profiler__coverage_range__to_dict
        ),
        profiler.FunctionCoverage: (
            _profiler__function_coverage__to_dict
        ),
        profiler.ScriptCoverage: (
            _profiler__script_coverage__to_dict
        ),
        profiler.TypeObject: (
            _profiler__type_object__to_dict
        ),
        profiler.TypeProfileEntry: (
            _profiler__type_profile_entry__to_dict
        ),
        profiler.ScriptTypeProfile: (
            _profiler__script_type_profile__to_dict
        ),
        runtime.RemoteObject: (
            _runtime__remote_object__to_dict
        ),
        runtime.CustomPreview: (
            _runtime__custom_preview__to_dict
        ),
        runtime.ObjectPreview: (
            _runtime__object_preview__to_dict
        ),
        runtime.PropertyPreview: (
            _runtime__property_preview__to_dict
        ),
        runtime.EntryPreview: (
            _runtime__entry_preview__to_dict
        ),
        runtime.PropertyDescriptor: (
            _runtime__property_descriptor__to_dict
        ),
        runtime.InternalPropertyDescriptor: (
            _runtime__internal_property_descriptor__to_dict
        ),
        runtime.PrivatePropertyDescriptor: (
            _runtime__private_property_descriptor__to_dict
        ),
        runtime.CallArgument: (
            _runtime__call_argument__to_dict
        ),
        runtime.ExecutionContextDescription: (
            _runtime__execution_context_description__to_dict
        ),
        runtime.ExceptionDetails: (
            _runtime__exception_details__to_dict
        ),
        runtime.CallFrame: (
            _runtime__call_frame__to_dict
        ),
        runtime.StackTrace: (
            _runtime__stack_trace__to_dict
        ),
        runtime.StackTraceId: (
            _runtime__stack_trace_id__to_dict
        ),
        schema.Domain: (
            _schema__domain__to_dict
        ),
    }
    return lookup[type(data)](
        data,
        casing_strategy
    )


def from_dict(
        dataclass_type: type[_T],
        data: dict,
        casing_strategy: CasingStrategyT
) -> _T:
    lookup = {
        accessibility.GetPartialAXTreeReturnT: (
            _accessibility__get_partial_ax_tree_return_t__from_dict
        ),
        accessibility.GetFullAXTreeReturnT: (
            _accessibility__get_full_ax_tree_return_t__from_dict
        ),
        accessibility.GetRootAXNodeReturnT: (
            _accessibility__get_root_ax_node_return_t__from_dict
        ),
        accessibility.GetAXNodeAndAncestorsReturnT: (
            _accessibility__get_ax_node_and_ancestors_return_t__from_dict
        ),
        accessibility.GetChildAXNodesReturnT: (
            _accessibility__get_child_ax_nodes_return_t__from_dict
        ),
        accessibility.QueryAXTreeReturnT: (
            _accessibility__query_ax_tree_return_t__from_dict
        ),
        accessibility.AXValueSource: (
            _accessibility__ax_value_source__from_dict
        ),
        accessibility.AXRelatedNode: (
            _accessibility__ax_related_node__from_dict
        ),
        accessibility.AXProperty: (
            _accessibility__ax_property__from_dict
        ),
        accessibility.AXValue: (
            _accessibility__ax_value__from_dict
        ),
        accessibility.AXNode: (
            _accessibility__ax_node__from_dict
        ),
        animation.GetCurrentTimeReturnT: (
            _animation__get_current_time_return_t__from_dict
        ),
        animation.GetPlaybackRateReturnT: (
            _animation__get_playback_rate_return_t__from_dict
        ),
        animation.ResolveAnimationReturnT: (
            _animation__resolve_animation_return_t__from_dict
        ),
        animation.Animation: (
            _animation__animation__from_dict
        ),
        animation.AnimationEffect: (
            _animation__animation_effect__from_dict
        ),
        animation.KeyframesRule: (
            _animation__keyframes_rule__from_dict
        ),
        animation.KeyframeStyle: (
            _animation__keyframe_style__from_dict
        ),
        audits.GetEncodedResponseReturnT: (
            _audits__get_encoded_response_return_t__from_dict
        ),
        audits.CheckFormsIssuesReturnT: (
            _audits__check_forms_issues_return_t__from_dict
        ),
        audits.AffectedCookie: (
            _audits__affected_cookie__from_dict
        ),
        audits.AffectedRequest: (
            _audits__affected_request__from_dict
        ),
        audits.AffectedFrame: (
            _audits__affected_frame__from_dict
        ),
        audits.CookieIssueDetails: (
            _audits__cookie_issue_details__from_dict
        ),
        audits.MixedContentIssueDetails: (
            _audits__mixed_content_issue_details__from_dict
        ),
        audits.BlockedByResponseIssueDetails: (
            _audits__blocked_by_response_issue_details__from_dict
        ),
        audits.HeavyAdIssueDetails: (
            _audits__heavy_ad_issue_details__from_dict
        ),
        audits.SourceCodeLocation: (
            _audits__source_code_location__from_dict
        ),
        audits.ContentSecurityPolicyIssueDetails: (
            _audits__content_security_policy_issue_details__from_dict
        ),
        audits.SharedArrayBufferIssueDetails: (
            _audits__shared_array_buffer_issue_details__from_dict
        ),
        audits.LowTextContrastIssueDetails: (
            _audits__low_text_contrast_issue_details__from_dict
        ),
        audits.CorsIssueDetails: (
            _audits__cors_issue_details__from_dict
        ),
        audits.AttributionReportingIssueDetails: (
            _audits__attribution_reporting_issue_details__from_dict
        ),
        audits.QuirksModeIssueDetails: (
            _audits__quirks_mode_issue_details__from_dict
        ),
        audits.NavigatorUserAgentIssueDetails: (
            _audits__navigator_user_agent_issue_details__from_dict
        ),
        audits.GenericIssueDetails: (
            _audits__generic_issue_details__from_dict
        ),
        audits.DeprecationIssueDetails: (
            _audits__deprecation_issue_details__from_dict
        ),
        audits.BounceTrackingIssueDetails: (
            _audits__bounce_tracking_issue_details__from_dict
        ),
        audits.FederatedAuthRequestIssueDetails: (
            _audits__federated_auth_request_issue_details__from_dict
        ),
        audits.FederatedAuthUserInfoRequestIssueDetails: (
            _audits__federated_auth_user_info_request_issue_details__from_dict
        ),
        audits.ClientHintIssueDetails: (
            _audits__client_hint_issue_details__from_dict
        ),
        audits.FailedRequestInfo: (
            _audits__failed_request_info__from_dict
        ),
        audits.StylesheetLoadingIssueDetails: (
            _audits__stylesheet_loading_issue_details__from_dict
        ),
        audits.InspectorIssueDetails: (
            _audits__inspector_issue_details__from_dict
        ),
        audits.InspectorIssue: (
            _audits__inspector_issue__from_dict
        ),
        autofill.CreditCard: (
            _autofill__credit_card__from_dict
        ),
        autofill.AddressField: (
            _autofill__address_field__from_dict
        ),
        autofill.AddressFields: (
            _autofill__address_fields__from_dict
        ),
        autofill.Address: (
            _autofill__address__from_dict
        ),
        autofill.AddressUI: (
            _autofill__address_ui__from_dict
        ),
        autofill.FilledField: (
            _autofill__filled_field__from_dict
        ),
        background_service.EventMetadata: (
            _background_service__event_metadata__from_dict
        ),
        background_service.BackgroundServiceEvent: (
            _background_service__background_service_event__from_dict
        ),
        browser.GetVersionReturnT: (
            _browser__get_version_return_t__from_dict
        ),
        browser.GetBrowserCommandLineReturnT: (
            _browser__get_browser_command_line_return_t__from_dict
        ),
        browser.GetHistogramsReturnT: (
            _browser__get_histograms_return_t__from_dict
        ),
        browser.GetHistogramReturnT: (
            _browser__get_histogram_return_t__from_dict
        ),
        browser.GetWindowBoundsReturnT: (
            _browser__get_window_bounds_return_t__from_dict
        ),
        browser.GetWindowForTargetReturnT: (
            _browser__get_window_for_target_return_t__from_dict
        ),
        browser.Bounds: (
            _browser__bounds__from_dict
        ),
        browser.PermissionDescriptor: (
            _browser__permission_descriptor__from_dict
        ),
        browser.Bucket: (
            _browser__bucket__from_dict
        ),
        browser.Histogram: (
            _browser__histogram__from_dict
        ),
        css.AddRuleReturnT: (
            _css__add_rule_return_t__from_dict
        ),
        css.CollectClassNamesReturnT: (
            _css__collect_class_names_return_t__from_dict
        ),
        css.CreateStyleSheetReturnT: (
            _css__create_style_sheet_return_t__from_dict
        ),
        css.GetBackgroundColorsReturnT: (
            _css__get_background_colors_return_t__from_dict
        ),
        css.GetComputedStyleForNodeReturnT: (
            _css__get_computed_style_for_node_return_t__from_dict
        ),
        css.GetInlineStylesForNodeReturnT: (
            _css__get_inline_styles_for_node_return_t__from_dict
        ),
        css.GetMatchedStylesForNodeReturnT: (
            _css__get_matched_styles_for_node_return_t__from_dict
        ),
        css.GetMediaQueriesReturnT: (
            _css__get_media_queries_return_t__from_dict
        ),
        css.GetPlatformFontsForNodeReturnT: (
            _css__get_platform_fonts_for_node_return_t__from_dict
        ),
        css.GetStyleSheetTextReturnT: (
            _css__get_style_sheet_text_return_t__from_dict
        ),
        css.GetLayersForNodeReturnT: (
            _css__get_layers_for_node_return_t__from_dict
        ),
        css.TakeComputedStyleUpdatesReturnT: (
            _css__take_computed_style_updates_return_t__from_dict
        ),
        css.SetKeyframeKeyReturnT: (
            _css__set_keyframe_key_return_t__from_dict
        ),
        css.SetMediaTextReturnT: (
            _css__set_media_text_return_t__from_dict
        ),
        css.SetContainerQueryTextReturnT: (
            _css__set_container_query_text_return_t__from_dict
        ),
        css.SetSupportsTextReturnT: (
            _css__set_supports_text_return_t__from_dict
        ),
        css.SetScopeTextReturnT: (
            _css__set_scope_text_return_t__from_dict
        ),
        css.SetRuleSelectorReturnT: (
            _css__set_rule_selector_return_t__from_dict
        ),
        css.SetStyleSheetTextReturnT: (
            _css__set_style_sheet_text_return_t__from_dict
        ),
        css.SetStyleTextsReturnT: (
            _css__set_style_texts_return_t__from_dict
        ),
        css.StopRuleUsageTrackingReturnT: (
            _css__stop_rule_usage_tracking_return_t__from_dict
        ),
        css.TakeCoverageDeltaReturnT: (
            _css__take_coverage_delta_return_t__from_dict
        ),
        css.PseudoElementMatches: (
            _css__pseudo_element_matches__from_dict
        ),
        css.InheritedStyleEntry: (
            _css__inherited_style_entry__from_dict
        ),
        css.InheritedPseudoElementMatches: (
            _css__inherited_pseudo_element_matches__from_dict
        ),
        css.RuleMatch: (
            _css__rule_match__from_dict
        ),
        css.Value: (
            _css__value__from_dict
        ),
        css.Specificity: (
            _css__specificity__from_dict
        ),
        css.SelectorList: (
            _css__selector_list__from_dict
        ),
        css.CSSStyleSheetHeader: (
            _css__css_style_sheet_header__from_dict
        ),
        css.CSSRule: (
            _css__css_rule__from_dict
        ),
        css.RuleUsage: (
            _css__rule_usage__from_dict
        ),
        css.SourceRange: (
            _css__source_range__from_dict
        ),
        css.ShorthandEntry: (
            _css__shorthand_entry__from_dict
        ),
        css.CSSComputedStyleProperty: (
            _css__css_computed_style_property__from_dict
        ),
        css.CSSStyle: (
            _css__css_style__from_dict
        ),
        css.CSSProperty: (
            _css__css_property__from_dict
        ),
        css.CSSMedia: (
            _css__css_media__from_dict
        ),
        css.MediaQuery: (
            _css__media_query__from_dict
        ),
        css.MediaQueryExpression: (
            _css__media_query_expression__from_dict
        ),
        css.CSSContainerQuery: (
            _css__css_container_query__from_dict
        ),
        css.CSSSupports: (
            _css__css_supports__from_dict
        ),
        css.CSSScope: (
            _css__css_scope__from_dict
        ),
        css.CSSLayer: (
            _css__css_layer__from_dict
        ),
        css.CSSLayerData: (
            _css__css_layer_data__from_dict
        ),
        css.PlatformFontUsage: (
            _css__platform_font_usage__from_dict
        ),
        css.FontVariationAxis: (
            _css__font_variation_axis__from_dict
        ),
        css.FontFace: (
            _css__font_face__from_dict
        ),
        css.CSSTryRule: (
            _css__css_try_rule__from_dict
        ),
        css.CSSPositionFallbackRule: (
            _css__css_position_fallback_rule__from_dict
        ),
        css.CSSKeyframesRule: (
            _css__css_keyframes_rule__from_dict
        ),
        css.CSSPropertyRegistration: (
            _css__css_property_registration__from_dict
        ),
        css.CSSPropertyRule: (
            _css__css_property_rule__from_dict
        ),
        css.CSSKeyframeRule: (
            _css__css_keyframe_rule__from_dict
        ),
        css.StyleDeclarationEdit: (
            _css__style_declaration_edit__from_dict
        ),
        cache_storage.RequestCacheNamesReturnT: (
            _cache_storage__request_cache_names_return_t__from_dict
        ),
        cache_storage.RequestCachedResponseReturnT: (
            _cache_storage__request_cached_response_return_t__from_dict
        ),
        cache_storage.RequestEntriesReturnT: (
            _cache_storage__request_entries_return_t__from_dict
        ),
        cache_storage.DataEntry: (
            _cache_storage__data_entry__from_dict
        ),
        cache_storage.Cache: (
            _cache_storage__cache__from_dict
        ),
        cache_storage.Header: (
            _cache_storage__header__from_dict
        ),
        cache_storage.CachedResponse: (
            _cache_storage__cached_response__from_dict
        ),
        cast.Sink: (
            _cast__sink__from_dict
        ),
        dom.CollectClassNamesFromSubtreeReturnT: (
            _dom__collect_class_names_from_subtree_return_t__from_dict
        ),
        dom.CopyToReturnT: (
            _dom__copy_to_return_t__from_dict
        ),
        dom.DescribeNodeReturnT: (
            _dom__describe_node_return_t__from_dict
        ),
        dom.GetAttributesReturnT: (
            _dom__get_attributes_return_t__from_dict
        ),
        dom.GetBoxModelReturnT: (
            _dom__get_box_model_return_t__from_dict
        ),
        dom.GetContentQuadsReturnT: (
            _dom__get_content_quads_return_t__from_dict
        ),
        dom.GetDocumentReturnT: (
            _dom__get_document_return_t__from_dict
        ),
        dom.GetFlattenedDocumentReturnT: (
            _dom__get_flattened_document_return_t__from_dict
        ),
        dom.GetNodesForSubtreeByStyleReturnT: (
            _dom__get_nodes_for_subtree_by_style_return_t__from_dict
        ),
        dom.GetNodeForLocationReturnT: (
            _dom__get_node_for_location_return_t__from_dict
        ),
        dom.GetOuterHTMLReturnT: (
            _dom__get_outer_html_return_t__from_dict
        ),
        dom.GetRelayoutBoundaryReturnT: (
            _dom__get_relayout_boundary_return_t__from_dict
        ),
        dom.GetSearchResultsReturnT: (
            _dom__get_search_results_return_t__from_dict
        ),
        dom.MoveToReturnT: (
            _dom__move_to_return_t__from_dict
        ),
        dom.PerformSearchReturnT: (
            _dom__perform_search_return_t__from_dict
        ),
        dom.PushNodeByPathToFrontendReturnT: (
            _dom__push_node_by_path_to_frontend_return_t__from_dict
        ),
        dom.PushNodesByBackendIdsToFrontendReturnT: (
            _dom__push_nodes_by_backend_ids_to_frontend_return_t__from_dict
        ),
        dom.QuerySelectorReturnT: (
            _dom__query_selector_return_t__from_dict
        ),
        dom.QuerySelectorAllReturnT: (
            _dom__query_selector_all_return_t__from_dict
        ),
        dom.GetTopLayerElementsReturnT: (
            _dom__get_top_layer_elements_return_t__from_dict
        ),
        dom.RequestNodeReturnT: (
            _dom__request_node_return_t__from_dict
        ),
        dom.ResolveNodeReturnT: (
            _dom__resolve_node_return_t__from_dict
        ),
        dom.GetNodeStackTracesReturnT: (
            _dom__get_node_stack_traces_return_t__from_dict
        ),
        dom.GetFileInfoReturnT: (
            _dom__get_file_info_return_t__from_dict
        ),
        dom.SetNodeNameReturnT: (
            _dom__set_node_name_return_t__from_dict
        ),
        dom.GetFrameOwnerReturnT: (
            _dom__get_frame_owner_return_t__from_dict
        ),
        dom.GetContainerForNodeReturnT: (
            _dom__get_container_for_node_return_t__from_dict
        ),
        dom.GetQueryingDescendantsForContainerReturnT: (
            _dom__get_querying_descendants_for_container_return_t__from_dict
        ),
        dom.BackendNode: (
            _dom__backend_node__from_dict
        ),
        dom.Node: (
            _dom__node__from_dict
        ),
        dom.RGBA: (
            _dom__rgba__from_dict
        ),
        dom.BoxModel: (
            _dom__box_model__from_dict
        ),
        dom.ShapeOutsideInfo: (
            _dom__shape_outside_info__from_dict
        ),
        dom.Rect: (
            _dom__rect__from_dict
        ),
        dom.CSSComputedStyleProperty: (
            _dom__css_computed_style_property__from_dict
        ),
        dom_debugger.GetEventListenersReturnT: (
            _dom_debugger__get_event_listeners_return_t__from_dict
        ),
        dom_debugger.EventListener: (
            _dom_debugger__event_listener__from_dict
        ),
        dom_snapshot.GetSnapshotReturnT: (
            _dom_snapshot__get_snapshot_return_t__from_dict
        ),
        dom_snapshot.CaptureSnapshotReturnT: (
            _dom_snapshot__capture_snapshot_return_t__from_dict
        ),
        dom_snapshot.DOMNode: (
            _dom_snapshot__dom_node__from_dict
        ),
        dom_snapshot.InlineTextBox: (
            _dom_snapshot__inline_text_box__from_dict
        ),
        dom_snapshot.LayoutTreeNode: (
            _dom_snapshot__layout_tree_node__from_dict
        ),
        dom_snapshot.ComputedStyle: (
            _dom_snapshot__computed_style__from_dict
        ),
        dom_snapshot.NameValue: (
            _dom_snapshot__name_value__from_dict
        ),
        dom_snapshot.RareStringData: (
            _dom_snapshot__rare_string_data__from_dict
        ),
        dom_snapshot.RareBooleanData: (
            _dom_snapshot__rare_boolean_data__from_dict
        ),
        dom_snapshot.RareIntegerData: (
            _dom_snapshot__rare_integer_data__from_dict
        ),
        dom_snapshot.DocumentSnapshot: (
            _dom_snapshot__document_snapshot__from_dict
        ),
        dom_snapshot.NodeTreeSnapshot: (
            _dom_snapshot__node_tree_snapshot__from_dict
        ),
        dom_snapshot.LayoutTreeSnapshot: (
            _dom_snapshot__layout_tree_snapshot__from_dict
        ),
        dom_snapshot.TextBoxSnapshot: (
            _dom_snapshot__text_box_snapshot__from_dict
        ),
        dom_storage.GetDOMStorageItemsReturnT: (
            _dom_storage__get_dom_storage_items_return_t__from_dict
        ),
        dom_storage.StorageId: (
            _dom_storage__storage_id__from_dict
        ),
        database.ExecuteSQLReturnT: (
            _database__execute_sql_return_t__from_dict
        ),
        database.GetDatabaseTableNamesReturnT: (
            _database__get_database_table_names_return_t__from_dict
        ),
        database.Database: (
            _database__database__from_dict
        ),
        database.Error: (
            _database__error__from_dict
        ),
        emulation.CanEmulateReturnT: (
            _emulation__can_emulate_return_t__from_dict
        ),
        emulation.SetVirtualTimePolicyReturnT: (
            _emulation__set_virtual_time_policy_return_t__from_dict
        ),
        emulation.ScreenOrientation: (
            _emulation__screen_orientation__from_dict
        ),
        emulation.DisplayFeature: (
            _emulation__display_feature__from_dict
        ),
        emulation.MediaFeature: (
            _emulation__media_feature__from_dict
        ),
        emulation.UserAgentBrandVersion: (
            _emulation__user_agent_brand_version__from_dict
        ),
        emulation.UserAgentMetadata: (
            _emulation__user_agent_metadata__from_dict
        ),
        headless_experimental.BeginFrameReturnT: (
            _headless_experimental__begin_frame_return_t__from_dict
        ),
        headless_experimental.ScreenshotParams: (
            _headless_experimental__screenshot_params__from_dict
        ),
        io.ReadReturnT: (
            _io__read_return_t__from_dict
        ),
        io.ResolveBlobReturnT: (
            _io__resolve_blob_return_t__from_dict
        ),
        indexed_db.RequestDataReturnT: (
            _indexed_db__request_data_return_t__from_dict
        ),
        indexed_db.GetMetadataReturnT: (
            _indexed_db__get_metadata_return_t__from_dict
        ),
        indexed_db.RequestDatabaseReturnT: (
            _indexed_db__request_database_return_t__from_dict
        ),
        indexed_db.RequestDatabaseNamesReturnT: (
            _indexed_db__request_database_names_return_t__from_dict
        ),
        indexed_db.DatabaseWithObjectStores: (
            _indexed_db__database_with_object_stores__from_dict
        ),
        indexed_db.ObjectStore: (
            _indexed_db__object_store__from_dict
        ),
        indexed_db.ObjectStoreIndex: (
            _indexed_db__object_store_index__from_dict
        ),
        indexed_db.Key: (
            _indexed_db__key__from_dict
        ),
        indexed_db.KeyRange: (
            _indexed_db__key_range__from_dict
        ),
        indexed_db.DataEntry: (
            _indexed_db__data_entry__from_dict
        ),
        indexed_db.KeyPath: (
            _indexed_db__key_path__from_dict
        ),
        input_.TouchPoint: (
            _input__touch_point__from_dict
        ),
        input_.DragDataItem: (
            _input__drag_data_item__from_dict
        ),
        input_.DragData: (
            _input__drag_data__from_dict
        ),
        layer_tree.CompositingReasonsReturnT: (
            _layer_tree__compositing_reasons_return_t__from_dict
        ),
        layer_tree.LoadSnapshotReturnT: (
            _layer_tree__load_snapshot_return_t__from_dict
        ),
        layer_tree.MakeSnapshotReturnT: (
            _layer_tree__make_snapshot_return_t__from_dict
        ),
        layer_tree.ProfileSnapshotReturnT: (
            _layer_tree__profile_snapshot_return_t__from_dict
        ),
        layer_tree.ReplaySnapshotReturnT: (
            _layer_tree__replay_snapshot_return_t__from_dict
        ),
        layer_tree.SnapshotCommandLogReturnT: (
            _layer_tree__snapshot_command_log_return_t__from_dict
        ),
        layer_tree.ScrollRect: (
            _layer_tree__scroll_rect__from_dict
        ),
        layer_tree.StickyPositionConstraint: (
            _layer_tree__sticky_position_constraint__from_dict
        ),
        layer_tree.PictureTile: (
            _layer_tree__picture_tile__from_dict
        ),
        layer_tree.Layer: (
            _layer_tree__layer__from_dict
        ),
        log.LogEntry: (
            _log__log_entry__from_dict
        ),
        log.ViolationSetting: (
            _log__violation_setting__from_dict
        ),
        memory.GetDOMCountersReturnT: (
            _memory__get_dom_counters_return_t__from_dict
        ),
        memory.GetAllTimeSamplingProfileReturnT: (
            _memory__get_all_time_sampling_profile_return_t__from_dict
        ),
        memory.GetBrowserSamplingProfileReturnT: (
            _memory__get_browser_sampling_profile_return_t__from_dict
        ),
        memory.GetSamplingProfileReturnT: (
            _memory__get_sampling_profile_return_t__from_dict
        ),
        memory.SamplingProfileNode: (
            _memory__sampling_profile_node__from_dict
        ),
        memory.SamplingProfile: (
            _memory__sampling_profile__from_dict
        ),
        memory.Module: (
            _memory__module__from_dict
        ),
        network.CanClearBrowserCacheReturnT: (
            _network__can_clear_browser_cache_return_t__from_dict
        ),
        network.CanClearBrowserCookiesReturnT: (
            _network__can_clear_browser_cookies_return_t__from_dict
        ),
        network.CanEmulateNetworkConditionsReturnT: (
            _network__can_emulate_network_conditions_return_t__from_dict
        ),
        network.GetAllCookiesReturnT: (
            _network__get_all_cookies_return_t__from_dict
        ),
        network.GetCertificateReturnT: (
            _network__get_certificate_return_t__from_dict
        ),
        network.GetCookiesReturnT: (
            _network__get_cookies_return_t__from_dict
        ),
        network.GetResponseBodyReturnT: (
            _network__get_response_body_return_t__from_dict
        ),
        network.GetRequestPostDataReturnT: (
            _network__get_request_post_data_return_t__from_dict
        ),
        network.GetResponseBodyForInterceptionReturnT: (
            _network__get_response_body_for_interception_return_t__from_dict
        ),
        network.TakeResponseBodyForInterceptionAsStreamReturnT: (
            _network__take_response_body_for_interception_as_stream_return_t__from_dict
        ),
        network.SearchInResponseBodyReturnT: (
            _network__search_in_response_body_return_t__from_dict
        ),
        network.SetCookieReturnT: (
            _network__set_cookie_return_t__from_dict
        ),
        network.GetSecurityIsolationStatusReturnT: (
            _network__get_security_isolation_status_return_t__from_dict
        ),
        network.LoadNetworkResourceReturnT: (
            _network__load_network_resource_return_t__from_dict
        ),
        network.ResourceTiming: (
            _network__resource_timing__from_dict
        ),
        network.PostDataEntry: (
            _network__post_data_entry__from_dict
        ),
        network.Request: (
            _network__request__from_dict
        ),
        network.SignedCertificateTimestamp: (
            _network__signed_certificate_timestamp__from_dict
        ),
        network.SecurityDetails: (
            _network__security_details__from_dict
        ),
        network.CorsErrorStatus: (
            _network__cors_error_status__from_dict
        ),
        network.TrustTokenParams: (
            _network__trust_token_params__from_dict
        ),
        network.Response: (
            _network__response__from_dict
        ),
        network.WebSocketRequest: (
            _network__web_socket_request__from_dict
        ),
        network.WebSocketResponse: (
            _network__web_socket_response__from_dict
        ),
        network.WebSocketFrame: (
            _network__web_socket_frame__from_dict
        ),
        network.CachedResource: (
            _network__cached_resource__from_dict
        ),
        network.Initiator: (
            _network__initiator__from_dict
        ),
        network.Cookie: (
            _network__cookie__from_dict
        ),
        network.BlockedSetCookieWithReason: (
            _network__blocked_set_cookie_with_reason__from_dict
        ),
        network.BlockedCookieWithReason: (
            _network__blocked_cookie_with_reason__from_dict
        ),
        network.CookieParam: (
            _network__cookie_param__from_dict
        ),
        network.AuthChallenge: (
            _network__auth_challenge__from_dict
        ),
        network.AuthChallengeResponse: (
            _network__auth_challenge_response__from_dict
        ),
        network.RequestPattern: (
            _network__request_pattern__from_dict
        ),
        network.SignedExchangeSignature: (
            _network__signed_exchange_signature__from_dict
        ),
        network.SignedExchangeHeader: (
            _network__signed_exchange_header__from_dict
        ),
        network.SignedExchangeError: (
            _network__signed_exchange_error__from_dict
        ),
        network.SignedExchangeInfo: (
            _network__signed_exchange_info__from_dict
        ),
        network.ConnectTiming: (
            _network__connect_timing__from_dict
        ),
        network.ClientSecurityState: (
            _network__client_security_state__from_dict
        ),
        network.CrossOriginOpenerPolicyStatus: (
            _network__cross_origin_opener_policy_status__from_dict
        ),
        network.CrossOriginEmbedderPolicyStatus: (
            _network__cross_origin_embedder_policy_status__from_dict
        ),
        network.ContentSecurityPolicyStatus: (
            _network__content_security_policy_status__from_dict
        ),
        network.SecurityIsolationStatus: (
            _network__security_isolation_status__from_dict
        ),
        network.ReportingApiReport: (
            _network__reporting_api_report__from_dict
        ),
        network.ReportingApiEndpoint: (
            _network__reporting_api_endpoint__from_dict
        ),
        network.LoadNetworkResourcePageResult: (
            _network__load_network_resource_page_result__from_dict
        ),
        network.LoadNetworkResourceOptions: (
            _network__load_network_resource_options__from_dict
        ),
        overlay.GetHighlightObjectForTestReturnT: (
            _overlay__get_highlight_object_for_test_return_t__from_dict
        ),
        overlay.GetGridHighlightObjectsForTestReturnT: (
            _overlay__get_grid_highlight_objects_for_test_return_t__from_dict
        ),
        overlay.GetSourceOrderHighlightObjectForTestReturnT: (
            _overlay__get_source_order_highlight_object_for_test_return_t__from_dict
        ),
        overlay.SourceOrderConfig: (
            _overlay__source_order_config__from_dict
        ),
        overlay.GridHighlightConfig: (
            _overlay__grid_highlight_config__from_dict
        ),
        overlay.FlexContainerHighlightConfig: (
            _overlay__flex_container_highlight_config__from_dict
        ),
        overlay.FlexItemHighlightConfig: (
            _overlay__flex_item_highlight_config__from_dict
        ),
        overlay.LineStyle: (
            _overlay__line_style__from_dict
        ),
        overlay.BoxStyle: (
            _overlay__box_style__from_dict
        ),
        overlay.HighlightConfig: (
            _overlay__highlight_config__from_dict
        ),
        overlay.GridNodeHighlightConfig: (
            _overlay__grid_node_highlight_config__from_dict
        ),
        overlay.FlexNodeHighlightConfig: (
            _overlay__flex_node_highlight_config__from_dict
        ),
        overlay.ScrollSnapContainerHighlightConfig: (
            _overlay__scroll_snap_container_highlight_config__from_dict
        ),
        overlay.ScrollSnapHighlightConfig: (
            _overlay__scroll_snap_highlight_config__from_dict
        ),
        overlay.HingeConfig: (
            _overlay__hinge_config__from_dict
        ),
        overlay.ContainerQueryHighlightConfig: (
            _overlay__container_query_highlight_config__from_dict
        ),
        overlay.ContainerQueryContainerHighlightConfig: (
            _overlay__container_query_container_highlight_config__from_dict
        ),
        overlay.IsolatedElementHighlightConfig: (
            _overlay__isolated_element_highlight_config__from_dict
        ),
        overlay.IsolationModeHighlightConfig: (
            _overlay__isolation_mode_highlight_config__from_dict
        ),
        page.AddScriptToEvaluateOnLoadReturnT: (
            _page__add_script_to_evaluate_on_load_return_t__from_dict
        ),
        page.AddScriptToEvaluateOnNewDocumentReturnT: (
            _page__add_script_to_evaluate_on_new_document_return_t__from_dict
        ),
        page.CaptureScreenshotReturnT: (
            _page__capture_screenshot_return_t__from_dict
        ),
        page.CaptureSnapshotReturnT: (
            _page__capture_snapshot_return_t__from_dict
        ),
        page.CreateIsolatedWorldReturnT: (
            _page__create_isolated_world_return_t__from_dict
        ),
        page.GetAppManifestReturnT: (
            _page__get_app_manifest_return_t__from_dict
        ),
        page.GetInstallabilityErrorsReturnT: (
            _page__get_installability_errors_return_t__from_dict
        ),
        page.GetManifestIconsReturnT: (
            _page__get_manifest_icons_return_t__from_dict
        ),
        page.GetAppIdReturnT: (
            _page__get_app_id_return_t__from_dict
        ),
        page.GetAdScriptIdReturnT: (
            _page__get_ad_script_id_return_t__from_dict
        ),
        page.GetCookiesReturnT: (
            _page__get_cookies_return_t__from_dict
        ),
        page.GetFrameTreeReturnT: (
            _page__get_frame_tree_return_t__from_dict
        ),
        page.GetLayoutMetricsReturnT: (
            _page__get_layout_metrics_return_t__from_dict
        ),
        page.GetNavigationHistoryReturnT: (
            _page__get_navigation_history_return_t__from_dict
        ),
        page.GetResourceContentReturnT: (
            _page__get_resource_content_return_t__from_dict
        ),
        page.GetResourceTreeReturnT: (
            _page__get_resource_tree_return_t__from_dict
        ),
        page.NavigateReturnT: (
            _page__navigate_return_t__from_dict
        ),
        page.PrintToPDFReturnT: (
            _page__print_to_pdf_return_t__from_dict
        ),
        page.SearchInResourceReturnT: (
            _page__search_in_resource_return_t__from_dict
        ),
        page.GetPermissionsPolicyStateReturnT: (
            _page__get_permissions_policy_state_return_t__from_dict
        ),
        page.GetOriginTrialsReturnT: (
            _page__get_origin_trials_return_t__from_dict
        ),
        page.AdFrameStatus: (
            _page__ad_frame_status__from_dict
        ),
        page.AdScriptId: (
            _page__ad_script_id__from_dict
        ),
        page.PermissionsPolicyBlockLocator: (
            _page__permissions_policy_block_locator__from_dict
        ),
        page.PermissionsPolicyFeatureState: (
            _page__permissions_policy_feature_state__from_dict
        ),
        page.OriginTrialToken: (
            _page__origin_trial_token__from_dict
        ),
        page.OriginTrialTokenWithStatus: (
            _page__origin_trial_token_with_status__from_dict
        ),
        page.OriginTrial: (
            _page__origin_trial__from_dict
        ),
        page.Frame: (
            _page__frame__from_dict
        ),
        page.FrameResource: (
            _page__frame_resource__from_dict
        ),
        page.FrameResourceTree: (
            _page__frame_resource_tree__from_dict
        ),
        page.FrameTree: (
            _page__frame_tree__from_dict
        ),
        page.NavigationEntry: (
            _page__navigation_entry__from_dict
        ),
        page.ScreencastFrameMetadata: (
            _page__screencast_frame_metadata__from_dict
        ),
        page.AppManifestError: (
            _page__app_manifest_error__from_dict
        ),
        page.AppManifestParsedProperties: (
            _page__app_manifest_parsed_properties__from_dict
        ),
        page.LayoutViewport: (
            _page__layout_viewport__from_dict
        ),
        page.VisualViewport: (
            _page__visual_viewport__from_dict
        ),
        page.Viewport: (
            _page__viewport__from_dict
        ),
        page.FontFamilies: (
            _page__font_families__from_dict
        ),
        page.ScriptFontFamilies: (
            _page__script_font_families__from_dict
        ),
        page.FontSizes: (
            _page__font_sizes__from_dict
        ),
        page.InstallabilityErrorArgument: (
            _page__installability_error_argument__from_dict
        ),
        page.InstallabilityError: (
            _page__installability_error__from_dict
        ),
        page.CompilationCacheParams: (
            _page__compilation_cache_params__from_dict
        ),
        page.BackForwardCacheNotRestoredExplanation: (
            _page__back_forward_cache_not_restored_explanation__from_dict
        ),
        page.BackForwardCacheNotRestoredExplanationTree: (
            _page__back_forward_cache_not_restored_explanation_tree__from_dict
        ),
        performance.GetMetricsReturnT: (
            _performance__get_metrics_return_t__from_dict
        ),
        performance.Metric: (
            _performance__metric__from_dict
        ),
        performance_timeline.LargestContentfulPaint: (
            _performance_timeline__largest_contentful_paint__from_dict
        ),
        performance_timeline.LayoutShiftAttribution: (
            _performance_timeline__layout_shift_attribution__from_dict
        ),
        performance_timeline.LayoutShift: (
            _performance_timeline__layout_shift__from_dict
        ),
        performance_timeline.TimelineEvent: (
            _performance_timeline__timeline_event__from_dict
        ),
        security.CertificateSecurityState: (
            _security__certificate_security_state__from_dict
        ),
        security.SafetyTipInfo: (
            _security__safety_tip_info__from_dict
        ),
        security.VisibleSecurityState: (
            _security__visible_security_state__from_dict
        ),
        security.SecurityStateExplanation: (
            _security__security_state_explanation__from_dict
        ),
        security.InsecureContentStatus: (
            _security__insecure_content_status__from_dict
        ),
        service_worker.ServiceWorkerRegistration: (
            _service_worker__service_worker_registration__from_dict
        ),
        service_worker.ServiceWorkerVersion: (
            _service_worker__service_worker_version__from_dict
        ),
        service_worker.ServiceWorkerErrorMessage: (
            _service_worker__service_worker_error_message__from_dict
        ),
        storage.GetStorageKeyForFrameReturnT: (
            _storage__get_storage_key_for_frame_return_t__from_dict
        ),
        storage.GetCookiesReturnT: (
            _storage__get_cookies_return_t__from_dict
        ),
        storage.GetUsageAndQuotaReturnT: (
            _storage__get_usage_and_quota_return_t__from_dict
        ),
        storage.GetTrustTokensReturnT: (
            _storage__get_trust_tokens_return_t__from_dict
        ),
        storage.ClearTrustTokensReturnT: (
            _storage__clear_trust_tokens_return_t__from_dict
        ),
        storage.GetInterestGroupDetailsReturnT: (
            _storage__get_interest_group_details_return_t__from_dict
        ),
        storage.GetSharedStorageMetadataReturnT: (
            _storage__get_shared_storage_metadata_return_t__from_dict
        ),
        storage.GetSharedStorageEntriesReturnT: (
            _storage__get_shared_storage_entries_return_t__from_dict
        ),
        storage.RunBounceTrackingMitigationsReturnT: (
            _storage__run_bounce_tracking_mitigations_return_t__from_dict
        ),
        storage.UsageForType: (
            _storage__usage_for_type__from_dict
        ),
        storage.TrustTokens: (
            _storage__trust_tokens__from_dict
        ),
        storage.InterestGroupAd: (
            _storage__interest_group_ad__from_dict
        ),
        storage.InterestGroupDetails: (
            _storage__interest_group_details__from_dict
        ),
        storage.SharedStorageEntry: (
            _storage__shared_storage_entry__from_dict
        ),
        storage.SharedStorageMetadata: (
            _storage__shared_storage_metadata__from_dict
        ),
        storage.SharedStorageReportingMetadata: (
            _storage__shared_storage_reporting_metadata__from_dict
        ),
        storage.SharedStorageUrlWithMetadata: (
            _storage__shared_storage_url_with_metadata__from_dict
        ),
        storage.SharedStorageAccessParams: (
            _storage__shared_storage_access_params__from_dict
        ),
        storage.StorageBucket: (
            _storage__storage_bucket__from_dict
        ),
        storage.StorageBucketInfo: (
            _storage__storage_bucket_info__from_dict
        ),
        storage.AttributionReportingFilterDataEntry: (
            _storage__attribution_reporting_filter_data_entry__from_dict
        ),
        storage.AttributionReportingAggregationKeysEntry: (
            _storage__attribution_reporting_aggregation_keys_entry__from_dict
        ),
        storage.AttributionReportingEventReportWindows: (
            _storage__attribution_reporting_event_report_windows__from_dict
        ),
        storage.AttributionReportingSourceRegistration: (
            _storage__attribution_reporting_source_registration__from_dict
        ),
        system_info.GetInfoReturnT: (
            _system_info__get_info_return_t__from_dict
        ),
        system_info.GetFeatureStateReturnT: (
            _system_info__get_feature_state_return_t__from_dict
        ),
        system_info.GetProcessInfoReturnT: (
            _system_info__get_process_info_return_t__from_dict
        ),
        system_info.GPUDevice: (
            _system_info__gpu_device__from_dict
        ),
        system_info.Size: (
            _system_info__size__from_dict
        ),
        system_info.VideoDecodeAcceleratorCapability: (
            _system_info__video_decode_accelerator_capability__from_dict
        ),
        system_info.VideoEncodeAcceleratorCapability: (
            _system_info__video_encode_accelerator_capability__from_dict
        ),
        system_info.ImageDecodeAcceleratorCapability: (
            _system_info__image_decode_accelerator_capability__from_dict
        ),
        system_info.GPUInfo: (
            _system_info__gpu_info__from_dict
        ),
        system_info.ProcessInfo: (
            _system_info__process_info__from_dict
        ),
        target.AttachToTargetReturnT: (
            _target__attach_to_target_return_t__from_dict
        ),
        target.AttachToBrowserTargetReturnT: (
            _target__attach_to_browser_target_return_t__from_dict
        ),
        target.CloseTargetReturnT: (
            _target__close_target_return_t__from_dict
        ),
        target.CreateBrowserContextReturnT: (
            _target__create_browser_context_return_t__from_dict
        ),
        target.GetBrowserContextsReturnT: (
            _target__get_browser_contexts_return_t__from_dict
        ),
        target.CreateTargetReturnT: (
            _target__create_target_return_t__from_dict
        ),
        target.GetTargetInfoReturnT: (
            _target__get_target_info_return_t__from_dict
        ),
        target.GetTargetsReturnT: (
            _target__get_targets_return_t__from_dict
        ),
        target.TargetInfo: (
            _target__target_info__from_dict
        ),
        target.FilterEntry: (
            _target__filter_entry__from_dict
        ),
        target.RemoteLocation: (
            _target__remote_location__from_dict
        ),
        tracing.GetCategoriesReturnT: (
            _tracing__get_categories_return_t__from_dict
        ),
        tracing.RequestMemoryDumpReturnT: (
            _tracing__request_memory_dump_return_t__from_dict
        ),
        tracing.TraceConfig: (
            _tracing__trace_config__from_dict
        ),
        fetch.GetResponseBodyReturnT: (
            _fetch__get_response_body_return_t__from_dict
        ),
        fetch.TakeResponseBodyAsStreamReturnT: (
            _fetch__take_response_body_as_stream_return_t__from_dict
        ),
        fetch.RequestPattern: (
            _fetch__request_pattern__from_dict
        ),
        fetch.HeaderEntry: (
            _fetch__header_entry__from_dict
        ),
        fetch.AuthChallenge: (
            _fetch__auth_challenge__from_dict
        ),
        fetch.AuthChallengeResponse: (
            _fetch__auth_challenge_response__from_dict
        ),
        web_audio.GetRealtimeDataReturnT: (
            _web_audio__get_realtime_data_return_t__from_dict
        ),
        web_audio.ContextRealtimeData: (
            _web_audio__context_realtime_data__from_dict
        ),
        web_audio.BaseAudioContext: (
            _web_audio__base_audio_context__from_dict
        ),
        web_audio.AudioListener: (
            _web_audio__audio_listener__from_dict
        ),
        web_audio.AudioNode: (
            _web_audio__audio_node__from_dict
        ),
        web_audio.AudioParam: (
            _web_audio__audio_param__from_dict
        ),
        web_authn.AddVirtualAuthenticatorReturnT: (
            _web_authn__add_virtual_authenticator_return_t__from_dict
        ),
        web_authn.GetCredentialReturnT: (
            _web_authn__get_credential_return_t__from_dict
        ),
        web_authn.GetCredentialsReturnT: (
            _web_authn__get_credentials_return_t__from_dict
        ),
        web_authn.VirtualAuthenticatorOptions: (
            _web_authn__virtual_authenticator_options__from_dict
        ),
        web_authn.Credential: (
            _web_authn__credential__from_dict
        ),
        media.PlayerMessage: (
            _media__player_message__from_dict
        ),
        media.PlayerProperty: (
            _media__player_property__from_dict
        ),
        media.PlayerEvent: (
            _media__player_event__from_dict
        ),
        media.PlayerErrorSourceLocation: (
            _media__player_error_source_location__from_dict
        ),
        media.PlayerError: (
            _media__player_error__from_dict
        ),
        device_access.PromptDevice: (
            _device_access__prompt_device__from_dict
        ),
        preload.RuleSet: (
            _preload__rule_set__from_dict
        ),
        preload.PreloadingAttemptKey: (
            _preload__preloading_attempt_key__from_dict
        ),
        preload.PreloadingAttemptSource: (
            _preload__preloading_attempt_source__from_dict
        ),
        fed_cm.Account: (
            _fed_cm__account__from_dict
        ),
        console.ConsoleMessage: (
            _console__console_message__from_dict
        ),
        debugger.EnableReturnT: (
            _debugger__enable_return_t__from_dict
        ),
        debugger.EvaluateOnCallFrameReturnT: (
            _debugger__evaluate_on_call_frame_return_t__from_dict
        ),
        debugger.GetPossibleBreakpointsReturnT: (
            _debugger__get_possible_breakpoints_return_t__from_dict
        ),
        debugger.GetScriptSourceReturnT: (
            _debugger__get_script_source_return_t__from_dict
        ),
        debugger.GetStackTraceReturnT: (
            _debugger__get_stack_trace_return_t__from_dict
        ),
        debugger.RestartFrameReturnT: (
            _debugger__restart_frame_return_t__from_dict
        ),
        debugger.SearchInContentReturnT: (
            _debugger__search_in_content_return_t__from_dict
        ),
        debugger.SetBreakpointReturnT: (
            _debugger__set_breakpoint_return_t__from_dict
        ),
        debugger.SetInstrumentationBreakpointReturnT: (
            _debugger__set_instrumentation_breakpoint_return_t__from_dict
        ),
        debugger.SetBreakpointByUrlReturnT: (
            _debugger__set_breakpoint_by_url_return_t__from_dict
        ),
        debugger.SetBreakpointOnFunctionCallReturnT: (
            _debugger__set_breakpoint_on_function_call_return_t__from_dict
        ),
        debugger.SetScriptSourceReturnT: (
            _debugger__set_script_source_return_t__from_dict
        ),
        debugger.Location: (
            _debugger__location__from_dict
        ),
        debugger.ScriptPosition: (
            _debugger__script_position__from_dict
        ),
        debugger.CallFrame: (
            _debugger__call_frame__from_dict
        ),
        debugger.Scope: (
            _debugger__scope__from_dict
        ),
        debugger.SearchMatch: (
            _debugger__search_match__from_dict
        ),
        debugger.BreakLocation: (
            _debugger__break_location__from_dict
        ),
        heap_profiler.GetHeapObjectIdReturnT: (
            _heap_profiler__get_heap_object_id_return_t__from_dict
        ),
        heap_profiler.GetObjectByHeapObjectIdReturnT: (
            _heap_profiler__get_object_by_heap_object_id_return_t__from_dict
        ),
        heap_profiler.GetSamplingProfileReturnT: (
            _heap_profiler__get_sampling_profile_return_t__from_dict
        ),
        heap_profiler.StopSamplingReturnT: (
            _heap_profiler__stop_sampling_return_t__from_dict
        ),
        heap_profiler.SamplingHeapProfileNode: (
            _heap_profiler__sampling_heap_profile_node__from_dict
        ),
        heap_profiler.SamplingHeapProfileSample: (
            _heap_profiler__sampling_heap_profile_sample__from_dict
        ),
        heap_profiler.SamplingHeapProfile: (
            _heap_profiler__sampling_heap_profile__from_dict
        ),
        profiler.GetBestEffortCoverageReturnT: (
            _profiler__get_best_effort_coverage_return_t__from_dict
        ),
        profiler.StopReturnT: (
            _profiler__stop_return_t__from_dict
        ),
        profiler.TakePreciseCoverageReturnT: (
            _profiler__take_precise_coverage_return_t__from_dict
        ),
        profiler.TakeTypeProfileReturnT: (
            _profiler__take_type_profile_return_t__from_dict
        ),
        profiler.ProfileNode: (
            _profiler__profile_node__from_dict
        ),
        profiler.Profile: (
            _profiler__profile__from_dict
        ),
        profiler.PositionTickInfo: (
            _profiler__position_tick_info__from_dict
        ),
        profiler.CoverageRange: (
            _profiler__coverage_range__from_dict
        ),
        profiler.FunctionCoverage: (
            _profiler__function_coverage__from_dict
        ),
        profiler.ScriptCoverage: (
            _profiler__script_coverage__from_dict
        ),
        profiler.TypeObject: (
            _profiler__type_object__from_dict
        ),
        profiler.TypeProfileEntry: (
            _profiler__type_profile_entry__from_dict
        ),
        profiler.ScriptTypeProfile: (
            _profiler__script_type_profile__from_dict
        ),
        runtime.AwaitPromiseReturnT: (
            _runtime__await_promise_return_t__from_dict
        ),
        runtime.CallFunctionOnReturnT: (
            _runtime__call_function_on_return_t__from_dict
        ),
        runtime.CompileScriptReturnT: (
            _runtime__compile_script_return_t__from_dict
        ),
        runtime.EvaluateReturnT: (
            _runtime__evaluate_return_t__from_dict
        ),
        runtime.GetIsolateIdReturnT: (
            _runtime__get_isolate_id_return_t__from_dict
        ),
        runtime.GetHeapUsageReturnT: (
            _runtime__get_heap_usage_return_t__from_dict
        ),
        runtime.GetPropertiesReturnT: (
            _runtime__get_properties_return_t__from_dict
        ),
        runtime.GlobalLexicalScopeNamesReturnT: (
            _runtime__global_lexical_scope_names_return_t__from_dict
        ),
        runtime.QueryObjectsReturnT: (
            _runtime__query_objects_return_t__from_dict
        ),
        runtime.RunScriptReturnT: (
            _runtime__run_script_return_t__from_dict
        ),
        runtime.RemoteObject: (
            _runtime__remote_object__from_dict
        ),
        runtime.CustomPreview: (
            _runtime__custom_preview__from_dict
        ),
        runtime.ObjectPreview: (
            _runtime__object_preview__from_dict
        ),
        runtime.PropertyPreview: (
            _runtime__property_preview__from_dict
        ),
        runtime.EntryPreview: (
            _runtime__entry_preview__from_dict
        ),
        runtime.PropertyDescriptor: (
            _runtime__property_descriptor__from_dict
        ),
        runtime.InternalPropertyDescriptor: (
            _runtime__internal_property_descriptor__from_dict
        ),
        runtime.PrivatePropertyDescriptor: (
            _runtime__private_property_descriptor__from_dict
        ),
        runtime.CallArgument: (
            _runtime__call_argument__from_dict
        ),
        runtime.ExecutionContextDescription: (
            _runtime__execution_context_description__from_dict
        ),
        runtime.ExceptionDetails: (
            _runtime__exception_details__from_dict
        ),
        runtime.CallFrame: (
            _runtime__call_frame__from_dict
        ),
        runtime.StackTrace: (
            _runtime__stack_trace__from_dict
        ),
        runtime.StackTraceId: (
            _runtime__stack_trace_id__from_dict
        ),
        schema.GetDomainsReturnT: (
            _schema__get_domains_return_t__from_dict
        ),
        schema.Domain: (
            _schema__domain__from_dict
        ),
    }
    return lookup[dataclass_type](
        data,
        casing_strategy
    )
