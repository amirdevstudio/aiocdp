# DO NOT EDIT THIS FILE
#
# This file is generated by the generator. To make changes, edit the generator
# and run it again.

from dataclasses import (
    dataclass
)
from typing import (
    TYPE_CHECKING
)
from typing import (
    Literal
)
from typing import (
    Any
)
if TYPE_CHECKING:
    from cdp.domains.network.types import (
        TimeSinceEpoch
    )
    from cdp.domains.page.types import (
        FrameId
    )
    from cdp.domains.browser.types import (
        BrowserContextID
    )

SerializedStorageKey = str

UnsignedInt64AsBase10 = str

UnsignedInt128AsBase16 = str

SignedInt64AsBase10 = str

StorageType = Literal[
    'appcache',
    'cookies',
    'file_systems',
    'indexeddb',
    'local_storage',
    'shader_cache',
    'websql',
    'service_workers',
    'cache_storage',
    'interest_groups',
    'shared_storage',
    'storage_buckets',
    'all',
    'other'
]

InterestGroupAccessType = Literal[
    'join',
    'leave',
    'update',
    'loaded',
    'bid',
    'win'
]

SharedStorageAccessType = Literal[
    'documentAddModule',
    'documentSelectURL',
    'documentRun',
    'documentSet',
    'documentAppend',
    'documentDelete',
    'documentClear',
    'workletSet',
    'workletAppend',
    'workletDelete',
    'workletClear',
    'workletGet',
    'workletKeys',
    'workletEntries',
    'workletLength',
    'workletRemainingBudget'
]

StorageBucketsDurability = Literal[
    'relaxed',
    'strict'
]

AttributionReportingSourceType = Literal[
    'navigation',
    'event'
]

AttributionReportingSourceRegistrationResult = Literal[
    'success',
    'internalError',
    'insufficientSourceCapacity',
    'insufficientUniqueDestinationCapacity',
    'excessiveReportingOrigins',
    'prohibitedByBrowserPolicy',
    'successNoised',
    'destinationReportingLimitReached',
    'destinationGlobalLimitReached',
    'destinationBothLimitsReached',
    'reportingOriginsPerSiteLimitReached',
    'exceedsMaxChannelCapacity'
]


@dataclass
class UsageForType:
    storage_type: 'StorageType'
    usage: float
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'storage_type': self.storage_type.to_dict(
                    casing_strategy
                ),
                'usage': self.usage,
            }
        if casing_strategy == 'snake':
            return {
                'storageType': self.storage_type.to_dict(
                    casing_strategy
                ),
                'usage': self.usage,
            }
        if casing_strategy == 'snake':
            return {
                'StorageType': self.storage_type.to_dict(
                    casing_strategy
                ),
                'Usage': self.usage,
            }


@dataclass
class TrustTokens:
    issuer_origin: str
    count: float
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'issuer_origin': self.issuer_origin,
                'count': self.count,
            }
        if casing_strategy == 'snake':
            return {
                'issuerOrigin': self.issuer_origin,
                'count': self.count,
            }
        if casing_strategy == 'snake':
            return {
                'IssuerOrigin': self.issuer_origin,
                'Count': self.count,
            }


@dataclass
class InterestGroupAd:
    render_url: str
    metadata: str
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'render_url': self.render_url,
                'metadata': self.metadata,
            }
        if casing_strategy == 'snake':
            return {
                'renderUrl': self.render_url,
                'metadata': self.metadata,
            }
        if casing_strategy == 'snake':
            return {
                'RenderUrl': self.render_url,
                'Metadata': self.metadata,
            }


@dataclass
class InterestGroupDetails:
    owner_origin: str
    name: str
    expiration_time: 'TimeSinceEpoch'
    joining_origin: str
    bidding_url: str
    bidding_wasm_helper_url: str
    update_url: str
    trusted_bidding_signals_url: str
    trusted_bidding_signals_keys: list
    user_bidding_signals: str
    ads: list
    ad_components: list
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'owner_origin': self.owner_origin,
                'name': self.name,
                'expiration_time': self.expiration_time.to_dict(
                    casing_strategy
                ),
                'joining_origin': self.joining_origin,
                'bidding_url': self.bidding_url,
                'bidding_wasm_helper_url': self.bidding_wasm_helper_url,
                'update_url': self.update_url,
                'trusted_bidding_signals_url': self.trusted_bidding_signals_url,
                'trusted_bidding_signals_keys': self.trusted_bidding_signals_keys,
                'user_bidding_signals': self.user_bidding_signals,
                'ads': _.to_dict(
                    casing_strategy
                )_ads,
                'ad_components': _.to_dict(
                    casing_strategy
                )_ad_components,
            }
        if casing_strategy == 'snake':
            return {
                'ownerOrigin': self.owner_origin,
                'name': self.name,
                'expirationTime': self.expiration_time.to_dict(
                    casing_strategy
                ),
                'joiningOrigin': self.joining_origin,
                'biddingUrl': self.bidding_url,
                'biddingWasmHelperUrl': self.bidding_wasm_helper_url,
                'updateUrl': self.update_url,
                'trustedBiddingSignalsUrl': self.trusted_bidding_signals_url,
                'trustedBiddingSignalsKeys': self.trusted_bidding_signals_keys,
                'userBiddingSignals': self.user_bidding_signals,
                'ads': _.to_dict(
                    casing_strategy
                )_ads,
                'adComponents': _.to_dict(
                    casing_strategy
                )_ad_components,
            }
        if casing_strategy == 'snake':
            return {
                'OwnerOrigin': self.owner_origin,
                'Name': self.name,
                'ExpirationTime': self.expiration_time.to_dict(
                    casing_strategy
                ),
                'JoiningOrigin': self.joining_origin,
                'BiddingUrl': self.bidding_url,
                'BiddingWasmHelperUrl': self.bidding_wasm_helper_url,
                'UpdateUrl': self.update_url,
                'TrustedBiddingSignalsUrl': self.trusted_bidding_signals_url,
                'TrustedBiddingSignalsKeys': self.trusted_bidding_signals_keys,
                'UserBiddingSignals': self.user_bidding_signals,
                'Ads': _.to_dict(
                    casing_strategy
                )_ads,
                'AdComponents': _.to_dict(
                    casing_strategy
                )_ad_components,
            }


@dataclass
class SharedStorageEntry:
    key: str
    value: str
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'key': self.key,
                'value': self.value,
            }
        if casing_strategy == 'snake':
            return {
                'key': self.key,
                'value': self.value,
            }
        if casing_strategy == 'snake':
            return {
                'Key': self.key,
                'Value': self.value,
            }


@dataclass
class SharedStorageMetadata:
    creation_time: 'TimeSinceEpoch'
    length: int
    remaining_budget: float
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'creation_time': self.creation_time.to_dict(
                    casing_strategy
                ),
                'length': self.length,
                'remaining_budget': self.remaining_budget,
            }
        if casing_strategy == 'snake':
            return {
                'creationTime': self.creation_time.to_dict(
                    casing_strategy
                ),
                'length': self.length,
                'remainingBudget': self.remaining_budget,
            }
        if casing_strategy == 'snake':
            return {
                'CreationTime': self.creation_time.to_dict(
                    casing_strategy
                ),
                'Length': self.length,
                'RemainingBudget': self.remaining_budget,
            }


@dataclass
class SharedStorageReportingMetadata:
    event_type: str
    reporting_url: str
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'event_type': self.event_type,
                'reporting_url': self.reporting_url,
            }
        if casing_strategy == 'snake':
            return {
                'eventType': self.event_type,
                'reportingUrl': self.reporting_url,
            }
        if casing_strategy == 'snake':
            return {
                'EventType': self.event_type,
                'ReportingUrl': self.reporting_url,
            }


@dataclass
class SharedStorageUrlWithMetadata:
    url: str
    reporting_metadata: list
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'url': self.url,
                'reporting_metadata': _.to_dict(
                    casing_strategy
                )_reporting_metadata,
            }
        if casing_strategy == 'snake':
            return {
                'url': self.url,
                'reportingMetadata': _.to_dict(
                    casing_strategy
                )_reporting_metadata,
            }
        if casing_strategy == 'snake':
            return {
                'Url': self.url,
                'ReportingMetadata': _.to_dict(
                    casing_strategy
                )_reporting_metadata,
            }


@dataclass
class SharedStorageAccessParams:
    script_source_url: str
    operation_name: str
    serialized_data: str
    urls_with_metadata: list
    key: str
    value: str
    ignore_if_present: bool
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'script_source_url': self.script_source_url,
                'operation_name': self.operation_name,
                'serialized_data': self.serialized_data,
                'urls_with_metadata': _.to_dict(
                    casing_strategy
                )_urls_with_metadata,
                'key': self.key,
                'value': self.value,
                'ignore_if_present': self.ignore_if_present,
            }
        if casing_strategy == 'snake':
            return {
                'scriptSourceUrl': self.script_source_url,
                'operationName': self.operation_name,
                'serializedData': self.serialized_data,
                'urlsWithMetadata': _.to_dict(
                    casing_strategy
                )_urls_with_metadata,
                'key': self.key,
                'value': self.value,
                'ignoreIfPresent': self.ignore_if_present,
            }
        if casing_strategy == 'snake':
            return {
                'ScriptSourceUrl': self.script_source_url,
                'OperationName': self.operation_name,
                'SerializedData': self.serialized_data,
                'UrlsWithMetadata': _.to_dict(
                    casing_strategy
                )_urls_with_metadata,
                'Key': self.key,
                'Value': self.value,
                'IgnoreIfPresent': self.ignore_if_present,
            }


@dataclass
class StorageBucket:
    storage_key: 'SerializedStorageKey'
    name: str
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'storage_key': self.storage_key.to_dict(
                    casing_strategy
                ),
                'name': self.name,
            }
        if casing_strategy == 'snake':
            return {
                'storageKey': self.storage_key.to_dict(
                    casing_strategy
                ),
                'name': self.name,
            }
        if casing_strategy == 'snake':
            return {
                'StorageKey': self.storage_key.to_dict(
                    casing_strategy
                ),
                'Name': self.name,
            }


@dataclass
class StorageBucketInfo:
    bucket: 'StorageBucket'
    id: str
    expiration: 'TimeSinceEpoch'
    quota: float
    persistent: bool
    durability: 'StorageBucketsDurability'
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'bucket': self.bucket.to_dict(
                    casing_strategy
                ),
                'id': self.id_,
                'expiration': self.expiration.to_dict(
                    casing_strategy
                ),
                'quota': self.quota,
                'persistent': self.persistent,
                'durability': self.durability.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'snake':
            return {
                'bucket': self.bucket.to_dict(
                    casing_strategy
                ),
                'id': self.id_,
                'expiration': self.expiration.to_dict(
                    casing_strategy
                ),
                'quota': self.quota,
                'persistent': self.persistent,
                'durability': self.durability.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'snake':
            return {
                'Bucket': self.bucket.to_dict(
                    casing_strategy
                ),
                'Id': self.id_,
                'Expiration': self.expiration.to_dict(
                    casing_strategy
                ),
                'Quota': self.quota,
                'Persistent': self.persistent,
                'Durability': self.durability.to_dict(
                    casing_strategy
                ),
            }


@dataclass
class AttributionReportingFilterDataEntry:
    key: str
    values: list
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'key': self.key,
                'values': self.values,
            }
        if casing_strategy == 'snake':
            return {
                'key': self.key,
                'values': self.values,
            }
        if casing_strategy == 'snake':
            return {
                'Key': self.key,
                'Values': self.values,
            }


@dataclass
class AttributionReportingAggregationKeysEntry:
    key: str
    value: 'UnsignedInt128AsBase16'
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'key': self.key,
                'value': self.value.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'snake':
            return {
                'key': self.key,
                'value': self.value.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'snake':
            return {
                'Key': self.key,
                'Value': self.value.to_dict(
                    casing_strategy
                ),
            }


@dataclass
class AttributionReportingEventReportWindows:
    start: int
    ends: list
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'start': self.start,
                'ends': self.ends,
            }
        if casing_strategy == 'snake':
            return {
                'start': self.start,
                'ends': self.ends,
            }
        if casing_strategy == 'snake':
            return {
                'Start': self.start,
                'Ends': self.ends,
            }


@dataclass
class AttributionReportingSourceRegistration:
    time: 'TimeSinceEpoch'
    expiry: int
    event_report_window: int
    event_report_windows: 'AttributionReportingEventReportWindows'
    aggregatable_report_window: int
    type: 'AttributionReportingSourceType'
    source_origin: str
    reporting_origin: str
    destination_sites: list
    event_id: 'UnsignedInt64AsBase10'
    priority: 'SignedInt64AsBase10'
    filter_data: list
    aggregation_keys: list
    debug_key: 'UnsignedInt64AsBase10'
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'time': self.time.to_dict(
                    casing_strategy
                ),
                'expiry': self.expiry,
                'event_report_window': self.event_report_window,
                'event_report_windows': self.event_report_windows.to_dict(
                    casing_strategy
                ),
                'aggregatable_report_window': self.aggregatable_report_window,
                'type': self.type_.to_dict(
                    casing_strategy
                ),
                'source_origin': self.source_origin,
                'reporting_origin': self.reporting_origin,
                'destination_sites': self.destination_sites,
                'event_id': self.event_id.to_dict(
                    casing_strategy
                ),
                'priority': self.priority.to_dict(
                    casing_strategy
                ),
                'filter_data': _.to_dict(
                    casing_strategy
                )_filter_data,
                'aggregation_keys': _.to_dict(
                    casing_strategy
                )_aggregation_keys,
                'debug_key': self.debug_key.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'snake':
            return {
                'time': self.time.to_dict(
                    casing_strategy
                ),
                'expiry': self.expiry,
                'eventReportWindow': self.event_report_window,
                'eventReportWindows': self.event_report_windows.to_dict(
                    casing_strategy
                ),
                'aggregatableReportWindow': self.aggregatable_report_window,
                'type': self.type_.to_dict(
                    casing_strategy
                ),
                'sourceOrigin': self.source_origin,
                'reportingOrigin': self.reporting_origin,
                'destinationSites': self.destination_sites,
                'eventId': self.event_id.to_dict(
                    casing_strategy
                ),
                'priority': self.priority.to_dict(
                    casing_strategy
                ),
                'filterData': _.to_dict(
                    casing_strategy
                )_filter_data,
                'aggregationKeys': _.to_dict(
                    casing_strategy
                )_aggregation_keys,
                'debugKey': self.debug_key.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'snake':
            return {
                'Time': self.time.to_dict(
                    casing_strategy
                ),
                'Expiry': self.expiry,
                'EventReportWindow': self.event_report_window,
                'EventReportWindows': self.event_report_windows.to_dict(
                    casing_strategy
                ),
                'AggregatableReportWindow': self.aggregatable_report_window,
                'Type': self.type_.to_dict(
                    casing_strategy
                ),
                'SourceOrigin': self.source_origin,
                'ReportingOrigin': self.reporting_origin,
                'DestinationSites': self.destination_sites,
                'EventId': self.event_id.to_dict(
                    casing_strategy
                ),
                'Priority': self.priority.to_dict(
                    casing_strategy
                ),
                'FilterData': _.to_dict(
                    casing_strategy
                )_filter_data,
                'AggregationKeys': _.to_dict(
                    casing_strategy
                )_aggregation_keys,
                'DebugKey': self.debug_key.to_dict(
                    casing_strategy
                ),
            }


@dataclass
class GetStorageKeyForFrameReturnT:
    storage_key: 'SerializedStorageKey'


@dataclass
class GetCookiesReturnT:
    cookies: list


@dataclass
class GetUsageAndQuotaReturnT:
    usage: float
    quota: float
    override_active: bool
    usage_breakdown: list


@dataclass
class GetTrustTokensReturnT:
    tokens: list


@dataclass
class ClearTrustTokensReturnT:
    did_delete_tokens: bool


@dataclass
class GetInterestGroupDetailsReturnT:
    details: 'InterestGroupDetails'


@dataclass
class GetSharedStorageMetadataReturnT:
    metadata: 'SharedStorageMetadata'


@dataclass
class GetSharedStorageEntriesReturnT:
    entries: list


@dataclass
class RunBounceTrackingMitigationsReturnT:
    deleted_sites: list
