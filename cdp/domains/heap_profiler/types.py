# DO NOT EDIT THIS FILE
#
# This file is generated by the generator. To make changes, edit the generator
# and run it again.

from typing import (
    Any,
    Literal,
    TYPE_CHECKING
)
from dataclasses import (
    dataclass
)
if TYPE_CHECKING:
    from cdp.domains.runtime.types import (
        CallFrame,
        RemoteObject,
        RemoteObjectId
    )

HeapSnapshotObjectId = str


@dataclass
class SamplingHeapProfileNode:
    call_frame: 'CallFrame'
    self_size: float
    id: int
    children: list
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'call_frame': self.call_frame.to_dict(casing_strategy),
                'self_size': self.self_size,
                'id': self.id,
                'children': [
                    _.to_dict(casing_strategy)
                    for _ in self.children
                ],
            }        
        if casing_strategy == 'camel':
            return {
                'callFrame': self.call_frame.to_dict(casing_strategy),
                'selfSize': self.self_size,
                'id': self.id,
                'children': [
                    _.to_dict(casing_strategy)
                    for _ in self.children
                ],
            }        
        if casing_strategy == 'pascal':
            return {
                'CallFrame': self.call_frame.to_dict(casing_strategy),
                'SelfSize': self.self_size,
                'Id': self.id,
                'Children': [
                    _.to_dict(casing_strategy)
                    for _ in self.children
                ],
            }


@dataclass
class SamplingHeapProfileSample:
    size: float
    node_id: int
    ordinal: float
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'size': self.size,
                'node_id': self.node_id,
                'ordinal': self.ordinal,
            }        
        if casing_strategy == 'camel':
            return {
                'size': self.size,
                'nodeId': self.node_id,
                'ordinal': self.ordinal,
            }        
        if casing_strategy == 'pascal':
            return {
                'Size': self.size,
                'NodeId': self.node_id,
                'Ordinal': self.ordinal,
            }


@dataclass
class SamplingHeapProfile:
    head: 'SamplingHeapProfileNode'
    samples: list
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'head': self.head.to_dict(casing_strategy),
                'samples': [
                    _.to_dict(casing_strategy)
                    for _ in self.samples
                ],
            }        
        if casing_strategy == 'camel':
            return {
                'head': self.head.to_dict(casing_strategy),
                'samples': [
                    _.to_dict(casing_strategy)
                    for _ in self.samples
                ],
            }        
        if casing_strategy == 'pascal':
            return {
                'Head': self.head.to_dict(casing_strategy),
                'Samples': [
                    _.to_dict(casing_strategy)
                    for _ in self.samples
                ],
            }


@dataclass
class GetHeapObjectIdReturnT:
    heap_snapshot_object_id: 'HeapSnapshotObjectId'


@dataclass
class GetObjectByHeapObjectIdReturnT:
    result: 'RemoteObject'


@dataclass
class GetSamplingProfileReturnT:
    profile: 'SamplingHeapProfile'


@dataclass
class StopSamplingReturnT:
    profile: 'SamplingHeapProfile'
