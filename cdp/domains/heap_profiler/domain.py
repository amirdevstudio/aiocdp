# DO NOT EDIT THIS FILE
#
# This file is generated by the generator. To make changes, edit the generator
# and run it again.

from cdp.domains.base import (
    BaseDomain
)
from dataclasses import (
    dataclass
)
from cdp.utils import (
    is_defined,
    UNDEFINED
)
from typing import (
    TYPE_CHECKING
)
from cdp.domains.mapper import (
    from_dict,
    to_dict
)
from cdp.domains.heap_profiler.types import (
    GetHeapObjectIdReturnT,
    GetObjectByHeapObjectIdReturnT,
    GetSamplingProfileReturnT,
    HeapSnapshotObjectId,
    StopSamplingReturnT
)
from cdp.domains.runtime.types import (
    RemoteObjectId
)
if TYPE_CHECKING:
    from cdp.target.connection import (
        IResponse
    )


@dataclass
class HeapProfiler(BaseDomain):
    def add_inspected_heap_object(
            self,
            heap_object_id: 'HeapSnapshotObjectId'
    ) -> IResponse[None]:
        params = {
            'heapObjectId': heap_object_id,
        }

        return self._send_command(
            'HeapProfiler.addInspectedHeapObject',
            params,
            False
        )

    def collect_garbage(
            self
    ) -> IResponse[None]:
        params = {}

        return self._send_command(
            'HeapProfiler.collectGarbage',
            params,
            False
        )

    def disable(
            self
    ) -> IResponse[None]:
        params = {}

        return self._send_command(
            'HeapProfiler.disable',
            params,
            False
        )

    def enable(
            self
    ) -> IResponse[None]:
        params = {}

        return self._send_command(
            'HeapProfiler.enable',
            params,
            False
        )

    def get_heap_object_id(
            self,
            object_id: 'RemoteObjectId'
    ) -> IResponse[GetHeapObjectIdReturnT]:
        params = {
            'objectId': object_id,
        }

        return self._send_command(
            'HeapProfiler.getHeapObjectId',
            params,
            True,
            lambda data: from_dict(
                GetHeapObjectIdReturnT,
                data,
                'camel'
            )
        )

    def get_object_by_heap_object_id(
            self,
            object_id: 'HeapSnapshotObjectId',
            object_group: 'str' = UNDEFINED
    ) -> IResponse[GetObjectByHeapObjectIdReturnT]:
        params = {
            'objectId': object_id,
        }

        if is_defined(object_group):
            params['objectGroup'] = object_group

        return self._send_command(
            'HeapProfiler.getObjectByHeapObjectId',
            params,
            True,
            lambda data: from_dict(
                GetObjectByHeapObjectIdReturnT,
                data,
                'camel'
            )
        )

    def get_sampling_profile(
            self
    ) -> IResponse[GetSamplingProfileReturnT]:
        params = {}

        return self._send_command(
            'HeapProfiler.getSamplingProfile',
            params,
            True,
            lambda data: from_dict(
                GetSamplingProfileReturnT,
                data,
                'camel'
            )
        )

    def start_sampling(
            self,
            sampling_interval: 'float' = UNDEFINED
    ) -> IResponse[None]:
        params = {}

        if is_defined(sampling_interval):
            params['samplingInterval'] = sampling_interval

        return self._send_command(
            'HeapProfiler.startSampling',
            params,
            False
        )

    def start_tracking_heap_objects(
            self,
            track_allocations: 'bool' = UNDEFINED
    ) -> IResponse[None]:
        params = {}

        if is_defined(track_allocations):
            params['trackAllocations'] = track_allocations

        return self._send_command(
            'HeapProfiler.startTrackingHeapObjects',
            params,
            False
        )

    def stop_sampling(
            self
    ) -> IResponse[StopSamplingReturnT]:
        params = {}

        return self._send_command(
            'HeapProfiler.stopSampling',
            params,
            True,
            lambda data: from_dict(
                StopSamplingReturnT,
                data,
                'camel'
            )
        )

    def stop_tracking_heap_objects(
            self,
            report_progress: 'bool' = UNDEFINED
    ) -> IResponse[None]:
        params = {}

        if is_defined(report_progress):
            params['reportProgress'] = report_progress

        return self._send_command(
            'HeapProfiler.stopTrackingHeapObjects',
            params,
            False
        )

    def take_heap_snapshot(
            self,
            report_progress: 'bool' = UNDEFINED
    ) -> IResponse[None]:
        params = {}

        if is_defined(report_progress):
            params['reportProgress'] = report_progress

        return self._send_command(
            'HeapProfiler.takeHeapSnapshot',
            params,
            False
        )
