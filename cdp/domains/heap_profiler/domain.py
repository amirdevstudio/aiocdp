# DO NOT EDIT THIS FILE
#
# This file is generated by the generator. To make changes, edit the generator
# and run it again.

from cdp.domains.base import (
    BaseDomain
)
from cdp.domains import (
    mappers
)
from cdp.utils import (
    UNDEFINED,
    is_defined
)
from dataclasses import (
    dataclass
)
from typing import (
    TYPE_CHECKING
)
from cdp.domains.heap_profiler.types import (
    GetHeapObjectIdReturnType,
    GetObjectByHeapObjectIdReturnType,
    GetSamplingProfileReturnType,
    HeapSnapshotObjectId,
    RemoteObjectId,
    StopSamplingReturnType
)
if TYPE_CHECKING:
    from cdp.target.connection import (
        IFutureResponse
    )


@dataclass
class HeapProfiler(BaseDomain):
    def add_inspected_heap_object(
            self,
            heap_object_id: 'HeapSnapshotObjectId'
    ) -> 'IFutureResponse[None]':
        params = {
            'heapObjectId': to_dict(
                heap_object_id,
                'camel'
            ),
        }

        return self._send_command(
            'HeapProfiler.addInspectedHeapObject',
            params,
            False
        )

    def collect_garbage(
            self
    ) -> 'IFutureResponse[None]':
        params = {}

        return self._send_command(
            'HeapProfiler.collectGarbage',
            params,
            False
        )

    def disable(
            self
    ) -> 'IFutureResponse[None]':
        params = {}

        return self._send_command(
            'HeapProfiler.disable',
            params,
            False
        )

    def enable(
            self
    ) -> 'IFutureResponse[None]':
        params = {}

        return self._send_command(
            'HeapProfiler.enable',
            params,
            False
        )

    def get_heap_object_id(
            self,
            object_id: 'RemoteObjectId'
    ) -> 'IFutureResponse[GetHeapObjectIdReturnType]':
        params = {
            'objectId': to_dict(
                object_id,
                'camel'
            ),
        }

        return self._send_command(
            'HeapProfiler.getHeapObjectId',
            params,
            True,
            lambda data: from_dict(
                GetHeapObjectIdReturnType,
                data,
                'camel'
            )
        )

    def get_object_by_heap_object_id(
            self,
            object_id: 'HeapSnapshotObjectId',
            object_group: 'str' = UNDEFINED
    ) -> 'IFutureResponse[GetObjectByHeapObjectIdReturnType]':
        params = {
            'objectId': to_dict(
                object_id,
                'camel'
            ),
        }

        if is_defined(object_group):
            params['objectGroup'] = object_group

        return self._send_command(
            'HeapProfiler.getObjectByHeapObjectId',
            params,
            True,
            lambda data: from_dict(
                GetObjectByHeapObjectIdReturnType,
                data,
                'camel'
            )
        )

    def get_sampling_profile(
            self
    ) -> 'IFutureResponse[GetSamplingProfileReturnType]':
        params = {}

        return self._send_command(
            'HeapProfiler.getSamplingProfile',
            params,
            True,
            lambda data: from_dict(
                GetSamplingProfileReturnType,
                data,
                'camel'
            )
        )

    def start_sampling(
            self,
            sampling_interval: 'float' = UNDEFINED
    ) -> 'IFutureResponse[None]':
        params = {}

        if is_defined(sampling_interval):
            params['samplingInterval'] = sampling_interval

        return self._send_command(
            'HeapProfiler.startSampling',
            params,
            False
        )

    def start_tracking_heap_objects(
            self,
            track_allocations: 'bool' = UNDEFINED
    ) -> 'IFutureResponse[None]':
        params = {}

        if is_defined(track_allocations):
            params['trackAllocations'] = track_allocations

        return self._send_command(
            'HeapProfiler.startTrackingHeapObjects',
            params,
            False
        )

    def stop_sampling(
            self
    ) -> 'IFutureResponse[StopSamplingReturnType]':
        params = {}

        return self._send_command(
            'HeapProfiler.stopSampling',
            params,
            True,
            lambda data: from_dict(
                StopSamplingReturnType,
                data,
                'camel'
            )
        )

    def stop_tracking_heap_objects(
            self,
            report_progress: 'bool' = UNDEFINED
    ) -> 'IFutureResponse[None]':
        params = {}

        if is_defined(report_progress):
            params['reportProgress'] = report_progress

        return self._send_command(
            'HeapProfiler.stopTrackingHeapObjects',
            params,
            False
        )

    def take_heap_snapshot(
            self,
            report_progress: 'bool' = UNDEFINED
    ) -> 'IFutureResponse[None]':
        params = {}

        if is_defined(report_progress):
            params['reportProgress'] = report_progress

        return self._send_command(
            'HeapProfiler.takeHeapSnapshot',
            params,
            False
        )
