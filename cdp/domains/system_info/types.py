# DO NOT EDIT THIS FILE
#
# This file is generated by the generator. To make changes, edit the generator
# and run it again.

from typing import (
    Any,
    Literal,
    TYPE_CHECKING
)
from dataclasses import (
    dataclass
)

SubsamplingFormat = Literal[
    'yuv420',
    'yuv422',
    'yuv444'
]

ImageType = Literal[
    'jpeg',
    'webp',
    'unknown'
]


@dataclass
class GPUDevice:
    vendor_id: float
    device_id: float
    sub_sys_id: float
    revision: float
    vendor_string: str
    device_string: str
    driver_vendor: str
    driver_version: str
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'vendor_id': self.vendor_id,
                'device_id': self.device_id,
                'sub_sys_id': self.sub_sys_id,
                'revision': self.revision,
                'vendor_string': self.vendor_string,
                'device_string': self.device_string,
                'driver_vendor': self.driver_vendor,
                'driver_version': self.driver_version,
            }        
        if casing_strategy == 'camel':
            return {
                'vendorId': self.vendor_id,
                'deviceId': self.device_id,
                'subSysId': self.sub_sys_id,
                'revision': self.revision,
                'vendorString': self.vendor_string,
                'deviceString': self.device_string,
                'driverVendor': self.driver_vendor,
                'driverVersion': self.driver_version,
            }        
        if casing_strategy == 'pascal':
            return {
                'VendorId': self.vendor_id,
                'DeviceId': self.device_id,
                'SubSysId': self.sub_sys_id,
                'Revision': self.revision,
                'VendorString': self.vendor_string,
                'DeviceString': self.device_string,
                'DriverVendor': self.driver_vendor,
                'DriverVersion': self.driver_version,
            }


@dataclass
class Size:
    width: int
    height: int
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'width': self.width,
                'height': self.height,
            }        
        if casing_strategy == 'camel':
            return {
                'width': self.width,
                'height': self.height,
            }        
        if casing_strategy == 'pascal':
            return {
                'Width': self.width,
                'Height': self.height,
            }


@dataclass
class VideoDecodeAcceleratorCapability:
    profile: str
    max_resolution: 'Size'
    min_resolution: 'Size'
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'profile': self.profile,
                'max_resolution': self.max_resolution.to_dict(casing_strategy),
                'min_resolution': self.min_resolution.to_dict(casing_strategy),
            }        
        if casing_strategy == 'camel':
            return {
                'profile': self.profile,
                'maxResolution': self.max_resolution.to_dict(casing_strategy),
                'minResolution': self.min_resolution.to_dict(casing_strategy),
            }        
        if casing_strategy == 'pascal':
            return {
                'Profile': self.profile,
                'MaxResolution': self.max_resolution.to_dict(casing_strategy),
                'MinResolution': self.min_resolution.to_dict(casing_strategy),
            }


@dataclass
class VideoEncodeAcceleratorCapability:
    profile: str
    max_resolution: 'Size'
    max_framerate_numerator: int
    max_framerate_denominator: int
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'profile': self.profile,
                'max_resolution': self.max_resolution.to_dict(casing_strategy),
                'max_framerate_numerator': self.max_framerate_numerator,
                'max_framerate_denominator': self.max_framerate_denominator,
            }        
        if casing_strategy == 'camel':
            return {
                'profile': self.profile,
                'maxResolution': self.max_resolution.to_dict(casing_strategy),
                'maxFramerateNumerator': self.max_framerate_numerator,
                'maxFramerateDenominator': self.max_framerate_denominator,
            }        
        if casing_strategy == 'pascal':
            return {
                'Profile': self.profile,
                'MaxResolution': self.max_resolution.to_dict(casing_strategy),
                'MaxFramerateNumerator': self.max_framerate_numerator,
                'MaxFramerateDenominator': self.max_framerate_denominator,
            }


@dataclass
class ImageDecodeAcceleratorCapability:
    image_type: 'ImageType'
    max_dimensions: 'Size'
    min_dimensions: 'Size'
    subsamplings: list
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'image_type': self.image_type,
                'max_dimensions': self.max_dimensions.to_dict(casing_strategy),
                'min_dimensions': self.min_dimensions.to_dict(casing_strategy),
                'subsamplings': [
                    _.to_dict(casing_strategy)
                    for _ in self.subsamplings
                ],
            }        
        if casing_strategy == 'camel':
            return {
                'imageType': self.image_type,
                'maxDimensions': self.max_dimensions.to_dict(casing_strategy),
                'minDimensions': self.min_dimensions.to_dict(casing_strategy),
                'subsamplings': [
                    _.to_dict(casing_strategy)
                    for _ in self.subsamplings
                ],
            }        
        if casing_strategy == 'pascal':
            return {
                'ImageType': self.image_type,
                'MaxDimensions': self.max_dimensions.to_dict(casing_strategy),
                'MinDimensions': self.min_dimensions.to_dict(casing_strategy),
                'Subsamplings': [
                    _.to_dict(casing_strategy)
                    for _ in self.subsamplings
                ],
            }


@dataclass
class GPUInfo:
    devices: list
    aux_attributes: object
    feature_status: object
    driver_bug_workarounds: list
    video_decoding: list
    video_encoding: list
    image_decoding: list
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'devices': [
                    _.to_dict(casing_strategy)
                    for _ in self.devices
                ],
                'aux_attributes': self.aux_attributes,
                'feature_status': self.feature_status,
                'driver_bug_workarounds': self.driver_bug_workarounds,
                'video_decoding': [
                    _.to_dict(casing_strategy)
                    for _ in self.video_decoding
                ],
                'video_encoding': [
                    _.to_dict(casing_strategy)
                    for _ in self.video_encoding
                ],
                'image_decoding': [
                    _.to_dict(casing_strategy)
                    for _ in self.image_decoding
                ],
            }        
        if casing_strategy == 'camel':
            return {
                'devices': [
                    _.to_dict(casing_strategy)
                    for _ in self.devices
                ],
                'auxAttributes': self.aux_attributes,
                'featureStatus': self.feature_status,
                'driverBugWorkarounds': self.driver_bug_workarounds,
                'videoDecoding': [
                    _.to_dict(casing_strategy)
                    for _ in self.video_decoding
                ],
                'videoEncoding': [
                    _.to_dict(casing_strategy)
                    for _ in self.video_encoding
                ],
                'imageDecoding': [
                    _.to_dict(casing_strategy)
                    for _ in self.image_decoding
                ],
            }        
        if casing_strategy == 'pascal':
            return {
                'Devices': [
                    _.to_dict(casing_strategy)
                    for _ in self.devices
                ],
                'AuxAttributes': self.aux_attributes,
                'FeatureStatus': self.feature_status,
                'DriverBugWorkarounds': self.driver_bug_workarounds,
                'VideoDecoding': [
                    _.to_dict(casing_strategy)
                    for _ in self.video_decoding
                ],
                'VideoEncoding': [
                    _.to_dict(casing_strategy)
                    for _ in self.video_encoding
                ],
                'ImageDecoding': [
                    _.to_dict(casing_strategy)
                    for _ in self.image_decoding
                ],
            }


@dataclass
class ProcessInfo:
    type: str
    id: int
    cpu_time: float
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'type': self.type,
                'id': self.id,
                'cpu_time': self.cpu_time,
            }        
        if casing_strategy == 'camel':
            return {
                'type': self.type,
                'id': self.id,
                'cpuTime': self.cpu_time,
            }        
        if casing_strategy == 'pascal':
            return {
                'Type': self.type,
                'Id': self.id,
                'CpuTime': self.cpu_time,
            }


@dataclass
class GetInfoReturnT:
    gpu: 'GPUInfo'
    model_name: str
    model_version: str
    command_line: str


@dataclass
class GetFeatureStateReturnT:
    feature_enabled: bool


@dataclass
class GetProcessInfoReturnT:
    process_info: list
