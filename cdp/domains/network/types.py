# DO NOT EDIT THIS FILE
#
# This file is generated by the generator. To make changes, edit the generator
# and run it again.

from typing import (
    Any,
    Literal,
    TYPE_CHECKING
)
from dataclasses import (
    dataclass
)
if TYPE_CHECKING:
    from cdp.domains.security.types import (
        CertificateId,
        MixedContentType,
        SecurityState
    )
    from cdp.domains.runtime.types import (
        StackTrace
    )
    from cdp.domains.io.types import (
        StreamHandle
    )
    from cdp.domains.emulation.types import (
        UserAgentMetadata
    )
    from cdp.domains.page.types import (
        FrameId
    )

LoaderId = str

RequestId = str

InterceptionId = str

TimeSinceEpoch = float

MonotonicTime = float

Headers = dict

ReportId = str

ResourceType = Literal[
    'Document',
    'Stylesheet',
    'Image',
    'Media',
    'Font',
    'Script',
    'TextTrack',
    'XHR',
    'Fetch',
    'Prefetch',
    'EventSource',
    'WebSocket',
    'Manifest',
    'SignedExchange',
    'Ping',
    'CSPViolationReport',
    'Preflight',
    'Other'
]

ErrorReason = Literal[
    'Failed',
    'Aborted',
    'TimedOut',
    'AccessDenied',
    'ConnectionClosed',
    'ConnectionReset',
    'ConnectionRefused',
    'ConnectionAborted',
    'ConnectionFailed',
    'NameNotResolved',
    'InternetDisconnected',
    'AddressUnreachable',
    'BlockedByClient',
    'BlockedByResponse'
]

ConnectionType = Literal[
    'none',
    'cellular2g',
    'cellular3g',
    'cellular4g',
    'bluetooth',
    'ethernet',
    'wifi',
    'wimax',
    'other'
]

CookieSameSite = Literal[
    'Strict',
    'Lax',
    'None'
]

CookiePriority = Literal[
    'Low',
    'Medium',
    'High'
]

CookieSourceScheme = Literal[
    'Unset',
    'NonSecure',
    'Secure'
]

ResourcePriority = Literal[
    'VeryLow',
    'Low',
    'Medium',
    'High',
    'VeryHigh'
]

CertificateTransparencyCompliance = Literal[
    'unknown',
    'not-compliant',
    'compliant'
]

BlockedReason = Literal[
    'other',
    'csp',
    'mixed-content',
    'origin',
    'inspector',
    'subresource-filter',
    'content-type',
    'coep-frame-resource-needs-coep-header',
    'coop-sandboxed-iframe-cannot-navigate-to-coop-page',
    'corp-not-same-origin',
    'corp-not-same-origin-after-defaulted-to-same-origin-by-coep',
    'corp-not-same-site'
]

CorsError = Literal[
    'DisallowedByMode',
    'InvalidResponse',
    'WildcardOriginNotAllowed',
    'MissingAllowOriginHeader',
    'MultipleAllowOriginValues',
    'InvalidAllowOriginValue',
    'AllowOriginMismatch',
    'InvalidAllowCredentials',
    'CorsDisabledScheme',
    'PreflightInvalidStatus',
    'PreflightDisallowedRedirect',
    'PreflightWildcardOriginNotAllowed',
    'PreflightMissingAllowOriginHeader',
    'PreflightMultipleAllowOriginValues',
    'PreflightInvalidAllowOriginValue',
    'PreflightAllowOriginMismatch',
    'PreflightInvalidAllowCredentials',
    'PreflightMissingAllowExternal',
    'PreflightInvalidAllowExternal',
    'PreflightMissingAllowPrivateNetwork',
    'PreflightInvalidAllowPrivateNetwork',
    'InvalidAllowMethodsPreflightResponse',
    'InvalidAllowHeadersPreflightResponse',
    'MethodDisallowedByPreflightResponse',
    'HeaderDisallowedByPreflightResponse',
    'RedirectContainsCredentials',
    'InsecurePrivateNetwork',
    'InvalidPrivateNetworkAccess',
    'UnexpectedPrivateNetworkAccess',
    'NoCorsRedirectModeNotFollow',
    'PreflightMissingPrivateNetworkAccessId',
    'PreflightMissingPrivateNetworkAccessName',
    'PrivateNetworkAccessPermissionUnavailable',
    'PrivateNetworkAccessPermissionDenied'
]

ServiceWorkerResponseSource = Literal[
    'cache-storage',
    'http-cache',
    'fallback-code',
    'network'
]

TrustTokenOperationType = Literal[
    'Issuance',
    'Redemption',
    'Signing'
]

AlternateProtocolUsage = Literal[
    'alternativeJobWonWithoutRace',
    'alternativeJobWonRace',
    'mainJobWonRace',
    'mappingMissing',
    'broken',
    'dnsAlpnH3JobWonWithoutRace',
    'dnsAlpnH3JobWonRace',
    'unspecifiedReason'
]

SetCookieBlockedReason = Literal[
    'SecureOnly',
    'SameSiteStrict',
    'SameSiteLax',
    'SameSiteUnspecifiedTreatedAsLax',
    'SameSiteNoneInsecure',
    'UserPreferences',
    'ThirdPartyBlockedInFirstPartySet',
    'SyntaxError',
    'SchemeNotSupported',
    'OverwriteSecure',
    'InvalidDomain',
    'InvalidPrefix',
    'UnknownError',
    'SchemefulSameSiteStrict',
    'SchemefulSameSiteLax',
    'SchemefulSameSiteUnspecifiedTreatedAsLax',
    'SamePartyFromCrossPartyContext',
    'SamePartyConflictsWithOtherAttributes',
    'NameValuePairExceedsMaxSize',
    'DisallowedCharacter'
]

CookieBlockedReason = Literal[
    'SecureOnly',
    'NotOnPath',
    'DomainMismatch',
    'SameSiteStrict',
    'SameSiteLax',
    'SameSiteUnspecifiedTreatedAsLax',
    'SameSiteNoneInsecure',
    'UserPreferences',
    'ThirdPartyBlockedInFirstPartySet',
    'UnknownError',
    'SchemefulSameSiteStrict',
    'SchemefulSameSiteLax',
    'SchemefulSameSiteUnspecifiedTreatedAsLax',
    'SamePartyFromCrossPartyContext',
    'NameValuePairExceedsMaxSize'
]

InterceptionStage = Literal[
    'Request',
    'HeadersReceived'
]

SignedExchangeErrorField = Literal[
    'signatureSig',
    'signatureIntegrity',
    'signatureCertUrl',
    'signatureCertSha256',
    'signatureValidityUrl',
    'signatureTimestamps'
]

ContentEncoding = Literal[
    'deflate',
    'gzip',
    'br',
    'zstd'
]

PrivateNetworkRequestPolicy = Literal[
    'Allow',
    'BlockFromInsecureToMorePrivate',
    'WarnFromInsecureToMorePrivate',
    'PreflightBlock',
    'PreflightWarn'
]

IPAddressSpace = Literal[
    'Local',
    'Private',
    'Public',
    'Unknown'
]

CrossOriginOpenerPolicyValue = Literal[
    'SameOrigin',
    'SameOriginAllowPopups',
    'RestrictProperties',
    'UnsafeNone',
    'SameOriginPlusCoep',
    'RestrictPropertiesPlusCoep'
]

CrossOriginEmbedderPolicyValue = Literal[
    'None',
    'Credentialless',
    'RequireCorp'
]

ContentSecurityPolicySource = Literal[
    'HTTP',
    'Meta'
]

ReportStatus = Literal[
    'Queued',
    'Pending',
    'MarkedForRemoval',
    'Success'
]


@dataclass
class ResourceTiming:
    request_time: float
    proxy_start: float
    proxy_end: float
    dns_start: float
    dns_end: float
    connect_start: float
    connect_end: float
    ssl_start: float
    ssl_end: float
    worker_start: float
    worker_ready: float
    worker_fetch_start: float
    worker_respond_with_settled: float
    send_start: float
    send_end: float
    push_start: float
    push_end: float
    receive_headers_start: float
    receive_headers_end: float
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'request_time': self.request_time,
                'proxy_start': self.proxy_start,
                'proxy_end': self.proxy_end,
                'dns_start': self.dns_start,
                'dns_end': self.dns_end,
                'connect_start': self.connect_start,
                'connect_end': self.connect_end,
                'ssl_start': self.ssl_start,
                'ssl_end': self.ssl_end,
                'worker_start': self.worker_start,
                'worker_ready': self.worker_ready,
                'worker_fetch_start': self.worker_fetch_start,
                'worker_respond_with_settled': self.worker_respond_with_settled,
                'send_start': self.send_start,
                'send_end': self.send_end,
                'push_start': self.push_start,
                'push_end': self.push_end,
                'receive_headers_start': self.receive_headers_start,
                'receive_headers_end': self.receive_headers_end,
            }        
        if casing_strategy == 'camel':
            return {
                'requestTime': self.request_time,
                'proxyStart': self.proxy_start,
                'proxyEnd': self.proxy_end,
                'dnsStart': self.dns_start,
                'dnsEnd': self.dns_end,
                'connectStart': self.connect_start,
                'connectEnd': self.connect_end,
                'sslStart': self.ssl_start,
                'sslEnd': self.ssl_end,
                'workerStart': self.worker_start,
                'workerReady': self.worker_ready,
                'workerFetchStart': self.worker_fetch_start,
                'workerRespondWithSettled': self.worker_respond_with_settled,
                'sendStart': self.send_start,
                'sendEnd': self.send_end,
                'pushStart': self.push_start,
                'pushEnd': self.push_end,
                'receiveHeadersStart': self.receive_headers_start,
                'receiveHeadersEnd': self.receive_headers_end,
            }        
        if casing_strategy == 'pascal':
            return {
                'RequestTime': self.request_time,
                'ProxyStart': self.proxy_start,
                'ProxyEnd': self.proxy_end,
                'DnsStart': self.dns_start,
                'DnsEnd': self.dns_end,
                'ConnectStart': self.connect_start,
                'ConnectEnd': self.connect_end,
                'SslStart': self.ssl_start,
                'SslEnd': self.ssl_end,
                'WorkerStart': self.worker_start,
                'WorkerReady': self.worker_ready,
                'WorkerFetchStart': self.worker_fetch_start,
                'WorkerRespondWithSettled': self.worker_respond_with_settled,
                'SendStart': self.send_start,
                'SendEnd': self.send_end,
                'PushStart': self.push_start,
                'PushEnd': self.push_end,
                'ReceiveHeadersStart': self.receive_headers_start,
                'ReceiveHeadersEnd': self.receive_headers_end,
            }


@dataclass
class PostDataEntry:
    bytes: str
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'bytes': self.bytes,
            }        
        if casing_strategy == 'camel':
            return {
                'bytes': self.bytes,
            }        
        if casing_strategy == 'pascal':
            return {
                'Bytes': self.bytes,
            }


@dataclass
class Request:
    url: str
    url_fragment: str
    method: str
    headers: 'Headers'
    post_data: str
    has_post_data: bool
    post_data_entries: list
    mixed_content_type: 'MixedContentType'
    initial_priority: 'ResourcePriority'
    referrer_policy: str
    is_link_preload: bool
    trust_token_params: 'TrustTokenParams'
    is_same_site: bool
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'url': self.url,
                'url_fragment': self.url_fragment,
                'method': self.method,
                'headers': self.headers,
                'post_data': self.post_data,
                'has_post_data': self.has_post_data,
                'post_data_entries': [
                    _.to_dict(casing_strategy)
                    for _ in self.post_data_entries
                ],
                'mixed_content_type': self.mixed_content_type,
                'initial_priority': self.initial_priority,
                'referrer_policy': self.referrer_policy,
                'is_link_preload': self.is_link_preload,
                'trust_token_params': self.trust_token_params.to_dict(casing_strategy),
                'is_same_site': self.is_same_site,
            }        
        if casing_strategy == 'camel':
            return {
                'url': self.url,
                'urlFragment': self.url_fragment,
                'method': self.method,
                'headers': self.headers,
                'postData': self.post_data,
                'hasPostData': self.has_post_data,
                'postDataEntries': [
                    _.to_dict(casing_strategy)
                    for _ in self.post_data_entries
                ],
                'mixedContentType': self.mixed_content_type,
                'initialPriority': self.initial_priority,
                'referrerPolicy': self.referrer_policy,
                'isLinkPreload': self.is_link_preload,
                'trustTokenParams': self.trust_token_params.to_dict(casing_strategy),
                'isSameSite': self.is_same_site,
            }        
        if casing_strategy == 'pascal':
            return {
                'Url': self.url,
                'UrlFragment': self.url_fragment,
                'Method': self.method,
                'Headers': self.headers,
                'PostData': self.post_data,
                'HasPostData': self.has_post_data,
                'PostDataEntries': [
                    _.to_dict(casing_strategy)
                    for _ in self.post_data_entries
                ],
                'MixedContentType': self.mixed_content_type,
                'InitialPriority': self.initial_priority,
                'ReferrerPolicy': self.referrer_policy,
                'IsLinkPreload': self.is_link_preload,
                'TrustTokenParams': self.trust_token_params.to_dict(casing_strategy),
                'IsSameSite': self.is_same_site,
            }


@dataclass
class SignedCertificateTimestamp:
    status: str
    origin: str
    log_description: str
    log_id: str
    timestamp: float
    hash_algorithm: str
    signature_algorithm: str
    signature_data: str
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'status': self.status,
                'origin': self.origin,
                'log_description': self.log_description,
                'log_id': self.log_id,
                'timestamp': self.timestamp,
                'hash_algorithm': self.hash_algorithm,
                'signature_algorithm': self.signature_algorithm,
                'signature_data': self.signature_data,
            }        
        if casing_strategy == 'camel':
            return {
                'status': self.status,
                'origin': self.origin,
                'logDescription': self.log_description,
                'logId': self.log_id,
                'timestamp': self.timestamp,
                'hashAlgorithm': self.hash_algorithm,
                'signatureAlgorithm': self.signature_algorithm,
                'signatureData': self.signature_data,
            }        
        if casing_strategy == 'pascal':
            return {
                'Status': self.status,
                'Origin': self.origin,
                'LogDescription': self.log_description,
                'LogId': self.log_id,
                'Timestamp': self.timestamp,
                'HashAlgorithm': self.hash_algorithm,
                'SignatureAlgorithm': self.signature_algorithm,
                'SignatureData': self.signature_data,
            }


@dataclass
class SecurityDetails:
    protocol: str
    key_exchange: str
    key_exchange_group: str
    cipher: str
    mac: str
    certificate_id: 'CertificateId'
    subject_name: str
    san_list: list
    issuer: str
    valid_from: 'TimeSinceEpoch'
    valid_to: 'TimeSinceEpoch'
    signed_certificate_timestamp_list: list
    certificate_transparency_compliance: 'CertificateTransparencyCompliance'
    server_signature_algorithm: int
    encrypted_client_hello: bool
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'protocol': self.protocol,
                'key_exchange': self.key_exchange,
                'key_exchange_group': self.key_exchange_group,
                'cipher': self.cipher,
                'mac': self.mac,
                'certificate_id': self.certificate_id,
                'subject_name': self.subject_name,
                'san_list': self.san_list,
                'issuer': self.issuer,
                'valid_from': self.valid_from,
                'valid_to': self.valid_to,
                'signed_certificate_timestamp_list': [
                    _.to_dict(casing_strategy)
                    for _ in self.signed_certificate_timestamp_list
                ],
                'certificate_transparency_compliance': self.certificate_transparency_compliance,
                'server_signature_algorithm': self.server_signature_algorithm,
                'encrypted_client_hello': self.encrypted_client_hello,
            }        
        if casing_strategy == 'camel':
            return {
                'protocol': self.protocol,
                'keyExchange': self.key_exchange,
                'keyExchangeGroup': self.key_exchange_group,
                'cipher': self.cipher,
                'mac': self.mac,
                'certificateId': self.certificate_id,
                'subjectName': self.subject_name,
                'sanList': self.san_list,
                'issuer': self.issuer,
                'validFrom': self.valid_from,
                'validTo': self.valid_to,
                'signedCertificateTimestampList': [
                    _.to_dict(casing_strategy)
                    for _ in self.signed_certificate_timestamp_list
                ],
                'certificateTransparencyCompliance': self.certificate_transparency_compliance,
                'serverSignatureAlgorithm': self.server_signature_algorithm,
                'encryptedClientHello': self.encrypted_client_hello,
            }        
        if casing_strategy == 'pascal':
            return {
                'Protocol': self.protocol,
                'KeyExchange': self.key_exchange,
                'KeyExchangeGroup': self.key_exchange_group,
                'Cipher': self.cipher,
                'Mac': self.mac,
                'CertificateId': self.certificate_id,
                'SubjectName': self.subject_name,
                'SanList': self.san_list,
                'Issuer': self.issuer,
                'ValidFrom': self.valid_from,
                'ValidTo': self.valid_to,
                'SignedCertificateTimestampList': [
                    _.to_dict(casing_strategy)
                    for _ in self.signed_certificate_timestamp_list
                ],
                'CertificateTransparencyCompliance': self.certificate_transparency_compliance,
                'ServerSignatureAlgorithm': self.server_signature_algorithm,
                'EncryptedClientHello': self.encrypted_client_hello,
            }


@dataclass
class CorsErrorStatus:
    cors_error: 'CorsError'
    failed_parameter: str
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'cors_error': self.cors_error,
                'failed_parameter': self.failed_parameter,
            }        
        if casing_strategy == 'camel':
            return {
                'corsError': self.cors_error,
                'failedParameter': self.failed_parameter,
            }        
        if casing_strategy == 'pascal':
            return {
                'CorsError': self.cors_error,
                'FailedParameter': self.failed_parameter,
            }


@dataclass
class TrustTokenParams:
    operation: 'TrustTokenOperationType'
    refresh_policy: str
    issuers: list
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'operation': self.operation,
                'refresh_policy': self.refresh_policy,
                'issuers': self.issuers,
            }        
        if casing_strategy == 'camel':
            return {
                'operation': self.operation,
                'refreshPolicy': self.refresh_policy,
                'issuers': self.issuers,
            }        
        if casing_strategy == 'pascal':
            return {
                'Operation': self.operation,
                'RefreshPolicy': self.refresh_policy,
                'Issuers': self.issuers,
            }


@dataclass
class Response:
    url: str
    status: int
    status_text: str
    headers: 'Headers'
    headers_text: str
    mime_type: str
    request_headers: 'Headers'
    request_headers_text: str
    connection_reused: bool
    connection_id: float
    remote_ip_address: str
    remote_port: int
    from_disk_cache: bool
    from_service_worker: bool
    from_prefetch_cache: bool
    encoded_data_length: float
    timing: 'ResourceTiming'
    service_worker_response_source: 'ServiceWorkerResponseSource'
    response_time: 'TimeSinceEpoch'
    cache_storage_cache_name: str
    protocol: str
    alternate_protocol_usage: 'AlternateProtocolUsage'
    security_state: 'SecurityState'
    security_details: 'SecurityDetails'
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'url': self.url,
                'status': self.status,
                'status_text': self.status_text,
                'headers': self.headers,
                'headers_text': self.headers_text,
                'mime_type': self.mime_type,
                'request_headers': self.request_headers,
                'request_headers_text': self.request_headers_text,
                'connection_reused': self.connection_reused,
                'connection_id': self.connection_id,
                'remote_ip_address': self.remote_ip_address,
                'remote_port': self.remote_port,
                'from_disk_cache': self.from_disk_cache,
                'from_service_worker': self.from_service_worker,
                'from_prefetch_cache': self.from_prefetch_cache,
                'encoded_data_length': self.encoded_data_length,
                'timing': self.timing.to_dict(casing_strategy),
                'service_worker_response_source': self.service_worker_response_source,
                'response_time': self.response_time,
                'cache_storage_cache_name': self.cache_storage_cache_name,
                'protocol': self.protocol,
                'alternate_protocol_usage': self.alternate_protocol_usage,
                'security_state': self.security_state,
                'security_details': self.security_details.to_dict(casing_strategy),
            }        
        if casing_strategy == 'camel':
            return {
                'url': self.url,
                'status': self.status,
                'statusText': self.status_text,
                'headers': self.headers,
                'headersText': self.headers_text,
                'mimeType': self.mime_type,
                'requestHeaders': self.request_headers,
                'requestHeadersText': self.request_headers_text,
                'connectionReused': self.connection_reused,
                'connectionId': self.connection_id,
                'remoteIPAddress': self.remote_ip_address,
                'remotePort': self.remote_port,
                'fromDiskCache': self.from_disk_cache,
                'fromServiceWorker': self.from_service_worker,
                'fromPrefetchCache': self.from_prefetch_cache,
                'encodedDataLength': self.encoded_data_length,
                'timing': self.timing.to_dict(casing_strategy),
                'serviceWorkerResponseSource': self.service_worker_response_source,
                'responseTime': self.response_time,
                'cacheStorageCacheName': self.cache_storage_cache_name,
                'protocol': self.protocol,
                'alternateProtocolUsage': self.alternate_protocol_usage,
                'securityState': self.security_state,
                'securityDetails': self.security_details.to_dict(casing_strategy),
            }        
        if casing_strategy == 'pascal':
            return {
                'Url': self.url,
                'Status': self.status,
                'StatusText': self.status_text,
                'Headers': self.headers,
                'HeadersText': self.headers_text,
                'MimeType': self.mime_type,
                'RequestHeaders': self.request_headers,
                'RequestHeadersText': self.request_headers_text,
                'ConnectionReused': self.connection_reused,
                'ConnectionId': self.connection_id,
                'RemoteIPAddress': self.remote_ip_address,
                'RemotePort': self.remote_port,
                'FromDiskCache': self.from_disk_cache,
                'FromServiceWorker': self.from_service_worker,
                'FromPrefetchCache': self.from_prefetch_cache,
                'EncodedDataLength': self.encoded_data_length,
                'Timing': self.timing.to_dict(casing_strategy),
                'ServiceWorkerResponseSource': self.service_worker_response_source,
                'ResponseTime': self.response_time,
                'CacheStorageCacheName': self.cache_storage_cache_name,
                'Protocol': self.protocol,
                'AlternateProtocolUsage': self.alternate_protocol_usage,
                'SecurityState': self.security_state,
                'SecurityDetails': self.security_details.to_dict(casing_strategy),
            }


@dataclass
class WebSocketRequest:
    headers: 'Headers'
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'headers': self.headers,
            }        
        if casing_strategy == 'camel':
            return {
                'headers': self.headers,
            }        
        if casing_strategy == 'pascal':
            return {
                'Headers': self.headers,
            }


@dataclass
class WebSocketResponse:
    status: int
    status_text: str
    headers: 'Headers'
    headers_text: str
    request_headers: 'Headers'
    request_headers_text: str
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'status': self.status,
                'status_text': self.status_text,
                'headers': self.headers,
                'headers_text': self.headers_text,
                'request_headers': self.request_headers,
                'request_headers_text': self.request_headers_text,
            }        
        if casing_strategy == 'camel':
            return {
                'status': self.status,
                'statusText': self.status_text,
                'headers': self.headers,
                'headersText': self.headers_text,
                'requestHeaders': self.request_headers,
                'requestHeadersText': self.request_headers_text,
            }        
        if casing_strategy == 'pascal':
            return {
                'Status': self.status,
                'StatusText': self.status_text,
                'Headers': self.headers,
                'HeadersText': self.headers_text,
                'RequestHeaders': self.request_headers,
                'RequestHeadersText': self.request_headers_text,
            }


@dataclass
class WebSocketFrame:
    opcode: float
    mask: bool
    payload_data: str
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'opcode': self.opcode,
                'mask': self.mask,
                'payload_data': self.payload_data,
            }        
        if casing_strategy == 'camel':
            return {
                'opcode': self.opcode,
                'mask': self.mask,
                'payloadData': self.payload_data,
            }        
        if casing_strategy == 'pascal':
            return {
                'Opcode': self.opcode,
                'Mask': self.mask,
                'PayloadData': self.payload_data,
            }


@dataclass
class CachedResource:
    url: str
    type: 'ResourceType'
    response: 'Response'
    body_size: float
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'url': self.url,
                'type': self.type,
                'response': self.response.to_dict(casing_strategy),
                'body_size': self.body_size,
            }        
        if casing_strategy == 'camel':
            return {
                'url': self.url,
                'type': self.type,
                'response': self.response.to_dict(casing_strategy),
                'bodySize': self.body_size,
            }        
        if casing_strategy == 'pascal':
            return {
                'Url': self.url,
                'Type': self.type,
                'Response': self.response.to_dict(casing_strategy),
                'BodySize': self.body_size,
            }


@dataclass
class Initiator:
    type: str
    stack: 'StackTrace'
    url: str
    line_number: float
    column_number: float
    request_id: 'RequestId'
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'type': self.type,
                'stack': self.stack.to_dict(casing_strategy),
                'url': self.url,
                'line_number': self.line_number,
                'column_number': self.column_number,
                'request_id': self.request_id,
            }        
        if casing_strategy == 'camel':
            return {
                'type': self.type,
                'stack': self.stack.to_dict(casing_strategy),
                'url': self.url,
                'lineNumber': self.line_number,
                'columnNumber': self.column_number,
                'requestId': self.request_id,
            }        
        if casing_strategy == 'pascal':
            return {
                'Type': self.type,
                'Stack': self.stack.to_dict(casing_strategy),
                'Url': self.url,
                'LineNumber': self.line_number,
                'ColumnNumber': self.column_number,
                'RequestId': self.request_id,
            }


@dataclass
class Cookie:
    name: str
    value: str
    domain: str
    path: str
    expires: float
    size: int
    http_only: bool
    secure: bool
    session: bool
    same_site: 'CookieSameSite'
    priority: 'CookiePriority'
    same_party: bool
    source_scheme: 'CookieSourceScheme'
    source_port: int
    partition_key: str
    partition_key_opaque: bool
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'name': self.name,
                'value': self.value,
                'domain': self.domain,
                'path': self.path,
                'expires': self.expires,
                'size': self.size,
                'http_only': self.http_only,
                'secure': self.secure,
                'session': self.session,
                'same_site': self.same_site,
                'priority': self.priority,
                'same_party': self.same_party,
                'source_scheme': self.source_scheme,
                'source_port': self.source_port,
                'partition_key': self.partition_key,
                'partition_key_opaque': self.partition_key_opaque,
            }        
        if casing_strategy == 'camel':
            return {
                'name': self.name,
                'value': self.value,
                'domain': self.domain,
                'path': self.path,
                'expires': self.expires,
                'size': self.size,
                'httpOnly': self.http_only,
                'secure': self.secure,
                'session': self.session,
                'sameSite': self.same_site,
                'priority': self.priority,
                'sameParty': self.same_party,
                'sourceScheme': self.source_scheme,
                'sourcePort': self.source_port,
                'partitionKey': self.partition_key,
                'partitionKeyOpaque': self.partition_key_opaque,
            }        
        if casing_strategy == 'pascal':
            return {
                'Name': self.name,
                'Value': self.value,
                'Domain': self.domain,
                'Path': self.path,
                'Expires': self.expires,
                'Size': self.size,
                'HttpOnly': self.http_only,
                'Secure': self.secure,
                'Session': self.session,
                'SameSite': self.same_site,
                'Priority': self.priority,
                'SameParty': self.same_party,
                'SourceScheme': self.source_scheme,
                'SourcePort': self.source_port,
                'PartitionKey': self.partition_key,
                'PartitionKeyOpaque': self.partition_key_opaque,
            }


@dataclass
class BlockedSetCookieWithReason:
    blocked_reasons: list
    cookie_line: str
    cookie: 'Cookie'
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'blocked_reasons': [
                    _.to_dict(casing_strategy)
                    for _ in self.blocked_reasons
                ],
                'cookie_line': self.cookie_line,
                'cookie': self.cookie.to_dict(casing_strategy),
            }        
        if casing_strategy == 'camel':
            return {
                'blockedReasons': [
                    _.to_dict(casing_strategy)
                    for _ in self.blocked_reasons
                ],
                'cookieLine': self.cookie_line,
                'cookie': self.cookie.to_dict(casing_strategy),
            }        
        if casing_strategy == 'pascal':
            return {
                'BlockedReasons': [
                    _.to_dict(casing_strategy)
                    for _ in self.blocked_reasons
                ],
                'CookieLine': self.cookie_line,
                'Cookie': self.cookie.to_dict(casing_strategy),
            }


@dataclass
class BlockedCookieWithReason:
    blocked_reasons: list
    cookie: 'Cookie'
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'blocked_reasons': [
                    _.to_dict(casing_strategy)
                    for _ in self.blocked_reasons
                ],
                'cookie': self.cookie.to_dict(casing_strategy),
            }        
        if casing_strategy == 'camel':
            return {
                'blockedReasons': [
                    _.to_dict(casing_strategy)
                    for _ in self.blocked_reasons
                ],
                'cookie': self.cookie.to_dict(casing_strategy),
            }        
        if casing_strategy == 'pascal':
            return {
                'BlockedReasons': [
                    _.to_dict(casing_strategy)
                    for _ in self.blocked_reasons
                ],
                'Cookie': self.cookie.to_dict(casing_strategy),
            }


@dataclass
class CookieParam:
    name: str
    value: str
    url: str
    domain: str
    path: str
    secure: bool
    http_only: bool
    same_site: 'CookieSameSite'
    expires: 'TimeSinceEpoch'
    priority: 'CookiePriority'
    same_party: bool
    source_scheme: 'CookieSourceScheme'
    source_port: int
    partition_key: str
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'name': self.name,
                'value': self.value,
                'url': self.url,
                'domain': self.domain,
                'path': self.path,
                'secure': self.secure,
                'http_only': self.http_only,
                'same_site': self.same_site,
                'expires': self.expires,
                'priority': self.priority,
                'same_party': self.same_party,
                'source_scheme': self.source_scheme,
                'source_port': self.source_port,
                'partition_key': self.partition_key,
            }        
        if casing_strategy == 'camel':
            return {
                'name': self.name,
                'value': self.value,
                'url': self.url,
                'domain': self.domain,
                'path': self.path,
                'secure': self.secure,
                'httpOnly': self.http_only,
                'sameSite': self.same_site,
                'expires': self.expires,
                'priority': self.priority,
                'sameParty': self.same_party,
                'sourceScheme': self.source_scheme,
                'sourcePort': self.source_port,
                'partitionKey': self.partition_key,
            }        
        if casing_strategy == 'pascal':
            return {
                'Name': self.name,
                'Value': self.value,
                'Url': self.url,
                'Domain': self.domain,
                'Path': self.path,
                'Secure': self.secure,
                'HttpOnly': self.http_only,
                'SameSite': self.same_site,
                'Expires': self.expires,
                'Priority': self.priority,
                'SameParty': self.same_party,
                'SourceScheme': self.source_scheme,
                'SourcePort': self.source_port,
                'PartitionKey': self.partition_key,
            }


@dataclass
class AuthChallenge:
    source: str
    origin: str
    scheme: str
    realm: str
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'source': self.source,
                'origin': self.origin,
                'scheme': self.scheme,
                'realm': self.realm,
            }        
        if casing_strategy == 'camel':
            return {
                'source': self.source,
                'origin': self.origin,
                'scheme': self.scheme,
                'realm': self.realm,
            }        
        if casing_strategy == 'pascal':
            return {
                'Source': self.source,
                'Origin': self.origin,
                'Scheme': self.scheme,
                'Realm': self.realm,
            }


@dataclass
class AuthChallengeResponse:
    response: str
    username: str
    password: str
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'response': self.response,
                'username': self.username,
                'password': self.password,
            }        
        if casing_strategy == 'camel':
            return {
                'response': self.response,
                'username': self.username,
                'password': self.password,
            }        
        if casing_strategy == 'pascal':
            return {
                'Response': self.response,
                'Username': self.username,
                'Password': self.password,
            }


@dataclass
class RequestPattern:
    url_pattern: str
    resource_type: 'ResourceType'
    interception_stage: 'InterceptionStage'
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'url_pattern': self.url_pattern,
                'resource_type': self.resource_type,
                'interception_stage': self.interception_stage,
            }        
        if casing_strategy == 'camel':
            return {
                'urlPattern': self.url_pattern,
                'resourceType': self.resource_type,
                'interceptionStage': self.interception_stage,
            }        
        if casing_strategy == 'pascal':
            return {
                'UrlPattern': self.url_pattern,
                'ResourceType': self.resource_type,
                'InterceptionStage': self.interception_stage,
            }


@dataclass
class SignedExchangeSignature:
    label: str
    signature: str
    integrity: str
    cert_url: str
    cert_sha256: str
    validity_url: str
    date: int
    expires: int
    certificates: list
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'label': self.label,
                'signature': self.signature,
                'integrity': self.integrity,
                'cert_url': self.cert_url,
                'cert_sha256': self.cert_sha256,
                'validity_url': self.validity_url,
                'date': self.date,
                'expires': self.expires,
                'certificates': self.certificates,
            }        
        if casing_strategy == 'camel':
            return {
                'label': self.label,
                'signature': self.signature,
                'integrity': self.integrity,
                'certUrl': self.cert_url,
                'certSha256': self.cert_sha256,
                'validityUrl': self.validity_url,
                'date': self.date,
                'expires': self.expires,
                'certificates': self.certificates,
            }        
        if casing_strategy == 'pascal':
            return {
                'Label': self.label,
                'Signature': self.signature,
                'Integrity': self.integrity,
                'CertUrl': self.cert_url,
                'CertSha256': self.cert_sha256,
                'ValidityUrl': self.validity_url,
                'Date': self.date,
                'Expires': self.expires,
                'Certificates': self.certificates,
            }


@dataclass
class SignedExchangeHeader:
    request_url: str
    response_code: int
    response_headers: 'Headers'
    signatures: list
    header_integrity: str
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'request_url': self.request_url,
                'response_code': self.response_code,
                'response_headers': self.response_headers,
                'signatures': [
                    _.to_dict(casing_strategy)
                    for _ in self.signatures
                ],
                'header_integrity': self.header_integrity,
            }        
        if casing_strategy == 'camel':
            return {
                'requestUrl': self.request_url,
                'responseCode': self.response_code,
                'responseHeaders': self.response_headers,
                'signatures': [
                    _.to_dict(casing_strategy)
                    for _ in self.signatures
                ],
                'headerIntegrity': self.header_integrity,
            }        
        if casing_strategy == 'pascal':
            return {
                'RequestUrl': self.request_url,
                'ResponseCode': self.response_code,
                'ResponseHeaders': self.response_headers,
                'Signatures': [
                    _.to_dict(casing_strategy)
                    for _ in self.signatures
                ],
                'HeaderIntegrity': self.header_integrity,
            }


@dataclass
class SignedExchangeError:
    message: str
    signature_index: int
    error_field: 'SignedExchangeErrorField'
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'message': self.message,
                'signature_index': self.signature_index,
                'error_field': self.error_field,
            }        
        if casing_strategy == 'camel':
            return {
                'message': self.message,
                'signatureIndex': self.signature_index,
                'errorField': self.error_field,
            }        
        if casing_strategy == 'pascal':
            return {
                'Message': self.message,
                'SignatureIndex': self.signature_index,
                'ErrorField': self.error_field,
            }


@dataclass
class SignedExchangeInfo:
    outer_response: 'Response'
    header: 'SignedExchangeHeader'
    security_details: 'SecurityDetails'
    errors: list
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'outer_response': self.outer_response.to_dict(casing_strategy),
                'header': self.header.to_dict(casing_strategy),
                'security_details': self.security_details.to_dict(casing_strategy),
                'errors': [
                    _.to_dict(casing_strategy)
                    for _ in self.errors
                ],
            }        
        if casing_strategy == 'camel':
            return {
                'outerResponse': self.outer_response.to_dict(casing_strategy),
                'header': self.header.to_dict(casing_strategy),
                'securityDetails': self.security_details.to_dict(casing_strategy),
                'errors': [
                    _.to_dict(casing_strategy)
                    for _ in self.errors
                ],
            }        
        if casing_strategy == 'pascal':
            return {
                'OuterResponse': self.outer_response.to_dict(casing_strategy),
                'Header': self.header.to_dict(casing_strategy),
                'SecurityDetails': self.security_details.to_dict(casing_strategy),
                'Errors': [
                    _.to_dict(casing_strategy)
                    for _ in self.errors
                ],
            }


@dataclass
class ConnectTiming:
    request_time: float
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'request_time': self.request_time,
            }        
        if casing_strategy == 'camel':
            return {
                'requestTime': self.request_time,
            }        
        if casing_strategy == 'pascal':
            return {
                'RequestTime': self.request_time,
            }


@dataclass
class ClientSecurityState:
    initiator_is_secure_context: bool
    initiator_ip_address_space: 'IPAddressSpace'
    private_network_request_policy: 'PrivateNetworkRequestPolicy'
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'initiator_is_secure_context': self.initiator_is_secure_context,
                'initiator_ip_address_space': self.initiator_ip_address_space,
                'private_network_request_policy': self.private_network_request_policy,
            }        
        if casing_strategy == 'camel':
            return {
                'initiatorIsSecureContext': self.initiator_is_secure_context,
                'initiatorIPAddressSpace': self.initiator_ip_address_space,
                'privateNetworkRequestPolicy': self.private_network_request_policy,
            }        
        if casing_strategy == 'pascal':
            return {
                'InitiatorIsSecureContext': self.initiator_is_secure_context,
                'InitiatorIPAddressSpace': self.initiator_ip_address_space,
                'PrivateNetworkRequestPolicy': self.private_network_request_policy,
            }


@dataclass
class CrossOriginOpenerPolicyStatus:
    value: 'CrossOriginOpenerPolicyValue'
    report_only_value: 'CrossOriginOpenerPolicyValue'
    reporting_endpoint: str
    report_only_reporting_endpoint: str
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'value': self.value,
                'report_only_value': self.report_only_value,
                'reporting_endpoint': self.reporting_endpoint,
                'report_only_reporting_endpoint': self.report_only_reporting_endpoint,
            }        
        if casing_strategy == 'camel':
            return {
                'value': self.value,
                'reportOnlyValue': self.report_only_value,
                'reportingEndpoint': self.reporting_endpoint,
                'reportOnlyReportingEndpoint': self.report_only_reporting_endpoint,
            }        
        if casing_strategy == 'pascal':
            return {
                'Value': self.value,
                'ReportOnlyValue': self.report_only_value,
                'ReportingEndpoint': self.reporting_endpoint,
                'ReportOnlyReportingEndpoint': self.report_only_reporting_endpoint,
            }


@dataclass
class CrossOriginEmbedderPolicyStatus:
    value: 'CrossOriginEmbedderPolicyValue'
    report_only_value: 'CrossOriginEmbedderPolicyValue'
    reporting_endpoint: str
    report_only_reporting_endpoint: str
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'value': self.value,
                'report_only_value': self.report_only_value,
                'reporting_endpoint': self.reporting_endpoint,
                'report_only_reporting_endpoint': self.report_only_reporting_endpoint,
            }        
        if casing_strategy == 'camel':
            return {
                'value': self.value,
                'reportOnlyValue': self.report_only_value,
                'reportingEndpoint': self.reporting_endpoint,
                'reportOnlyReportingEndpoint': self.report_only_reporting_endpoint,
            }        
        if casing_strategy == 'pascal':
            return {
                'Value': self.value,
                'ReportOnlyValue': self.report_only_value,
                'ReportingEndpoint': self.reporting_endpoint,
                'ReportOnlyReportingEndpoint': self.report_only_reporting_endpoint,
            }


@dataclass
class ContentSecurityPolicyStatus:
    effective_directives: str
    is_enforced: bool
    source: 'ContentSecurityPolicySource'
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'effective_directives': self.effective_directives,
                'is_enforced': self.is_enforced,
                'source': self.source,
            }        
        if casing_strategy == 'camel':
            return {
                'effectiveDirectives': self.effective_directives,
                'isEnforced': self.is_enforced,
                'source': self.source,
            }        
        if casing_strategy == 'pascal':
            return {
                'EffectiveDirectives': self.effective_directives,
                'IsEnforced': self.is_enforced,
                'Source': self.source,
            }


@dataclass
class SecurityIsolationStatus:
    coop: 'CrossOriginOpenerPolicyStatus'
    coep: 'CrossOriginEmbedderPolicyStatus'
    csp: list
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'coop': self.coop.to_dict(casing_strategy),
                'coep': self.coep.to_dict(casing_strategy),
                'csp': [
                    _.to_dict(casing_strategy)
                    for _ in self.csp
                ],
            }        
        if casing_strategy == 'camel':
            return {
                'coop': self.coop.to_dict(casing_strategy),
                'coep': self.coep.to_dict(casing_strategy),
                'csp': [
                    _.to_dict(casing_strategy)
                    for _ in self.csp
                ],
            }        
        if casing_strategy == 'pascal':
            return {
                'Coop': self.coop.to_dict(casing_strategy),
                'Coep': self.coep.to_dict(casing_strategy),
                'Csp': [
                    _.to_dict(casing_strategy)
                    for _ in self.csp
                ],
            }


@dataclass
class ReportingApiReport:
    id: 'ReportId'
    initiator_url: str
    destination: str
    type: str
    timestamp: 'TimeSinceEpoch'
    depth: int
    completed_attempts: int
    body: object
    status: 'ReportStatus'
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'id': self.id,
                'initiator_url': self.initiator_url,
                'destination': self.destination,
                'type': self.type,
                'timestamp': self.timestamp,
                'depth': self.depth,
                'completed_attempts': self.completed_attempts,
                'body': self.body,
                'status': self.status,
            }        
        if casing_strategy == 'camel':
            return {
                'id': self.id,
                'initiatorUrl': self.initiator_url,
                'destination': self.destination,
                'type': self.type,
                'timestamp': self.timestamp,
                'depth': self.depth,
                'completedAttempts': self.completed_attempts,
                'body': self.body,
                'status': self.status,
            }        
        if casing_strategy == 'pascal':
            return {
                'Id': self.id,
                'InitiatorUrl': self.initiator_url,
                'Destination': self.destination,
                'Type': self.type,
                'Timestamp': self.timestamp,
                'Depth': self.depth,
                'CompletedAttempts': self.completed_attempts,
                'Body': self.body,
                'Status': self.status,
            }


@dataclass
class ReportingApiEndpoint:
    url: str
    group_name: str
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'url': self.url,
                'group_name': self.group_name,
            }        
        if casing_strategy == 'camel':
            return {
                'url': self.url,
                'groupName': self.group_name,
            }        
        if casing_strategy == 'pascal':
            return {
                'Url': self.url,
                'GroupName': self.group_name,
            }


@dataclass
class LoadNetworkResourcePageResult:
    success: bool
    net_error: float
    net_error_name: str
    http_status_code: float
    stream: 'StreamHandle'
    headers: 'Headers'
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'success': self.success,
                'net_error': self.net_error,
                'net_error_name': self.net_error_name,
                'http_status_code': self.http_status_code,
                'stream': self.stream,
                'headers': self.headers,
            }        
        if casing_strategy == 'camel':
            return {
                'success': self.success,
                'netError': self.net_error,
                'netErrorName': self.net_error_name,
                'httpStatusCode': self.http_status_code,
                'stream': self.stream,
                'headers': self.headers,
            }        
        if casing_strategy == 'pascal':
            return {
                'Success': self.success,
                'NetError': self.net_error,
                'NetErrorName': self.net_error_name,
                'HttpStatusCode': self.http_status_code,
                'Stream': self.stream,
                'Headers': self.headers,
            }


@dataclass
class LoadNetworkResourceOptions:
    disable_cache: bool
    include_credentials: bool
    def to_dict(
        self,
        casing_strategy: Literal['snake', 'camel', 'pascal'] = 'snake'
    ):
        
        if casing_strategy == 'snake':
            return {
                'disable_cache': self.disable_cache,
                'include_credentials': self.include_credentials,
            }        
        if casing_strategy == 'camel':
            return {
                'disableCache': self.disable_cache,
                'includeCredentials': self.include_credentials,
            }        
        if casing_strategy == 'pascal':
            return {
                'DisableCache': self.disable_cache,
                'IncludeCredentials': self.include_credentials,
            }


@dataclass
class CanClearBrowserCacheReturnT:
    result: bool


@dataclass
class CanClearBrowserCookiesReturnT:
    result: bool


@dataclass
class CanEmulateNetworkConditionsReturnT:
    result: bool


@dataclass
class GetAllCookiesReturnT:
    cookies: list


@dataclass
class GetCertificateReturnT:
    table_names: list


@dataclass
class GetCookiesReturnT:
    cookies: list


@dataclass
class GetResponseBodyReturnT:
    body: str
    base64_encoded: bool


@dataclass
class GetRequestPostDataReturnT:
    post_data: str


@dataclass
class GetResponseBodyForInterceptionReturnT:
    body: str
    base64_encoded: bool


@dataclass
class TakeResponseBodyForInterceptionAsStreamReturnT:
    stream: 'StreamHandle'


@dataclass
class SearchInResponseBodyReturnT:
    result: list


@dataclass
class SetCookieReturnT:
    success: bool


@dataclass
class GetSecurityIsolationStatusReturnT:
    status: 'SecurityIsolationStatus'


@dataclass
class LoadNetworkResourceReturnT:
    resource: 'LoadNetworkResourcePageResult'
