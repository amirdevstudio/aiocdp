# DO NOT EDIT THIS FILE
#
# This file is generated by the generator. To make changes, edit the generator
# and run it again.

from cdp.domains.base import (
    BaseDomain
)
from dataclasses import (
    dataclass
)
from cdp.utils import (
    is_defined,
    UNDEFINED
)
from typing import (
    TYPE_CHECKING
)
from cdp.domains.network.types import (
    AuthChallengeResponse,
    CanClearBrowserCacheReturnT,
    CanClearBrowserCookiesReturnT,
    CanEmulateNetworkConditionsReturnT,
    ConnectionType,
    CookiePriority,
    CookieSameSite,
    CookieSourceScheme,
    ErrorReason,
    GetAllCookiesReturnT,
    GetCertificateReturnT,
    GetCookiesReturnT,
    GetRequestPostDataReturnT,
    GetResponseBodyForInterceptionReturnT,
    GetResponseBodyReturnT,
    GetSecurityIsolationStatusReturnT,
    Headers,
    InterceptionId,
    LoadNetworkResourceOptions,
    LoadNetworkResourceReturnT,
    RequestId,
    SearchInResponseBodyReturnT,
    SetCookieReturnT,
    TakeResponseBodyForInterceptionAsStreamReturnT,
    TimeSinceEpoch
)
from cdp.domains.emulation.types import (
    UserAgentMetadata
)
from cdp.domains.page.types import (
    FrameId
)
if TYPE_CHECKING:
    from cdp.target.connection import (
        IResult
    )


@dataclass
class Network(BaseDomain):
    def set_accepted_encodings(
            self,
            encodings: list
    ) -> IResult[None]:
        params = {
            'encodings': encodings,
        }

        return self._send_command(
            'Network.setAcceptedEncodings',
            params,
            False
        )

    def clear_accepted_encodings_override(
            self
    ) -> IResult[None]:
        params = {}

        return self._send_command(
            'Network.clearAcceptedEncodingsOverride',
            params,
            False
        )

    def can_clear_browser_cache(
            self
    ) -> IResult['CanClearBrowserCacheReturnT']:
        params = {}

        return self._send_command(
            'Network.canClearBrowserCache',
            params,
            True
        )

    def can_clear_browser_cookies(
            self
    ) -> IResult['CanClearBrowserCookiesReturnT']:
        params = {}

        return self._send_command(
            'Network.canClearBrowserCookies',
            params,
            True
        )

    def can_emulate_network_conditions(
            self
    ) -> IResult['CanEmulateNetworkConditionsReturnT']:
        params = {}

        return self._send_command(
            'Network.canEmulateNetworkConditions',
            params,
            True
        )

    def clear_browser_cache(
            self
    ) -> IResult[None]:
        params = {}

        return self._send_command(
            'Network.clearBrowserCache',
            params,
            False
        )

    def clear_browser_cookies(
            self
    ) -> IResult[None]:
        params = {}

        return self._send_command(
            'Network.clearBrowserCookies',
            params,
            False
        )

    def continue_intercepted_request(
            self,
            interception_id: InterceptionId,
            error_reason: ErrorReason = UNDEFINED,
            raw_response: str = UNDEFINED,
            url: str = UNDEFINED,
            method: str = UNDEFINED,
            post_data: str = UNDEFINED,
            headers: Headers = UNDEFINED,
            auth_challenge_response: AuthChallengeResponse = UNDEFINED
    ) -> IResult[None]:
        params = {
            'interceptionId': interception_id,
        }

        if is_defined(error_reason):
            params['errorReason'] = error_reason

        if is_defined(raw_response):
            params['rawResponse'] = raw_response

        if is_defined(url):
            params['url'] = url

        if is_defined(method):
            params['method'] = method

        if is_defined(post_data):
            params['postData'] = post_data

        if is_defined(headers):
            params['headers'] = headers

        if is_defined(auth_challenge_response):
            params['authChallengeResponse'] = auth_challenge_response

        return self._send_command(
            'Network.continueInterceptedRequest',
            params,
            False
        )

    def delete_cookies(
            self,
            name: str,
            url: str = UNDEFINED,
            domain: str = UNDEFINED,
            path: str = UNDEFINED
    ) -> IResult[None]:
        params = {
            'name': name,
        }

        if is_defined(url):
            params['url'] = url

        if is_defined(domain):
            params['domain'] = domain

        if is_defined(path):
            params['path'] = path

        return self._send_command(
            'Network.deleteCookies',
            params,
            False
        )

    def disable(
            self
    ) -> IResult[None]:
        params = {}

        return self._send_command(
            'Network.disable',
            params,
            False
        )

    def emulate_network_conditions(
            self,
            offline: bool,
            latency: float,
            download_throughput: float,
            upload_throughput: float,
            connection_type: ConnectionType = UNDEFINED
    ) -> IResult[None]:
        params = {
            'offline': offline,
            'latency': latency,
            'downloadThroughput': download_throughput,
            'uploadThroughput': upload_throughput,
        }

        if is_defined(connection_type):
            params['connectionType'] = connection_type

        return self._send_command(
            'Network.emulateNetworkConditions',
            params,
            False
        )

    def enable(
            self,
            max_total_buffer_size: int = UNDEFINED,
            max_resource_buffer_size: int = UNDEFINED,
            max_post_data_size: int = UNDEFINED
    ) -> IResult[None]:
        params = {}

        if is_defined(max_total_buffer_size):
            params['maxTotalBufferSize'] = max_total_buffer_size

        if is_defined(max_resource_buffer_size):
            params['maxResourceBufferSize'] = max_resource_buffer_size

        if is_defined(max_post_data_size):
            params['maxPostDataSize'] = max_post_data_size

        return self._send_command(
            'Network.enable',
            params,
            False
        )

    def get_all_cookies(
            self
    ) -> IResult['GetAllCookiesReturnT']:
        params = {}

        return self._send_command(
            'Network.getAllCookies',
            params,
            True
        )

    def get_certificate(
            self,
            origin: str
    ) -> IResult['GetCertificateReturnT']:
        params = {
            'origin': origin,
        }

        return self._send_command(
            'Network.getCertificate',
            params,
            True
        )

    def get_cookies(
            self,
            urls: list = UNDEFINED
    ) -> IResult['GetCookiesReturnT']:
        params = {}

        if is_defined(urls):
            params['urls'] = urls

        return self._send_command(
            'Network.getCookies',
            params,
            True
        )

    def get_response_body(
            self,
            request_id: RequestId
    ) -> IResult['GetResponseBodyReturnT']:
        params = {
            'requestId': request_id,
        }

        return self._send_command(
            'Network.getResponseBody',
            params,
            True
        )

    def get_request_post_data(
            self,
            request_id: RequestId
    ) -> IResult['GetRequestPostDataReturnT']:
        params = {
            'requestId': request_id,
        }

        return self._send_command(
            'Network.getRequestPostData',
            params,
            True
        )

    def get_response_body_for_interception(
            self,
            interception_id: InterceptionId
    ) -> IResult['GetResponseBodyForInterceptionReturnT']:
        params = {
            'interceptionId': interception_id,
        }

        return self._send_command(
            'Network.getResponseBodyForInterception',
            params,
            True
        )

    def take_response_body_for_interception_as_stream(
            self,
            interception_id: InterceptionId
    ) -> IResult['TakeResponseBodyForInterceptionAsStreamReturnT']:
        params = {
            'interceptionId': interception_id,
        }

        return self._send_command(
            'Network.takeResponseBodyForInterceptionAsStream',
            params,
            True
        )

    def replay_xhr(
            self,
            request_id: RequestId
    ) -> IResult[None]:
        params = {
            'requestId': request_id,
        }

        return self._send_command(
            'Network.replayXHR',
            params,
            False
        )

    def search_in_response_body(
            self,
            request_id: RequestId,
            query: str,
            case_sensitive: bool = UNDEFINED,
            is_regex: bool = UNDEFINED
    ) -> IResult['SearchInResponseBodyReturnT']:
        params = {
            'requestId': request_id,
            'query': query,
        }

        if is_defined(case_sensitive):
            params['caseSensitive'] = case_sensitive

        if is_defined(is_regex):
            params['isRegex'] = is_regex

        return self._send_command(
            'Network.searchInResponseBody',
            params,
            True
        )

    def set_blocked_ur_ls(
            self,
            urls: list
    ) -> IResult[None]:
        params = {
            'urls': urls,
        }

        return self._send_command(
            'Network.setBlockedURLs',
            params,
            False
        )

    def set_bypass_service_worker(
            self,
            bypass: bool
    ) -> IResult[None]:
        params = {
            'bypass': bypass,
        }

        return self._send_command(
            'Network.setBypassServiceWorker',
            params,
            False
        )

    def set_cache_disabled(
            self,
            cache_disabled: bool
    ) -> IResult[None]:
        params = {
            'cacheDisabled': cache_disabled,
        }

        return self._send_command(
            'Network.setCacheDisabled',
            params,
            False
        )

    def set_cookie(
            self,
            name: str,
            value: str,
            url: str = UNDEFINED,
            domain: str = UNDEFINED,
            path: str = UNDEFINED,
            secure: bool = UNDEFINED,
            http_only: bool = UNDEFINED,
            same_site: CookieSameSite = UNDEFINED,
            expires: TimeSinceEpoch = UNDEFINED,
            priority: CookiePriority = UNDEFINED,
            same_party: bool = UNDEFINED,
            source_scheme: CookieSourceScheme = UNDEFINED,
            source_port: int = UNDEFINED,
            partition_key: str = UNDEFINED
    ) -> IResult['SetCookieReturnT']:
        params = {
            'name': name,
            'value': value,
        }

        if is_defined(url):
            params['url'] = url

        if is_defined(domain):
            params['domain'] = domain

        if is_defined(path):
            params['path'] = path

        if is_defined(secure):
            params['secure'] = secure

        if is_defined(http_only):
            params['httpOnly'] = http_only

        if is_defined(same_site):
            params['sameSite'] = same_site

        if is_defined(expires):
            params['expires'] = expires

        if is_defined(priority):
            params['priority'] = priority

        if is_defined(same_party):
            params['sameParty'] = same_party

        if is_defined(source_scheme):
            params['sourceScheme'] = source_scheme

        if is_defined(source_port):
            params['sourcePort'] = source_port

        if is_defined(partition_key):
            params['partitionKey'] = partition_key

        return self._send_command(
            'Network.setCookie',
            params,
            True
        )

    def set_cookies(
            self,
            cookies: list
    ) -> IResult[None]:
        params = {
            'cookies': cookies,
        }

        return self._send_command(
            'Network.setCookies',
            params,
            False
        )

    def set_extra_http_headers(
            self,
            headers: Headers
    ) -> IResult[None]:
        params = {
            'headers': headers,
        }

        return self._send_command(
            'Network.setExtraHTTPHeaders',
            params,
            False
        )

    def set_attach_debug_stack(
            self,
            enabled: bool
    ) -> IResult[None]:
        params = {
            'enabled': enabled,
        }

        return self._send_command(
            'Network.setAttachDebugStack',
            params,
            False
        )

    def set_request_interception(
            self,
            patterns: list
    ) -> IResult[None]:
        params = {
            'patterns': patterns,
        }

        return self._send_command(
            'Network.setRequestInterception',
            params,
            False
        )

    def set_user_agent_override(
            self,
            user_agent: str,
            accept_language: str = UNDEFINED,
            platform: str = UNDEFINED,
            user_agent_metadata: UserAgentMetadata = UNDEFINED
    ) -> IResult[None]:
        params = {
            'userAgent': user_agent,
        }

        if is_defined(accept_language):
            params['acceptLanguage'] = accept_language

        if is_defined(platform):
            params['platform'] = platform

        if is_defined(user_agent_metadata):
            params['userAgentMetadata'] = user_agent_metadata

        return self._send_command(
            'Network.setUserAgentOverride',
            params,
            False
        )

    def get_security_isolation_status(
            self,
            frame_id: FrameId = UNDEFINED
    ) -> IResult['GetSecurityIsolationStatusReturnT']:
        params = {}

        if is_defined(frame_id):
            params['frameId'] = frame_id

        return self._send_command(
            'Network.getSecurityIsolationStatus',
            params,
            True
        )

    def enable_reporting_api(
            self,
            enable: bool
    ) -> IResult[None]:
        params = {
            'enable': enable,
        }

        return self._send_command(
            'Network.enableReportingApi',
            params,
            False
        )

    def load_network_resource(
            self,
            frame_id: FrameId,
            url: str,
            options: LoadNetworkResourceOptions = UNDEFINED
    ) -> IResult['LoadNetworkResourceReturnT']:
        params = {
            'url': url,
            'options': options,
        }

        if is_defined(frame_id):
            params['frameId'] = frame_id

        return self._send_command(
            'Network.loadNetworkResource',
            params,
            True
        )
