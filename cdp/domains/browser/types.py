# DO NOT EDIT THIS FILE
#
# This file is generated by the generator. To make changes, edit the generator
# and run it again.

from typing import (
    Any,
    Literal,
    TYPE_CHECKING
)
from dataclasses import (
    dataclass
)
if TYPE_CHECKING:
    from cdp.domains.target.types import (
        TargetID
    )

BrowserContextID = str

WindowID = int

WindowState = Literal[
    'normal',
    'minimized',
    'maximized',
    'fullscreen'
]

PermissionType = Literal[
    'accessibilityEvents',
    'audioCapture',
    'backgroundSync',
    'backgroundFetch',
    'clipboardReadWrite',
    'clipboardSanitizedWrite',
    'displayCapture',
    'durableStorage',
    'flash',
    'geolocation',
    'idleDetection',
    'localFonts',
    'midi',
    'midiSysex',
    'nfc',
    'notifications',
    'paymentHandler',
    'periodicBackgroundSync',
    'protectedMediaIdentifier',
    'sensors',
    'storageAccess',
    'topLevelStorageAccess',
    'videoCapture',
    'videoCapturePanTiltZoom',
    'wakeLockScreen',
    'wakeLockSystem',
    'windowManagement'
]

PermissionSetting = Literal[
    'granted',
    'denied',
    'prompt'
]

BrowserCommandId = Literal[
    'openTabSearch',
    'closeTabSearch'
]


@dataclass
class Bounds:
    left: int
    top: int
    width: int
    height: int
    window_state: 'WindowState'
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'left': self.left,
                'top': self.top,
                'width': self.width,
                'height': self.height,
                'window_state': self.window_state,
            }
        if casing_strategy == 'camel':
            return {
                'left': self.left,
                'top': self.top,
                'width': self.width,
                'height': self.height,
                'windowState': self.window_state,
            }
        if casing_strategy == 'pascal':
            return {
                'Left': self.left,
                'Top': self.top,
                'Width': self.width,
                'Height': self.height,
                'WindowState': self.window_state,
            }


@dataclass
class PermissionDescriptor:
    name: str
    sysex: bool
    user_visible_only: bool
    allow_without_sanitization: bool
    pan_tilt_zoom: bool
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'name': self.name,
                'sysex': self.sysex,
                'user_visible_only': self.user_visible_only,
                'allow_without_sanitization': self.allow_without_sanitization,
                'pan_tilt_zoom': self.pan_tilt_zoom,
            }
        if casing_strategy == 'camel':
            return {
                'name': self.name,
                'sysex': self.sysex,
                'userVisibleOnly': self.user_visible_only,
                'allowWithoutSanitization': self.allow_without_sanitization,
                'panTiltZoom': self.pan_tilt_zoom,
            }
        if casing_strategy == 'pascal':
            return {
                'Name': self.name,
                'Sysex': self.sysex,
                'UserVisibleOnly': self.user_visible_only,
                'AllowWithoutSanitization': self.allow_without_sanitization,
                'PanTiltZoom': self.pan_tilt_zoom,
            }


@dataclass
class Bucket:
    low: int
    high: int
    count: int
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'low': self.low,
                'high': self.high,
                'count': self.count,
            }
        if casing_strategy == 'camel':
            return {
                'low': self.low,
                'high': self.high,
                'count': self.count,
            }
        if casing_strategy == 'pascal':
            return {
                'Low': self.low,
                'High': self.high,
                'Count': self.count,
            }


@dataclass
class Histogram:
    name: str
    sum: int
    count: int
    buckets: list
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'name': self.name,
                'sum': self.sum_,
                'count': self.count,
                'buckets': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.buckets
                ],
            }
        if casing_strategy == 'camel':
            return {
                'name': self.name,
                'sum': self.sum_,
                'count': self.count,
                'buckets': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.buckets
                ],
            }
        if casing_strategy == 'pascal':
            return {
                'Name': self.name,
                'Sum': self.sum_,
                'Count': self.count,
                'Buckets': [_.to_dict(
                    casing_strategy
                )
                    for _ in self.buckets
                ],
            }


@dataclass
class GetVersionReturnT:
    protocol_version: str
    product: str
    revision: str
    user_agent: str
    js_version: str


@dataclass
class GetBrowserCommandLineReturnT:
    arguments: list


@dataclass
class GetHistogramsReturnT:
    histograms: list


@dataclass
class GetHistogramReturnT:
    histogram: 'Histogram'


@dataclass
class GetWindowBoundsReturnT:
    bounds: 'Bounds'


@dataclass
class GetWindowForTargetReturnT:
    window_id: 'WindowID'
    bounds: 'Bounds'
