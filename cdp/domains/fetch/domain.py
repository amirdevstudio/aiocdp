# DO NOT EDIT THIS FILE
#
# This file is generated by the generator. To make changes, edit the generator
# and run it again.

from cdp.domains.base import (
    BaseDomain
)
from cdp.domains import (
    mappers
)
from cdp.utils import (
    UNDEFINED,
    is_defined
)
from dataclasses import (
    dataclass
)
from typing import (
    TYPE_CHECKING
)
from cdp.domains.fetch.types import (
    AuthChallengeResponse,
    ErrorReason,
    GetResponseBodyReturnType,
    RequestId,
    TakeResponseBodyAsStreamReturnType
)
if TYPE_CHECKING:
    from cdp.target.connection import (
        IFutureResponse
    )


@dataclass
class Fetch(BaseDomain):
    def disable(
            self
    ) -> 'IFutureResponse[None]':
        params = {}

        return self._send_command(
            'Fetch.disable',
            params,
            False
        )

    def enable(
            self,
            patterns: 'list' = UNDEFINED,
            handle_auth_requests: 'bool' = UNDEFINED
    ) -> 'IFutureResponse[None]':
        params = {}

        if is_defined(patterns):
            params['patterns'] = patterns

        if is_defined(handle_auth_requests):
            params['handleAuthRequests'] = handle_auth_requests

        return self._send_command(
            'Fetch.enable',
            params,
            False
        )

    def fail_request(
            self,
            request_id: 'RequestId',
            error_reason: 'ErrorReason'
    ) -> 'IFutureResponse[None]':
        params = {
            'requestId': to_dict(
                request_id,
                'camel'
            ),
            'errorReason': to_dict(
                error_reason,
                'camel'
            ),
        }

        return self._send_command(
            'Fetch.failRequest',
            params,
            False
        )

    def fulfill_request(
            self,
            request_id: 'RequestId',
            response_code: 'int',
            response_headers: 'list' = UNDEFINED,
            binary_response_headers: 'str' = UNDEFINED,
            body: 'str' = UNDEFINED,
            response_phrase: 'str' = UNDEFINED
    ) -> 'IFutureResponse[None]':
        params = {
            'requestId': to_dict(
                request_id,
                'camel'
            ),
            'responseCode': response_code,
        }

        if is_defined(response_headers):
            params['responseHeaders'] = response_headers

        if is_defined(binary_response_headers):
            params['binaryResponseHeaders'] = binary_response_headers

        if is_defined(body):
            params['body'] = body

        if is_defined(response_phrase):
            params['responsePhrase'] = response_phrase

        return self._send_command(
            'Fetch.fulfillRequest',
            params,
            False
        )

    def continue_request(
            self,
            request_id: 'RequestId',
            url: 'str' = UNDEFINED,
            method: 'str' = UNDEFINED,
            post_data: 'str' = UNDEFINED,
            headers: 'list' = UNDEFINED,
            intercept_response: 'bool' = UNDEFINED
    ) -> 'IFutureResponse[None]':
        params = {
            'requestId': to_dict(
                request_id,
                'camel'
            ),
        }

        if is_defined(url):
            params['url'] = url

        if is_defined(method):
            params['method'] = method

        if is_defined(post_data):
            params['postData'] = post_data

        if is_defined(headers):
            params['headers'] = headers

        if is_defined(intercept_response):
            params['interceptResponse'] = intercept_response

        return self._send_command(
            'Fetch.continueRequest',
            params,
            False
        )

    def continue_with_auth(
            self,
            request_id: 'RequestId',
            auth_challenge_response: 'AuthChallengeResponse'
    ) -> 'IFutureResponse[None]':
        params = {
            'requestId': to_dict(
                request_id,
                'camel'
            ),
            'authChallengeResponse': to_dict(
                auth_challenge_response,
                'camel'
            ),
        }

        return self._send_command(
            'Fetch.continueWithAuth',
            params,
            False
        )

    def continue_response(
            self,
            request_id: 'RequestId',
            response_code: 'int' = UNDEFINED,
            response_phrase: 'str' = UNDEFINED,
            response_headers: 'list' = UNDEFINED,
            binary_response_headers: 'str' = UNDEFINED
    ) -> 'IFutureResponse[None]':
        params = {
            'requestId': to_dict(
                request_id,
                'camel'
            ),
        }

        if is_defined(response_code):
            params['responseCode'] = response_code

        if is_defined(response_phrase):
            params['responsePhrase'] = response_phrase

        if is_defined(response_headers):
            params['responseHeaders'] = response_headers

        if is_defined(binary_response_headers):
            params['binaryResponseHeaders'] = binary_response_headers

        return self._send_command(
            'Fetch.continueResponse',
            params,
            False
        )

    def get_response_body(
            self,
            request_id: 'RequestId'
    ) -> 'IFutureResponse[GetResponseBodyReturnType]':
        params = {
            'requestId': to_dict(
                request_id,
                'camel'
            ),
        }

        return self._send_command(
            'Fetch.getResponseBody',
            params,
            True,
            lambda data: from_dict(
                GetResponseBodyReturnType,
                data,
                'camel'
            )
        )

    def take_response_body_as_stream(
            self,
            request_id: 'RequestId'
    ) -> 'IFutureResponse[TakeResponseBodyAsStreamReturnType]':
        params = {
            'requestId': to_dict(
                request_id,
                'camel'
            ),
        }

        return self._send_command(
            'Fetch.takeResponseBodyAsStream',
            params,
            True,
            lambda data: from_dict(
                TakeResponseBodyAsStreamReturnType,
                data,
                'camel'
            )
        )
