# DO NOT EDIT THIS FILE
#
# This file is generated by the generator. To make changes, edit the generator
# and run it again.

from cdp.domains.base import (
    BaseDomain
)
from cdp.domains import (
    mappers
)
from cdp.utils import (
    UNDEFINED,
    is_defined
)
from dataclasses import (
    dataclass
)
from typing import (
    TYPE_CHECKING
)
from cdp.domains.debugger.types import (
    BreakpointId,
    CallArgument,
    CallFrameId,
    EnableReturnType,
    EvaluateOnCallFrameReturnType,
    GetPossibleBreakpointsReturnType,
    GetScriptSourceReturnType,
    GetStackTraceReturnType,
    Location,
    RemoteObjectId,
    RestartFrameReturnType,
    ScriptId,
    SearchInContentReturnType,
    SetBreakpointByUrlReturnType,
    SetBreakpointOnFunctionCallReturnType,
    SetBreakpointReturnType,
    SetInstrumentationBreakpointReturnType,
    SetScriptSourceReturnType,
    StackTraceId,
    TimeDelta
)
if TYPE_CHECKING:
    from cdp.target.connection import (
        IFutureResponse
    )


@dataclass
class Debugger(BaseDomain):
    def continue_to_location(
            self,
            location: 'Location',
            target_call_frames: 'str' = UNDEFINED
    ) -> 'IFutureResponse[None]':
        params = {
            'location': to_dict(
                location,
                'camel'
            ),
        }

        if is_defined(target_call_frames):
            params['targetCallFrames'] = target_call_frames

        return self._send_command(
            'Debugger.continueToLocation',
            params,
            False
        )

    def disable(
            self
    ) -> 'IFutureResponse[None]':
        params = {}

        return self._send_command(
            'Debugger.disable',
            params,
            False
        )

    def enable(
            self,
            max_scripts_cache_size: 'float' = UNDEFINED
    ) -> 'IFutureResponse[EnableReturnType]':
        params = {}

        if is_defined(max_scripts_cache_size):
            params['maxScriptsCacheSize'] = max_scripts_cache_size

        return self._send_command(
            'Debugger.enable',
            params,
            True,
            lambda data: from_dict(
                EnableReturnType,
                data,
                'camel'
            )
        )

    def evaluate_on_call_frame(
            self,
            call_frame_id: 'CallFrameId',
            expression: 'str',
            object_group: 'str' = UNDEFINED,
            include_command_line_api: 'bool' = UNDEFINED,
            silent: 'bool' = UNDEFINED,
            return_by_value: 'bool' = UNDEFINED,
            generate_preview: 'bool' = UNDEFINED,
            throw_on_side_effect: 'bool' = UNDEFINED,
            timeout: 'TimeDelta' = UNDEFINED
    ) -> 'IFutureResponse[EvaluateOnCallFrameReturnType]':
        params = {
            'callFrameId': to_dict(
                call_frame_id,
                'camel'
            ),
            'expression': expression,
        }

        if is_defined(object_group):
            params['objectGroup'] = object_group

        if is_defined(include_command_line_api):
            params['includeCommandLineAPI'] = include_command_line_api

        if is_defined(silent):
            params['silent'] = silent

        if is_defined(return_by_value):
            params['returnByValue'] = return_by_value

        if is_defined(generate_preview):
            params['generatePreview'] = generate_preview

        if is_defined(throw_on_side_effect):
            params['throwOnSideEffect'] = throw_on_side_effect

        if is_defined(timeout):
            params['timeout'] = to_dict(
                timeout,
                'camel'
            )

        return self._send_command(
            'Debugger.evaluateOnCallFrame',
            params,
            True,
            lambda data: from_dict(
                EvaluateOnCallFrameReturnType,
                data,
                'camel'
            )
        )

    def get_possible_breakpoints(
            self,
            start: 'Location',
            end: 'Location' = UNDEFINED,
            restrict_to_function: 'bool' = UNDEFINED
    ) -> 'IFutureResponse[GetPossibleBreakpointsReturnType]':
        params = {
            'start': to_dict(
                start,
                'camel'
            ),
        }

        if is_defined(end):
            params['end'] = to_dict(
                end,
                'camel'
            )

        if is_defined(restrict_to_function):
            params['restrictToFunction'] = restrict_to_function

        return self._send_command(
            'Debugger.getPossibleBreakpoints',
            params,
            True,
            lambda data: from_dict(
                GetPossibleBreakpointsReturnType,
                data,
                'camel'
            )
        )

    def get_script_source(
            self,
            script_id: 'ScriptId'
    ) -> 'IFutureResponse[GetScriptSourceReturnType]':
        params = {
            'scriptId': to_dict(
                script_id,
                'camel'
            ),
        }

        return self._send_command(
            'Debugger.getScriptSource',
            params,
            True,
            lambda data: from_dict(
                GetScriptSourceReturnType,
                data,
                'camel'
            )
        )

    def get_stack_trace(
            self,
            stack_trace_id: 'StackTraceId'
    ) -> 'IFutureResponse[GetStackTraceReturnType]':
        params = {
            'stackTraceId': to_dict(
                stack_trace_id,
                'camel'
            ),
        }

        return self._send_command(
            'Debugger.getStackTrace',
            params,
            True,
            lambda data: from_dict(
                GetStackTraceReturnType,
                data,
                'camel'
            )
        )

    def pause(
            self
    ) -> 'IFutureResponse[None]':
        params = {}

        return self._send_command(
            'Debugger.pause',
            params,
            False
        )

    def pause_on_async_call(
            self,
            parent_stack_trace_id: 'StackTraceId'
    ) -> 'IFutureResponse[None]':
        params = {
            'parentStackTraceId': to_dict(
                parent_stack_trace_id,
                'camel'
            ),
        }

        return self._send_command(
            'Debugger.pauseOnAsyncCall',
            params,
            False
        )

    def remove_breakpoint(
            self,
            breakpoint_id: 'BreakpointId'
    ) -> 'IFutureResponse[None]':
        params = {
            'breakpointId': to_dict(
                breakpoint_id,
                'camel'
            ),
        }

        return self._send_command(
            'Debugger.removeBreakpoint',
            params,
            False
        )

    def restart_frame(
            self,
            call_frame_id: 'CallFrameId'
    ) -> 'IFutureResponse[RestartFrameReturnType]':
        params = {
            'callFrameId': to_dict(
                call_frame_id,
                'camel'
            ),
        }

        return self._send_command(
            'Debugger.restartFrame',
            params,
            True,
            lambda data: from_dict(
                RestartFrameReturnType,
                data,
                'camel'
            )
        )

    def resume(
            self
    ) -> 'IFutureResponse[None]':
        params = {}

        return self._send_command(
            'Debugger.resume',
            params,
            False
        )

    def search_in_content(
            self,
            script_id: 'ScriptId',
            query: 'str',
            case_sensitive: 'bool' = UNDEFINED,
            is_regex: 'bool' = UNDEFINED
    ) -> 'IFutureResponse[SearchInContentReturnType]':
        params = {
            'scriptId': to_dict(
                script_id,
                'camel'
            ),
            'query': query,
        }

        if is_defined(case_sensitive):
            params['caseSensitive'] = case_sensitive

        if is_defined(is_regex):
            params['isRegex'] = is_regex

        return self._send_command(
            'Debugger.searchInContent',
            params,
            True,
            lambda data: from_dict(
                SearchInContentReturnType,
                data,
                'camel'
            )
        )

    def set_async_call_stack_depth(
            self,
            max_depth: 'int'
    ) -> 'IFutureResponse[None]':
        params = {
            'maxDepth': max_depth,
        }

        return self._send_command(
            'Debugger.setAsyncCallStackDepth',
            params,
            False
        )

    def set_blackbox_patterns(
            self,
            patterns: 'list'
    ) -> 'IFutureResponse[None]':
        params = {
            'patterns': patterns,
        }

        return self._send_command(
            'Debugger.setBlackboxPatterns',
            params,
            False
        )

    def set_blackboxed_ranges(
            self,
            script_id: 'ScriptId',
            positions: 'list'
    ) -> 'IFutureResponse[None]':
        params = {
            'scriptId': to_dict(
                script_id,
                'camel'
            ),
            'positions': positions,
        }

        return self._send_command(
            'Debugger.setBlackboxedRanges',
            params,
            False
        )

    def set_breakpoint(
            self,
            location: 'Location',
            condition: 'str' = UNDEFINED
    ) -> 'IFutureResponse[SetBreakpointReturnType]':
        params = {
            'location': to_dict(
                location,
                'camel'
            ),
        }

        if is_defined(condition):
            params['condition'] = condition

        return self._send_command(
            'Debugger.setBreakpoint',
            params,
            True,
            lambda data: from_dict(
                SetBreakpointReturnType,
                data,
                'camel'
            )
        )

    def set_instrumentation_breakpoint(
            self,
            instrumentation: 'str'
    ) -> 'IFutureResponse[SetInstrumentationBreakpointReturnType]':
        params = {
            'instrumentation': instrumentation,
        }

        return self._send_command(
            'Debugger.setInstrumentationBreakpoint',
            params,
            True,
            lambda data: from_dict(
                SetInstrumentationBreakpointReturnType,
                data,
                'camel'
            )
        )

    def set_breakpoint_by_url(
            self,
            line_number: 'int',
            url: 'str' = UNDEFINED,
            url_regex: 'str' = UNDEFINED,
            script_hash: 'str' = UNDEFINED,
            column_number: 'int' = UNDEFINED,
            condition: 'str' = UNDEFINED
    ) -> 'IFutureResponse[SetBreakpointByUrlReturnType]':
        params = {
            'lineNumber': line_number,
        }

        if is_defined(url):
            params['url'] = url

        if is_defined(url_regex):
            params['urlRegex'] = url_regex

        if is_defined(script_hash):
            params['scriptHash'] = script_hash

        if is_defined(column_number):
            params['columnNumber'] = column_number

        if is_defined(condition):
            params['condition'] = condition

        return self._send_command(
            'Debugger.setBreakpointByUrl',
            params,
            True,
            lambda data: from_dict(
                SetBreakpointByUrlReturnType,
                data,
                'camel'
            )
        )

    def set_breakpoint_on_function_call(
            self,
            object_id: 'RemoteObjectId',
            condition: 'str' = UNDEFINED
    ) -> 'IFutureResponse[SetBreakpointOnFunctionCallReturnType]':
        params = {
            'objectId': to_dict(
                object_id,
                'camel'
            ),
        }

        if is_defined(condition):
            params['condition'] = condition

        return self._send_command(
            'Debugger.setBreakpointOnFunctionCall',
            params,
            True,
            lambda data: from_dict(
                SetBreakpointOnFunctionCallReturnType,
                data,
                'camel'
            )
        )

    def set_breakpoints_active(
            self,
            active: 'bool'
    ) -> 'IFutureResponse[None]':
        params = {
            'active': active,
        }

        return self._send_command(
            'Debugger.setBreakpointsActive',
            params,
            False
        )

    def set_pause_on_exceptions(
            self,
            state: 'str'
    ) -> 'IFutureResponse[None]':
        params = {
            'state': state,
        }

        return self._send_command(
            'Debugger.setPauseOnExceptions',
            params,
            False
        )

    def set_return_value(
            self,
            new_value: 'CallArgument'
    ) -> 'IFutureResponse[None]':
        params = {
            'newValue': to_dict(
                new_value,
                'camel'
            ),
        }

        return self._send_command(
            'Debugger.setReturnValue',
            params,
            False
        )

    def set_script_source(
            self,
            script_id: 'ScriptId',
            script_source: 'str',
            dry_run: 'bool' = UNDEFINED
    ) -> 'IFutureResponse[SetScriptSourceReturnType]':
        params = {
            'scriptId': to_dict(
                script_id,
                'camel'
            ),
            'scriptSource': script_source,
        }

        if is_defined(dry_run):
            params['dryRun'] = dry_run

        return self._send_command(
            'Debugger.setScriptSource',
            params,
            True,
            lambda data: from_dict(
                SetScriptSourceReturnType,
                data,
                'camel'
            )
        )

    def set_skip_all_pauses(
            self,
            skip: 'bool'
    ) -> 'IFutureResponse[None]':
        params = {
            'skip': skip,
        }

        return self._send_command(
            'Debugger.setSkipAllPauses',
            params,
            False
        )

    def set_variable_value(
            self,
            scope_number: 'int',
            variable_name: 'str',
            new_value: 'CallArgument',
            call_frame_id: 'CallFrameId'
    ) -> 'IFutureResponse[None]':
        params = {
            'scopeNumber': scope_number,
            'variableName': variable_name,
            'newValue': to_dict(
                new_value,
                'camel'
            ),
            'callFrameId': to_dict(
                call_frame_id,
                'camel'
            ),
        }

        return self._send_command(
            'Debugger.setVariableValue',
            params,
            False
        )

    def step_into(
            self,
            break_on_async_call: 'bool' = UNDEFINED
    ) -> 'IFutureResponse[None]':
        params = {}

        if is_defined(break_on_async_call):
            params['breakOnAsyncCall'] = break_on_async_call

        return self._send_command(
            'Debugger.stepInto',
            params,
            False
        )

    def step_out(
            self
    ) -> 'IFutureResponse[None]':
        params = {}

        return self._send_command(
            'Debugger.stepOut',
            params,
            False
        )

    def step_over(
            self
    ) -> 'IFutureResponse[None]':
        params = {}

        return self._send_command(
            'Debugger.stepOver',
            params,
            False
        )
