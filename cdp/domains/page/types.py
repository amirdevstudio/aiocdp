# DO NOT EDIT THIS FILE
#
# This file is generated by the generator. To make changes, edit the generator
# and run it again.

from typing import (
    Any,
    Literal,
    TYPE_CHECKING
)
from dataclasses import (
    dataclass
)
if TYPE_CHECKING:
    from cdp.domains.runtime.types import (
        ExecutionContextId,
        ScriptId,
        UniqueDebuggerId
    )
    from cdp.domains.network.types import (
        LoaderId,
        ResourceType,
        TimeSinceEpoch
    )
    from cdp.domains.dom.types import (
        Rect
    )
    from cdp.domains.io.types import (
        StreamHandle
    )
    from cdp.domains.emulation.types import (
        ScreenOrientation
    )

FrameId = str

ScriptIdentifier = str

AdFrameType = Literal[
    'none',
    'child',
    'root'
]

AdFrameExplanation = Literal[
    'ParentIsAd',
    'CreatedByAdScript',
    'MatchedBlockingRule'
]

SecureContextType = Literal[
    'Secure',
    'SecureLocalhost',
    'InsecureScheme',
    'InsecureAncestor'
]

CrossOriginIsolatedContextType = Literal[
    'Isolated',
    'NotIsolated',
    'NotIsolatedFeatureDisabled'
]

GatedAPIFeatures = Literal[
    'SharedArrayBuffers',
    'SharedArrayBuffersTransferAllowed',
    'PerformanceMeasureMemory',
    'PerformanceProfile'
]

PermissionsPolicyFeature = Literal[
    'accelerometer',
    'ambient-light-sensor',
    'attribution-reporting',
    'autoplay',
    'bluetooth',
    'browsing-topics',
    'camera',
    'ch-dpr',
    'ch-device-memory',
    'ch-downlink',
    'ch-ect',
    'ch-prefers-color-scheme',
    'ch-prefers-reduced-motion',
    'ch-prefers-reduced-transparency',
    'ch-rtt',
    'ch-save-data',
    'ch-ua',
    'ch-ua-arch',
    'ch-ua-bitness',
    'ch-ua-platform',
    'ch-ua-model',
    'ch-ua-mobile',
    'ch-ua-form-factor',
    'ch-ua-full-version',
    'ch-ua-full-version-list',
    'ch-ua-platform-version',
    'ch-ua-wow64',
    'ch-viewport-height',
    'ch-viewport-width',
    'ch-width',
    'clipboard-read',
    'clipboard-write',
    'compute-pressure',
    'cross-origin-isolated',
    'direct-sockets',
    'display-capture',
    'document-domain',
    'encrypted-media',
    'execution-while-out-of-viewport',
    'execution-while-not-rendered',
    'focus-without-user-activation',
    'fullscreen',
    'frobulate',
    'gamepad',
    'geolocation',
    'gyroscope',
    'hid',
    'identity-credentials-get',
    'idle-detection',
    'interest-cohort',
    'join-ad-interest-group',
    'keyboard-map',
    'local-fonts',
    'magnetometer',
    'microphone',
    'midi',
    'otp-credentials',
    'payment',
    'picture-in-picture',
    'private-aggregation',
    'private-state-token-issuance',
    'private-state-token-redemption',
    'publickey-credentials-get',
    'run-ad-auction',
    'screen-wake-lock',
    'serial',
    'shared-autofill',
    'shared-storage',
    'shared-storage-select-url',
    'smart-card',
    'storage-access',
    'sync-xhr',
    'unload',
    'usb',
    'vertical-scroll',
    'web-share',
    'window-management',
    'window-placement',
    'xr-spatial-tracking'
]

PermissionsPolicyBlockReason = Literal[
    'Header',
    'IframeAttribute',
    'InFencedFrameTree',
    'InIsolatedApp'
]

OriginTrialTokenStatus = Literal[
    'Success',
    'NotSupported',
    'Insecure',
    'Expired',
    'WrongOrigin',
    'InvalidSignature',
    'Malformed',
    'WrongVersion',
    'FeatureDisabled',
    'TokenDisabled',
    'FeatureDisabledForUser',
    'UnknownTrial'
]

OriginTrialStatus = Literal[
    'Enabled',
    'ValidTokenNotProvided',
    'OSNotSupported',
    'TrialNotAllowed'
]

OriginTrialUsageRestriction = Literal[
    'None',
    'Subset'
]

TransitionType = Literal[
    'link',
    'typed',
    'address_bar',
    'auto_bookmark',
    'auto_subframe',
    'manual_subframe',
    'generated',
    'auto_toplevel',
    'form_submit',
    'reload',
    'keyword',
    'keyword_generated',
    'other'
]

DialogType = Literal[
    'alert',
    'confirm',
    'prompt',
    'beforeunload'
]

ClientNavigationReason = Literal[
    'formSubmissionGet',
    'formSubmissionPost',
    'httpHeaderRefresh',
    'scriptInitiated',
    'metaTagRefresh',
    'pageBlockInterstitial',
    'reload',
    'anchorClick'
]

ClientNavigationDisposition = Literal[
    'currentTab',
    'newTab',
    'newWindow',
    'download'
]

ReferrerPolicy = Literal[
    'noReferrer',
    'noReferrerWhenDowngrade',
    'origin',
    'originWhenCrossOrigin',
    'sameOrigin',
    'strictOrigin',
    'strictOriginWhenCrossOrigin',
    'unsafeUrl'
]

AutoResponseMode = Literal[
    'none',
    'autoAccept',
    'autoReject',
    'autoOptOut'
]

NavigationType = Literal[
    'Navigation',
    'BackForwardCacheRestore'
]

BackForwardCacheNotRestoredReason = Literal[
    'NotPrimaryMainFrame',
    'BackForwardCacheDisabled',
    'RelatedActiveContentsExist',
    'HTTPStatusNotOK',
    'SchemeNotHTTPOrHTTPS',
    'Loading',
    'WasGrantedMediaAccess',
    'DisableForRenderFrameHostCalled',
    'DomainNotAllowed',
    'HTTPMethodNotGET',
    'SubframeIsNavigating',
    'Timeout',
    'CacheLimit',
    'JavaScriptExecution',
    'RendererProcessKilled',
    'RendererProcessCrashed',
    'SchedulerTrackedFeatureUsed',
    'ConflictingBrowsingInstance',
    'CacheFlushed',
    'ServiceWorkerVersionActivation',
    'SessionRestored',
    'ServiceWorkerPostMessage',
    'EnteredBackForwardCacheBeforeServiceWorkerHostAdded',
    'RenderFrameHostReused_SameSite',
    'RenderFrameHostReused_CrossSite',
    'ServiceWorkerClaim',
    'IgnoreEventAndEvict',
    'HaveInnerContents',
    'TimeoutPuttingInCache',
    'BackForwardCacheDisabledByLowMemory',
    'BackForwardCacheDisabledByCommandLine',
    'NetworkRequestDatapipeDrainedAsBytesConsumer',
    'NetworkRequestRedirected',
    'NetworkRequestTimeout',
    'NetworkExceedsBufferLimit',
    'NavigationCancelledWhileRestoring',
    'NotMostRecentNavigationEntry',
    'BackForwardCacheDisabledForPrerender',
    'UserAgentOverrideDiffers',
    'ForegroundCacheLimit',
    'BrowsingInstanceNotSwapped',
    'BackForwardCacheDisabledForDelegate',
    'UnloadHandlerExistsInMainFrame',
    'UnloadHandlerExistsInSubFrame',
    'ServiceWorkerUnregistration',
    'CacheControlNoStore',
    'CacheControlNoStoreCookieModified',
    'CacheControlNoStoreHTTPOnlyCookieModified',
    'NoResponseHead',
    'Unknown',
    'ActivationNavigationsDisallowedForBug1234857',
    'ErrorDocument',
    'FencedFramesEmbedder',
    'CookieDisabled',
    'HTTPAuthRequired',
    'CookieFlushed',
    'WebSocket',
    'WebTransport',
    'WebRTC',
    'MainResourceHasCacheControlNoStore',
    'MainResourceHasCacheControlNoCache',
    'SubresourceHasCacheControlNoStore',
    'SubresourceHasCacheControlNoCache',
    'ContainsPlugins',
    'DocumentLoaded',
    'DedicatedWorkerOrWorklet',
    'OutstandingNetworkRequestOthers',
    'RequestedMIDIPermission',
    'RequestedAudioCapturePermission',
    'RequestedVideoCapturePermission',
    'RequestedBackForwardCacheBlockedSensors',
    'RequestedBackgroundWorkPermission',
    'BroadcastChannel',
    'WebXR',
    'SharedWorker',
    'WebLocks',
    'WebHID',
    'WebShare',
    'RequestedStorageAccessGrant',
    'WebNfc',
    'OutstandingNetworkRequestFetch',
    'OutstandingNetworkRequestXHR',
    'AppBanner',
    'Printing',
    'WebDatabase',
    'PictureInPicture',
    'Portal',
    'SpeechRecognizer',
    'IdleManager',
    'PaymentManager',
    'SpeechSynthesis',
    'KeyboardLock',
    'WebOTPService',
    'OutstandingNetworkRequestDirectSocket',
    'InjectedJavascript',
    'InjectedStyleSheet',
    'KeepaliveRequest',
    'IndexedDBEvent',
    'Dummy',
    'JsNetworkRequestReceivedCacheControlNoStoreResource',
    'WebRTCSticky',
    'WebTransportSticky',
    'WebSocketSticky',
    'ContentSecurityHandler',
    'ContentWebAuthenticationAPI',
    'ContentFileChooser',
    'ContentSerial',
    'ContentFileSystemAccess',
    'ContentMediaDevicesDispatcherHost',
    'ContentWebBluetooth',
    'ContentWebUSB',
    'ContentMediaSessionService',
    'ContentScreenReader',
    'EmbedderPopupBlockerTabHelper',
    'EmbedderSafeBrowsingTriggeredPopupBlocker',
    'EmbedderSafeBrowsingThreatDetails',
    'EmbedderAppBannerManager',
    'EmbedderDomDistillerViewerSource',
    'EmbedderDomDistillerSelfDeletingRequestDelegate',
    'EmbedderOomInterventionTabHelper',
    'EmbedderOfflinePage',
    'EmbedderChromePasswordManagerClientBindCredentialManager',
    'EmbedderPermissionRequestManager',
    'EmbedderModalDialog',
    'EmbedderExtensions',
    'EmbedderExtensionMessaging',
    'EmbedderExtensionMessagingForOpenPort',
    'EmbedderExtensionSentMessageToCachedFrame'
]

BackForwardCacheNotRestoredReasonType = Literal[
    'SupportPending',
    'PageSupportNeeded',
    'Circumstantial'
]


@dataclass
class AdFrameStatus:
    ad_frame_type: 'AdFrameType'
    explanations: list
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'ad_frame_type': self.ad_frame_type,
                'explanations': _.to_dict(
                    casing_strategy
                )_explanations,
            }
        if casing_strategy == 'camel':
            return {
                'adFrameType': self.ad_frame_type,
                'explanations': _.to_dict(
                    casing_strategy
                )_explanations,
            }
        if casing_strategy == 'pascal':
            return {
                'AdFrameType': self.ad_frame_type,
                'Explanations': _.to_dict(
                    casing_strategy
                )_explanations,
            }


@dataclass
class AdScriptId:
    script_id: 'ScriptId'
    debugger_id: 'UniqueDebuggerId'
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'script_id': self.script_id.to_dict(
                    casing_strategy
                ),
                'debugger_id': self.debugger_id.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'camel':
            return {
                'scriptId': self.script_id.to_dict(
                    casing_strategy
                ),
                'debuggerId': self.debugger_id.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'pascal':
            return {
                'ScriptId': self.script_id.to_dict(
                    casing_strategy
                ),
                'DebuggerId': self.debugger_id.to_dict(
                    casing_strategy
                ),
            }


@dataclass
class PermissionsPolicyBlockLocator:
    frame_id: 'FrameId'
    block_reason: 'PermissionsPolicyBlockReason'
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'frame_id': self.frame_id.to_dict(
                    casing_strategy
                ),
                'block_reason': self.block_reason,
            }
        if casing_strategy == 'camel':
            return {
                'frameId': self.frame_id.to_dict(
                    casing_strategy
                ),
                'blockReason': self.block_reason,
            }
        if casing_strategy == 'pascal':
            return {
                'FrameId': self.frame_id.to_dict(
                    casing_strategy
                ),
                'BlockReason': self.block_reason,
            }


@dataclass
class PermissionsPolicyFeatureState:
    feature: 'PermissionsPolicyFeature'
    allowed: bool
    locator: 'PermissionsPolicyBlockLocator'
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'feature': self.feature,
                'allowed': self.allowed,
                'locator': self.locator.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'camel':
            return {
                'feature': self.feature,
                'allowed': self.allowed,
                'locator': self.locator.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'pascal':
            return {
                'Feature': self.feature,
                'Allowed': self.allowed,
                'Locator': self.locator.to_dict(
                    casing_strategy
                ),
            }


@dataclass
class OriginTrialToken:
    origin: str
    match_sub_domains: bool
    trial_name: str
    expiry_time: 'TimeSinceEpoch'
    is_third_party: bool
    usage_restriction: 'OriginTrialUsageRestriction'
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'origin': self.origin,
                'match_sub_domains': self.match_sub_domains,
                'trial_name': self.trial_name,
                'expiry_time': self.expiry_time.to_dict(
                    casing_strategy
                ),
                'is_third_party': self.is_third_party,
                'usage_restriction': self.usage_restriction,
            }
        if casing_strategy == 'camel':
            return {
                'origin': self.origin,
                'matchSubDomains': self.match_sub_domains,
                'trialName': self.trial_name,
                'expiryTime': self.expiry_time.to_dict(
                    casing_strategy
                ),
                'isThirdParty': self.is_third_party,
                'usageRestriction': self.usage_restriction,
            }
        if casing_strategy == 'pascal':
            return {
                'Origin': self.origin,
                'MatchSubDomains': self.match_sub_domains,
                'TrialName': self.trial_name,
                'ExpiryTime': self.expiry_time.to_dict(
                    casing_strategy
                ),
                'IsThirdParty': self.is_third_party,
                'UsageRestriction': self.usage_restriction,
            }


@dataclass
class OriginTrialTokenWithStatus:
    raw_token_text: str
    parsed_token: 'OriginTrialToken'
    status: 'OriginTrialTokenStatus'
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'raw_token_text': self.raw_token_text,
                'parsed_token': self.parsed_token.to_dict(
                    casing_strategy
                ),
                'status': self.status,
            }
        if casing_strategy == 'camel':
            return {
                'rawTokenText': self.raw_token_text,
                'parsedToken': self.parsed_token.to_dict(
                    casing_strategy
                ),
                'status': self.status,
            }
        if casing_strategy == 'pascal':
            return {
                'RawTokenText': self.raw_token_text,
                'ParsedToken': self.parsed_token.to_dict(
                    casing_strategy
                ),
                'Status': self.status,
            }


@dataclass
class OriginTrial:
    trial_name: str
    status: 'OriginTrialStatus'
    tokens_with_status: list
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'trial_name': self.trial_name,
                'status': self.status,
                'tokens_with_status': _.to_dict(
                    casing_strategy
                )_tokens_with_status,
            }
        if casing_strategy == 'camel':
            return {
                'trialName': self.trial_name,
                'status': self.status,
                'tokensWithStatus': _.to_dict(
                    casing_strategy
                )_tokens_with_status,
            }
        if casing_strategy == 'pascal':
            return {
                'TrialName': self.trial_name,
                'Status': self.status,
                'TokensWithStatus': _.to_dict(
                    casing_strategy
                )_tokens_with_status,
            }


@dataclass
class Frame:
    id: 'FrameId'
    parent_id: 'FrameId'
    loader_id: 'LoaderId'
    name: str
    url: str
    url_fragment: str
    domain_and_registry: str
    security_origin: str
    mime_type: str
    unreachable_url: str
    ad_frame_status: 'AdFrameStatus'
    secure_context_type: 'SecureContextType'
    cross_origin_isolated_context_type: 'CrossOriginIsolatedContextType'
    gated_api_features: list
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'id': self.id_.to_dict(
                    casing_strategy
                ),
                'parent_id': self.parent_id.to_dict(
                    casing_strategy
                ),
                'loader_id': self.loader_id.to_dict(
                    casing_strategy
                ),
                'name': self.name,
                'url': self.url,
                'url_fragment': self.url_fragment,
                'domain_and_registry': self.domain_and_registry,
                'security_origin': self.security_origin,
                'mime_type': self.mime_type,
                'unreachable_url': self.unreachable_url,
                'ad_frame_status': self.ad_frame_status.to_dict(
                    casing_strategy
                ),
                'secure_context_type': self.secure_context_type,
                'cross_origin_isolated_context_type': self.cross_origin_isolated_context_type,
                'gated_api_features': _.to_dict(
                    casing_strategy
                )_gated_api_features,
            }
        if casing_strategy == 'camel':
            return {
                'id': self.id_.to_dict(
                    casing_strategy
                ),
                'parentId': self.parent_id.to_dict(
                    casing_strategy
                ),
                'loaderId': self.loader_id.to_dict(
                    casing_strategy
                ),
                'name': self.name,
                'url': self.url,
                'urlFragment': self.url_fragment,
                'domainAndRegistry': self.domain_and_registry,
                'securityOrigin': self.security_origin,
                'mimeType': self.mime_type,
                'unreachableUrl': self.unreachable_url,
                'adFrameStatus': self.ad_frame_status.to_dict(
                    casing_strategy
                ),
                'secureContextType': self.secure_context_type,
                'crossOriginIsolatedContextType': self.cross_origin_isolated_context_type,
                'gatedAPIFeatures': _.to_dict(
                    casing_strategy
                )_gated_api_features,
            }
        if casing_strategy == 'pascal':
            return {
                'Id': self.id_.to_dict(
                    casing_strategy
                ),
                'ParentId': self.parent_id.to_dict(
                    casing_strategy
                ),
                'LoaderId': self.loader_id.to_dict(
                    casing_strategy
                ),
                'Name': self.name,
                'Url': self.url,
                'UrlFragment': self.url_fragment,
                'DomainAndRegistry': self.domain_and_registry,
                'SecurityOrigin': self.security_origin,
                'MimeType': self.mime_type,
                'UnreachableUrl': self.unreachable_url,
                'AdFrameStatus': self.ad_frame_status.to_dict(
                    casing_strategy
                ),
                'SecureContextType': self.secure_context_type,
                'CrossOriginIsolatedContextType': self.cross_origin_isolated_context_type,
                'GatedAPIFeatures': _.to_dict(
                    casing_strategy
                )_gated_api_features,
            }


@dataclass
class FrameResource:
    url: str
    type: 'ResourceType'
    mime_type: str
    last_modified: 'TimeSinceEpoch'
    content_size: float
    failed: bool
    canceled: bool
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'url': self.url,
                'type': self.type_,
                'mime_type': self.mime_type,
                'last_modified': self.last_modified.to_dict(
                    casing_strategy
                ),
                'content_size': self.content_size,
                'failed': self.failed,
                'canceled': self.canceled,
            }
        if casing_strategy == 'camel':
            return {
                'url': self.url,
                'type': self.type_,
                'mimeType': self.mime_type,
                'lastModified': self.last_modified.to_dict(
                    casing_strategy
                ),
                'contentSize': self.content_size,
                'failed': self.failed,
                'canceled': self.canceled,
            }
        if casing_strategy == 'pascal':
            return {
                'Url': self.url,
                'Type': self.type_,
                'MimeType': self.mime_type,
                'LastModified': self.last_modified.to_dict(
                    casing_strategy
                ),
                'ContentSize': self.content_size,
                'Failed': self.failed,
                'Canceled': self.canceled,
            }


@dataclass
class FrameResourceTree:
    frame: 'Frame'
    child_frames: list
    resources: list
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'frame': self.frame.to_dict(
                    casing_strategy
                ),
                'child_frames': _.to_dict(
                    casing_strategy
                )_child_frames,
                'resources': _.to_dict(
                    casing_strategy
                )_resources,
            }
        if casing_strategy == 'camel':
            return {
                'frame': self.frame.to_dict(
                    casing_strategy
                ),
                'childFrames': _.to_dict(
                    casing_strategy
                )_child_frames,
                'resources': _.to_dict(
                    casing_strategy
                )_resources,
            }
        if casing_strategy == 'pascal':
            return {
                'Frame': self.frame.to_dict(
                    casing_strategy
                ),
                'ChildFrames': _.to_dict(
                    casing_strategy
                )_child_frames,
                'Resources': _.to_dict(
                    casing_strategy
                )_resources,
            }


@dataclass
class FrameTree:
    frame: 'Frame'
    child_frames: list
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'frame': self.frame.to_dict(
                    casing_strategy
                ),
                'child_frames': _.to_dict(
                    casing_strategy
                )_child_frames,
            }
        if casing_strategy == 'camel':
            return {
                'frame': self.frame.to_dict(
                    casing_strategy
                ),
                'childFrames': _.to_dict(
                    casing_strategy
                )_child_frames,
            }
        if casing_strategy == 'pascal':
            return {
                'Frame': self.frame.to_dict(
                    casing_strategy
                ),
                'ChildFrames': _.to_dict(
                    casing_strategy
                )_child_frames,
            }


@dataclass
class NavigationEntry:
    id: int
    url: str
    user_typed_url: str
    title: str
    transition_type: 'TransitionType'
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'id': self.id_,
                'url': self.url,
                'user_typed_url': self.user_typed_url,
                'title': self.title,
                'transition_type': self.transition_type,
            }
        if casing_strategy == 'camel':
            return {
                'id': self.id_,
                'url': self.url,
                'userTypedURL': self.user_typed_url,
                'title': self.title,
                'transitionType': self.transition_type,
            }
        if casing_strategy == 'pascal':
            return {
                'Id': self.id_,
                'Url': self.url,
                'UserTypedURL': self.user_typed_url,
                'Title': self.title,
                'TransitionType': self.transition_type,
            }


@dataclass
class ScreencastFrameMetadata:
    offset_top: float
    page_scale_factor: float
    device_width: float
    device_height: float
    scroll_offset_x: float
    scroll_offset_y: float
    timestamp: 'TimeSinceEpoch'
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'offset_top': self.offset_top,
                'page_scale_factor': self.page_scale_factor,
                'device_width': self.device_width,
                'device_height': self.device_height,
                'scroll_offset_x': self.scroll_offset_x,
                'scroll_offset_y': self.scroll_offset_y,
                'timestamp': self.timestamp.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'camel':
            return {
                'offsetTop': self.offset_top,
                'pageScaleFactor': self.page_scale_factor,
                'deviceWidth': self.device_width,
                'deviceHeight': self.device_height,
                'scrollOffsetX': self.scroll_offset_x,
                'scrollOffsetY': self.scroll_offset_y,
                'timestamp': self.timestamp.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'pascal':
            return {
                'OffsetTop': self.offset_top,
                'PageScaleFactor': self.page_scale_factor,
                'DeviceWidth': self.device_width,
                'DeviceHeight': self.device_height,
                'ScrollOffsetX': self.scroll_offset_x,
                'ScrollOffsetY': self.scroll_offset_y,
                'Timestamp': self.timestamp.to_dict(
                    casing_strategy
                ),
            }


@dataclass
class AppManifestError:
    message: str
    critical: int
    line: int
    column: int
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'message': self.message,
                'critical': self.critical,
                'line': self.line,
                'column': self.column,
            }
        if casing_strategy == 'camel':
            return {
                'message': self.message,
                'critical': self.critical,
                'line': self.line,
                'column': self.column,
            }
        if casing_strategy == 'pascal':
            return {
                'Message': self.message,
                'Critical': self.critical,
                'Line': self.line,
                'Column': self.column,
            }


@dataclass
class AppManifestParsedProperties:
    scope: str
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'scope': self.scope,
            }
        if casing_strategy == 'camel':
            return {
                'scope': self.scope,
            }
        if casing_strategy == 'pascal':
            return {
                'Scope': self.scope,
            }


@dataclass
class LayoutViewport:
    page_x: int
    page_y: int
    client_width: int
    client_height: int
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'page_x': self.page_x,
                'page_y': self.page_y,
                'client_width': self.client_width,
                'client_height': self.client_height,
            }
        if casing_strategy == 'camel':
            return {
                'pageX': self.page_x,
                'pageY': self.page_y,
                'clientWidth': self.client_width,
                'clientHeight': self.client_height,
            }
        if casing_strategy == 'pascal':
            return {
                'PageX': self.page_x,
                'PageY': self.page_y,
                'ClientWidth': self.client_width,
                'ClientHeight': self.client_height,
            }


@dataclass
class VisualViewport:
    offset_x: float
    offset_y: float
    page_x: float
    page_y: float
    client_width: float
    client_height: float
    scale: float
    zoom: float
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'offset_x': self.offset_x,
                'offset_y': self.offset_y,
                'page_x': self.page_x,
                'page_y': self.page_y,
                'client_width': self.client_width,
                'client_height': self.client_height,
                'scale': self.scale,
                'zoom': self.zoom,
            }
        if casing_strategy == 'camel':
            return {
                'offsetX': self.offset_x,
                'offsetY': self.offset_y,
                'pageX': self.page_x,
                'pageY': self.page_y,
                'clientWidth': self.client_width,
                'clientHeight': self.client_height,
                'scale': self.scale,
                'zoom': self.zoom,
            }
        if casing_strategy == 'pascal':
            return {
                'OffsetX': self.offset_x,
                'OffsetY': self.offset_y,
                'PageX': self.page_x,
                'PageY': self.page_y,
                'ClientWidth': self.client_width,
                'ClientHeight': self.client_height,
                'Scale': self.scale,
                'Zoom': self.zoom,
            }


@dataclass
class Viewport:
    x: float
    y: float
    width: float
    height: float
    scale: float
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'x': self.x,
                'y': self.y,
                'width': self.width,
                'height': self.height,
                'scale': self.scale,
            }
        if casing_strategy == 'camel':
            return {
                'x': self.x,
                'y': self.y,
                'width': self.width,
                'height': self.height,
                'scale': self.scale,
            }
        if casing_strategy == 'pascal':
            return {
                'X': self.x,
                'Y': self.y,
                'Width': self.width,
                'Height': self.height,
                'Scale': self.scale,
            }


@dataclass
class FontFamilies:
    standard: str
    fixed: str
    serif: str
    sans_serif: str
    cursive: str
    fantasy: str
    math: str
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'standard': self.standard,
                'fixed': self.fixed,
                'serif': self.serif,
                'sans_serif': self.sans_serif,
                'cursive': self.cursive,
                'fantasy': self.fantasy,
                'math': self.math,
            }
        if casing_strategy == 'camel':
            return {
                'standard': self.standard,
                'fixed': self.fixed,
                'serif': self.serif,
                'sansSerif': self.sans_serif,
                'cursive': self.cursive,
                'fantasy': self.fantasy,
                'math': self.math,
            }
        if casing_strategy == 'pascal':
            return {
                'Standard': self.standard,
                'Fixed': self.fixed,
                'Serif': self.serif,
                'SansSerif': self.sans_serif,
                'Cursive': self.cursive,
                'Fantasy': self.fantasy,
                'Math': self.math,
            }


@dataclass
class ScriptFontFamilies:
    script: str
    font_families: 'FontFamilies'
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'script': self.script,
                'font_families': self.font_families.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'camel':
            return {
                'script': self.script,
                'fontFamilies': self.font_families.to_dict(
                    casing_strategy
                ),
            }
        if casing_strategy == 'pascal':
            return {
                'Script': self.script,
                'FontFamilies': self.font_families.to_dict(
                    casing_strategy
                ),
            }


@dataclass
class FontSizes:
    standard: int
    fixed: int
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'standard': self.standard,
                'fixed': self.fixed,
            }
        if casing_strategy == 'camel':
            return {
                'standard': self.standard,
                'fixed': self.fixed,
            }
        if casing_strategy == 'pascal':
            return {
                'Standard': self.standard,
                'Fixed': self.fixed,
            }


@dataclass
class InstallabilityErrorArgument:
    name: str
    value: str
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'name': self.name,
                'value': self.value,
            }
        if casing_strategy == 'camel':
            return {
                'name': self.name,
                'value': self.value,
            }
        if casing_strategy == 'pascal':
            return {
                'Name': self.name,
                'Value': self.value,
            }


@dataclass
class InstallabilityError:
    error_id: str
    error_arguments: list
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'error_id': self.error_id,
                'error_arguments': _.to_dict(
                    casing_strategy
                )_error_arguments,
            }
        if casing_strategy == 'camel':
            return {
                'errorId': self.error_id,
                'errorArguments': _.to_dict(
                    casing_strategy
                )_error_arguments,
            }
        if casing_strategy == 'pascal':
            return {
                'ErrorId': self.error_id,
                'ErrorArguments': _.to_dict(
                    casing_strategy
                )_error_arguments,
            }


@dataclass
class CompilationCacheParams:
    url: str
    eager: bool
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'url': self.url,
                'eager': self.eager,
            }
        if casing_strategy == 'camel':
            return {
                'url': self.url,
                'eager': self.eager,
            }
        if casing_strategy == 'pascal':
            return {
                'Url': self.url,
                'Eager': self.eager,
            }


@dataclass
class BackForwardCacheNotRestoredExplanation:
    type: 'BackForwardCacheNotRestoredReasonType'
    reason: 'BackForwardCacheNotRestoredReason'
    context: str
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'type': self.type_,
                'reason': self.reason,
                'context': self.context,
            }
        if casing_strategy == 'camel':
            return {
                'type': self.type_,
                'reason': self.reason,
                'context': self.context,
            }
        if casing_strategy == 'pascal':
            return {
                'Type': self.type_,
                'Reason': self.reason,
                'Context': self.context,
            }


@dataclass
class BackForwardCacheNotRestoredExplanationTree:
    url: str
    explanations: list
    children: list
    def to_dict(
        self,
        casing_strategy: Literal[
            'snake',
            'camel',
            'pascal'
        ] = 'snake'
    ):

        if casing_strategy == 'snake':
            return {
                'url': self.url,
                'explanations': _.to_dict(
                    casing_strategy
                )_explanations,
                'children': _.to_dict(
                    casing_strategy
                )_children,
            }
        if casing_strategy == 'camel':
            return {
                'url': self.url,
                'explanations': _.to_dict(
                    casing_strategy
                )_explanations,
                'children': _.to_dict(
                    casing_strategy
                )_children,
            }
        if casing_strategy == 'pascal':
            return {
                'Url': self.url,
                'Explanations': _.to_dict(
                    casing_strategy
                )_explanations,
                'Children': _.to_dict(
                    casing_strategy
                )_children,
            }


@dataclass
class AddScriptToEvaluateOnLoadReturnT:
    identifier: 'ScriptIdentifier'


@dataclass
class AddScriptToEvaluateOnNewDocumentReturnT:
    identifier: 'ScriptIdentifier'


@dataclass
class CaptureScreenshotReturnT:
    data: str


@dataclass
class CaptureSnapshotReturnT:
    data: str


@dataclass
class CreateIsolatedWorldReturnT:
    execution_context_id: 'ExecutionContextId'


@dataclass
class GetAppManifestReturnT:
    url: str
    errors: list
    data: str
    parsed: 'AppManifestParsedProperties'


@dataclass
class GetInstallabilityErrorsReturnT:
    installability_errors: list


@dataclass
class GetManifestIconsReturnT:
    primary_icon: str


@dataclass
class GetAppIdReturnT:
    app_id: str
    recommended_id: str


@dataclass
class GetAdScriptIdReturnT:
    ad_script_id: 'AdScriptId'


@dataclass
class GetCookiesReturnT:
    cookies: list


@dataclass
class GetFrameTreeReturnT:
    frame_tree: 'FrameTree'


@dataclass
class GetLayoutMetricsReturnT:
    layout_viewport: 'LayoutViewport'
    visual_viewport: 'VisualViewport'
    content_size: 'Rect'
    css_layout_viewport: 'LayoutViewport'
    css_visual_viewport: 'VisualViewport'
    css_content_size: 'Rect'


@dataclass
class GetNavigationHistoryReturnT:
    current_index: int
    entries: list


@dataclass
class GetResourceContentReturnT:
    content: str
    base64_encoded: bool


@dataclass
class GetResourceTreeReturnT:
    frame_tree: 'FrameResourceTree'


@dataclass
class NavigateReturnT:
    frame_id: 'FrameId'
    loader_id: 'LoaderId'
    error_text: str


@dataclass
class PrintToPDFReturnT:
    data: str
    stream: 'StreamHandle'


@dataclass
class SearchInResourceReturnT:
    result: list


@dataclass
class GetPermissionsPolicyStateReturnT:
    states: list


@dataclass
class GetOriginTrialsReturnT:
    origin_trials: list
